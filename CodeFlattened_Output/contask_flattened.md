Repository Summary:
Files analyzed: 134
Directories scanned: 486
Total size: 873.75 KB (894722 bytes)
Estimated tokens: 223680
Processing time: 0.55 seconds


## Table of Contents

- [Project Summary](#project-summary)
- [Directory Structure](#directory-structure)
- [Files Content](#files-content)
  - Files By Category:
    - C/C++ (17 files):
      - [flutter_window.cpp](#flutter_window_cpp) - 2.1 KB
      - [flutter_window.h](#flutter_window_h) - 961 bytes
      - [generated_plugin_registrant.cc](#generated_plugin_registrant_cc) - 673 bytes
      - [generated_plugin_registrant.cc](#generated_plugin_registrant_cc) - 161 bytes
      - [generated_plugin_registrant.h](#generated_plugin_registrant_h) - 303 bytes
      - [generated_plugin_registrant.h](#generated_plugin_registrant_h) - 302 bytes
      - [GeneratedPluginRegistrant.h](#GeneratedPluginRegistrant_h) - 378 bytes
      - [main.cc](#main_cc) - 186 bytes
      - [main.cpp](#main_cpp) - 1.3 KB
      - [my_application.cc](#my_application_cc) - 4.8 KB
      - [and 7 more C/C++ files...]
    - Configuration (15 files):
      - [.gitignore](#_gitignore) - 603 bytes
      - [.gitignore](#_gitignore) - 96 bytes
      - [.gitignore](#_gitignore) - 267 bytes
      - [.gitignore](#_gitignore) - 19 bytes
      - [.gitignore](#_gitignore) - 308 bytes
      - [.gitignore](#_gitignore) - 754 bytes
      - [analysis_options.yaml](#analysis_options_yaml) - 1.4 KB
      - [Contents.json](#Contents_json) - 414 bytes
      - [Contents.json](#Contents_json) - 2.6 KB
      - [Contents.json](#Contents_json) - 1.3 KB
      - [and 5 more Configuration files...]
    - Documentation (10 files):
      - [CHECKLIST_DESENVOLVIMENTO.md](#CHECKLIST_DESENVOLVIMENTO_md) - 10.7 KB
      - [README.md](#README_md) - 340 bytes
      - [README.md](#README_md) - 566 bytes
      - [rule1.md](#rule1_md) - 184 bytes
      - [SPEC_GERAL.md](#SPEC_GERAL_md) - 17.8 KB
      - [SPEC_MY_ATUAL_BASE.md](#SPEC_MY_ATUAL_BASE_md) - 1.3 KB
      - [TESTE_FASE2.md](#TESTE_FASE2_md) - 8.0 KB
      - [TESTE_FASE3_AJUSTES.md](#TESTE_FASE3_AJUSTES_md) - 8.4 KB
      - [TESTE_FASE3.md](#TESTE_FASE3_md) - 11.8 KB
      - [volunteer_management_optimization_analysis.md](#volunteer_management_optimization_analysis_md) - 6.4 KB
    - Java (1 files):
      - [GeneratedPluginRegistrant.java](#GeneratedPluginRegistrant_java) - 2.1 KB
    - Kotlin (4 files):
      - [build.gradle.kts](#build_gradle_kts) - 1.5 KB
      - [build.gradle.kts](#build_gradle_kts) - 536 bytes
      - [MainActivity.kt](#MainActivity_kt) - 126 bytes
      - [settings.gradle.kts](#settings_gradle_kts) - 912 bytes
    - Other (6 files):
      - [.cursorignore](#_cursorignore) - 791 bytes
      - [.flattenignore](#_flattenignore) - 28 bytes
      - [.metadata](#_metadata) - 1.7 KB
      - [alteracao_corrente](#alteracao_corrente) - 1.3 KB
      - [flutter_lldbinit](#flutter_lldbinit) - 108 bytes
      - [gradlew](#gradlew) - 4.9 KB
    - Other (dart) (64 files):
      - [app_colors.dart](#app_colors_dart) - 2.4 KB
      - [app_constants.dart](#app_constants_dart) - 5.3 KB
      - [app_dimensions.dart](#app_dimensions_dart) - 3.3 KB
      - [app_exceptions.dart](#app_exceptions_dart) - 9.6 KB
      - [app_routes.dart](#app_routes_dart) - 6.9 KB
      - [app_strings.dart](#app_strings_dart) - 5.8 KB
      - [app_theme.dart](#app_theme_dart) - 9.0 KB
      - [assignment_dialog.dart](#assignment_dialog_dart) - 14.6 KB
      - [assignment_screen.dart](#assignment_screen_dart) - 20.1 KB
      - [assignment_service.dart](#assignment_service_dart) - 13.9 KB
      - [and 54 more Other (dart) files...]
    - Other (sh) (2 files):
      - [flutter_export_environment.sh](#flutter_export_environment_sh) - 562 bytes
      - [flutter_export_environment.sh](#flutter_export_environment_sh) - 600 bytes
    - Other (xml) (7 files):
      - [AndroidManifest.xml](#AndroidManifest_xml) - 385 bytes
      - [AndroidManifest.xml](#AndroidManifest_xml) - 2.2 KB
      - [AndroidManifest.xml](#AndroidManifest_xml) - 385 bytes
      - [launch_background.xml](#launch_background_xml) - 446 bytes
      - [launch_background.xml](#launch_background_xml) - 450 bytes
      - [styles.xml](#styles_xml) - 1014 bytes
      - [styles.xml](#styles_xml) - 1013 bytes
    - Python (1 files):
      - [flutter_lldb_helper.py](#flutter_lldb_helper_py) - 1.2 KB
    - Swift (6 files):
      - [AppDelegate.swift](#AppDelegate_swift) - 324 bytes
      - [AppDelegate.swift](#AppDelegate_swift) - 404 bytes
      - [GeneratedPluginRegistrant.swift](#GeneratedPluginRegistrant_swift) - 850 bytes
      - [MainFlutterWindow.swift](#MainFlutterWindow_swift) - 403 bytes
      - [RunnerTests.swift](#RunnerTests_swift) - 302 bytes
      - [RunnerTests.swift](#RunnerTests_swift) - 297 bytes
    - Web (1 files):
      - [index.html](#index_html) - 1.2 KB
- [Architecture and Relationships](#architecture-and-relationships)
  - [File Dependencies](#file-dependencies)
  - [Class Relationships](#class-relationships)
  - [Component Interactions](#component-interactions)

## Project Summary <a id="project-summary"></a>

# Project Digest: contask
Generated on: Wed Jul 16 2025 00:36:19 GMT-0400 (Hor√°rio Padr√£o do Amazonas)
Source: c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask
Project Directory: c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask

# Directory Structure
[DIR] .
  [DIR] .augment
    [DIR] rules
      [FILE] rule1.md
  [DIR] .cursor
    [DIR] rules
  [FILE] .cursorignore
  [DIR] .dart_tool
    [DIR] chrome-device
      [DIR] Default
        [FILE] Account Web Data
        [FILE] Account Web Data-journal
        [DIR] Accounts
          [DIR] Avatar Images
            [FILE] 111116540463525924020
        [FILE] Affiliation Database
        [FILE] Affiliation Database-journal
        [DIR] AutofillStrikeDatabase
          [FILE] LOCK
          [FILE] LOG
        [DIR] blob_storage
          [DIR] 04e432a0-a5e4-4d68-b635-e4f8a6598756
          [DIR] 1390ea01-af99-4da6-b98b-7bb25c619a5d
          [DIR] 1ac3c983-e218-4703-9a05-9370878dfa32
          [DIR] 1b5a0508-6055-452b-801e-c9cea678be81
          [DIR] 24e66e04-3e7a-4055-a91c-ea6dd2fea634
          [DIR] 255ce91b-4fc6-47ad-b327-9cd30e7e8165
          [DIR] 28402845-953d-4071-81fc-4d109c749fda
          [DIR] 370e0294-50ff-431b-90b7-8d3434649a80
          [DIR] 3f512159-480b-462b-af48-5a9dcba5d9b9
          [DIR] 4a318ed8-79ee-4d4c-9cc9-2a78db23177c
          [DIR] 4fd329b6-9cb5-442b-84ab-f1bc2f621048
          [DIR] 5dd4be51-dd8b-493a-b647-cb63645730db
          [DIR] 6362e28d-3174-4fd1-8d8e-38235920ffec
          [DIR] 6ce7b1c7-e4f3-4157-a859-5f493fb96f45
          [DIR] 71156b28-5276-4001-baf8-52c76c74ebfc
          [DIR] 723f30b7-449b-4e48-b6ec-60201b3940b6
          [DIR] 735995f0-6ebe-4a21-bda5-df46aaa94ca2
          [DIR] 74784d3e-1e8a-4197-b2fc-d480bf3e0633
          [DIR] 75f6644e-765e-435d-a194-4798f8bb8a40
          [DIR] 83ba1ad3-2e7f-4c10-b1ab-ff07e186cbbb
          [DIR] 8556b08e-01e6-48d7-9484-3e29510ee6bb
          [DIR] 8d50532f-5a10-4511-8915-405bff9b0136
          [DIR] 92229a1f-f96c-488c-b472-ae757326aa70
          [DIR] a31eb727-b542-458f-8fdf-a533f28b672d
          [DIR] ae04463b-1dec-47bd-8057-c968c927131b
          [DIR] b39effb1-ab82-477d-b926-489982f3b916
          [DIR] b502c5d4-06d1-47f2-8716-7580f96df2a5
          [DIR] b6d21a3f-855b-4307-9f25-26a8faa92383
          [DIR] bb2aa6b1-a837-4aea-8fbc-a12bb43db2f3
          [DIR] c18e9918-c7ca-4087-bd6a-ad3d879b9131
          [DIR] c2bac190-b185-43e0-bb9e-ac84e2f00502
          [DIR] d4aeee84-215a-40ee-89d1-bc7e687c4686
          [DIR] d64f206c-f89f-4588-b7aa-8edb5903570a
          [DIR] db114962-7d9c-43ba-8ea4-7e88ce596620
          [DIR] dc14a313-a79a-4fe0-922a-e11d87d0c2c1
          [DIR] dc92433f-ac2f-4217-8a22-ee8c41814a0c
          [DIR] ebb5edb9-457d-4339-b692-94a48cfd83ed
          [DIR] eeac14b5-83a5-45de-a2af-1f2a44eef124
          [DIR] f33dd95b-cd36-4068-9751-c9011362452c
          [DIR] fa887f48-112c-47b6-9d3f-9be22f379661
        [FILE] BookmarkMergedSurfaceOrdering
        [FILE] BrowsingTopicsSiteData
        [FILE] BrowsingTopicsSiteData-journal
        [FILE] BrowsingTopicsState
        [DIR] BudgetDatabase
          [FILE] LOCK
          [FILE] LOG
        [DIR] chrome_cart_db
          [FILE] LOCK
          [FILE] LOG
        [DIR] ClientCertificates
          [FILE] LOCK
          [FILE] LOG
        [DIR] commerce_subscription_db
          [FILE] LOCK
          [FILE] LOG
        [FILE] DIPS
        [FILE] DIPS-wal
        [DIR] discounts_db
          [FILE] LOCK
          [FILE] LOG
        [DIR] Download Service
          [DIR] EntryDB
            [FILE] LOCK
            [FILE] LOG
          [DIR] Files
        [DIR] Extension Rules
          [FILE] CURRENT
          [FILE] LOCK
          [FILE] LOG
          [FILE] MANIFEST-000001
        [DIR] Extension Scripts
          [FILE] CURRENT
          [FILE] LOCK
          [FILE] LOG
          [FILE] MANIFEST-000001
        [DIR] Extension State
          [FILE] CURRENT
          [FILE] LOCK
          [FILE] LOG
          [FILE] MANIFEST-000001
        [FILE] Favicons
        [FILE] Favicons-journal
        [DIR] Feature Engagement Tracker
          [DIR] AvailabilityDB
            [FILE] LOCK
            [FILE] LOG
          [DIR] EventDB
            [FILE] LOCK
            [FILE] LOG
        [DIR] GCM Store
          [FILE] CURRENT
          [DIR] Encryption
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [FILE] LOCK
          [FILE] LOG
          [FILE] MANIFEST-000001
        [FILE] History
        [FILE] History-journal
        [DIR] IndexedDB
          [DIR] http_localhost_49500.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_50584.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_50816.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_51156.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_51301.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_51357.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_51408.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_51500.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_51791.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_51953.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_52598.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_52900.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_52907.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_53014.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_53269.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_53678.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_53781.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_54425.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_56024.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_56232.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_57296.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_57319.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_57595.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_58103.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_58700.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_58999.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_60298.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_60461.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_60890.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_61247.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_61587.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_62963.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_62978.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_63303.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_63328.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_64318.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_64443.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_64817.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_65090.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] http_localhost_65448.indexeddb.leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
        [DIR] Local Storage
          [DIR] leveldb
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
        [FILE] LOCK
        [FILE] LOG
        [FILE] Login Data
        [FILE] Login Data For Account
        [FILE] Login Data For Account-journal
        [FILE] Login Data-journal
        [FILE] MediaDeviceSalts
        [FILE] MediaDeviceSalts-journal
        [DIR] Network
          [FILE] Cookies
          [FILE] Cookies-journal
          [FILE] Network Persistent State
          [FILE] NetworkDataMigrated
          [FILE] Reporting and NEL
          [FILE] Reporting and NEL-journal
          [FILE] SCT Auditing Pending Reports
          [FILE] TransportSecurity
        [FILE] Network Action Predictor
        [FILE] Network Action Predictor-journal
        [DIR] optimization_guide_hint_cache_store
          [FILE] LOCK
          [FILE] LOG
        [DIR] parcel_tracking_db
          [FILE] LOCK
          [FILE] LOG
        [FILE] passkey_enclave_state
        [DIR] PersistentOriginTrials
          [FILE] LOCK
          [FILE] LOG
        [FILE] Preferences
        [FILE] PreferredApps
        [FILE] README
        [DIR] Safe Browsing Network
          [FILE] NetworkDataMigrated
          [FILE] Safe Browsing Cookies
          [FILE] Safe Browsing Cookies-journal
        [FILE] Secure Preferences
        [DIR] Segmentation Platform
          [DIR] SegmentInfoDB
            [FILE] LOCK
            [FILE] LOG
          [DIR] SignalDB
            [FILE] LOCK
            [FILE] LOG
          [DIR] SignalStorageConfigDB
            [FILE] LOCK
            [FILE] LOG
        [FILE] ServerCertificate
        [FILE] ServerCertificate-journal
        [DIR] Service Worker
          [DIR] Database
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
          [DIR] ScriptCache
            [FILE] 013888a1cda32b90_0
            [FILE] 035aa9dff41235ca_0
            [FILE] 08b99d499107ba17_0
            [FILE] 0ae129c33e7a30bd_0
            [FILE] 0b3d59c1b2221f76_0
            [FILE] 0d3086d7cda635d4_0
            [FILE] 14d9579db3cecf92_0
            [FILE] 23469ac906fcc612_0
            [FILE] 2687cdb408524ecb_0
            [FILE] 297ecea5cebb5dfe_0
            [FILE] 2a0afd649b00527b_0
            [FILE] 2beb0213504d07fc_0
            [FILE] 2cc80dabc69f58b6_0
            [FILE] 3ef2ebed6c12e1f6_0
            [FILE] 45c2f2fcb9072b47_0
            [FILE] 4cb013792b196a35_0
            [FILE] 4cb013792b196a35_1
            [FILE] 5ce2b92834133eaf_0
            [FILE] 653e56b4b6556a9e_0
            [FILE] 67a473248953641b_0
            [FILE] 6c038e3570d6abf1_0
            [FILE] 6f8ac775dbbd7415_0
            [FILE] 6fc459ba53cb570a_0
            [FILE] 7b4fd8111178d5b1_0
            [FILE] 83efbe48d0097388_0
            [FILE] 8a729281c4672a97_0
            [FILE] 91baa182c7a11977_0
            [FILE] ad0c92dfa52e69b6_0
            [FILE] afe1e5264eea33bc_0
            [FILE] b2efa64ecb36f8f1_0
            [FILE] b3bd0d67f800d222_0
            [FILE] b6c28cea6ed9dfc1_0
            [FILE] ba23d8ecda68de77_0
            [FILE] ce2a2172c04b134d_0
            [FILE] d0757ff92c7cde0a_0
            [FILE] d10f805e771d7acb_0
            [FILE] e0d37c7e54672663_0
            [FILE] f0de8c2de34c385b_0
            [FILE] f13a76bbf6c7f0b3_0
            [FILE] f1cdccba37924bda_0
            [FILE] f3ab1e1292e135fa_0
            [FILE] f76ccbbbd72a0391_0
            [FILE] fa813c9ad67834ac_0
            [FILE] fb1f328d70d91607_0
            [FILE] index
            [DIR] index-dir
              [FILE] the-real-index
        [DIR] Session Storage
          [FILE] CURRENT
          [FILE] LOCK
          [FILE] LOG
          [FILE] MANIFEST-000001
        [DIR] Sessions
          [FILE] Session_13396901585636670
          [FILE] Session_13396903173366843
          [FILE] Session_13396905228534288
          [FILE] Session_13396905342855734
          [FILE] Session_13396906225226699
          [FILE] Session_13396906492634159
          [FILE] Session_13396906682960149
          [FILE] Session_13396907217208829
          [FILE] Session_13396909992187229
          [FILE] Session_13396910158867899
          [FILE] Session_13396910458256520
          [FILE] Session_13396911236362782
          [FILE] Session_13396911672972511
          [FILE] Session_13396912349289506
          [FILE] Session_13396914423547471
          [FILE] Session_13396917062846728
          [FILE] Session_13396918108237470
          [FILE] Session_13396929934666894
          [FILE] Session_13396930605372879
          [FILE] Session_13396931332739293
          [FILE] Session_13396934443288231
          [FILE] Session_13396934939298231
          [FILE] Session_13396935947428450
          [FILE] Session_13396938406950721
          [FILE] Session_13396943714241196
          [FILE] Session_13396944049900172
          [FILE] Session_13396945525468770
          [FILE] Session_13397013371371651
          [FILE] Session_13397016036225865
          [FILE] Session_13397016782889541
          [FILE] Session_13397017685502108
          [FILE] Session_13397020562539259
          [FILE] Session_13397023737694782
          [FILE] Session_13397100351853728
          [FILE] Session_13397103806733662
          [FILE] Session_13397104316934044
          [FILE] Session_13397105814765258
          [FILE] Session_13397107284612580
          [FILE] Session_13397107557021219
          [FILE] Session_13397107831083260
          [FILE] Session_13397112121090346
          [FILE] Tabs_13396901592116952
          [FILE] Tabs_13396903793944366
          [FILE] Tabs_13396905236307898
          [FILE] Tabs_13396905342965135
          [FILE] Tabs_13396906225320660
          [FILE] Tabs_13396906492727898
          [FILE] Tabs_13396906683054217
          [FILE] Tabs_13396907217318205
          [FILE] Tabs_13396909992306565
          [FILE] Tabs_13396910158991104
          [FILE] Tabs_13396910458381292
          [FILE] Tabs_13396911236486100
          [FILE] Tabs_13396911673081544
          [FILE] Tabs_13396912349395825
          [FILE] Tabs_13396914423670280
          [FILE] Tabs_13396917062969249
          [FILE] Tabs_13396918108358518
          [FILE] Tabs_13396929934750667
          [FILE] Tabs_13396930605494046
          [FILE] Tabs_13396931332849398
          [FILE] Tabs_13396934443414230
          [FILE] Tabs_13396934939421523
          [FILE] Tabs_13396935947554046
          [FILE] Tabs_13396938407074726
          [FILE] Tabs_13396943714366378
          [FILE] Tabs_13396944050038925
          [FILE] Tabs_13396945525593145
          [FILE] Tabs_13397013371457803
          [FILE] Tabs_13397016036349558
          [FILE] Tabs_13397016783003238
          [FILE] Tabs_13397017685610873
          [FILE] Tabs_13397020562662574
          [FILE] Tabs_13397023737802813
          [FILE] Tabs_13397100351974607
          [FILE] Tabs_13397103806848582
          [FILE] Tabs_13397104317051300
          [FILE] Tabs_13397105814886448
          [FILE] Tabs_13397107284735899
          [FILE] Tabs_13397107557107157
          [FILE] Tabs_13397107831190096
          [FILE] Tabs_13397112121207652
        [DIR] Shared Dictionary
          [DIR] cache
            [FILE] index
            [DIR] index-dir
              [FILE] the-real-index
          [FILE] db
          [FILE] db-journal
        [FILE] SharedStorage
        [FILE] SharedStorage-wal
        [DIR] shared_proto_db
          [FILE] CURRENT
          [FILE] LOCK
          [FILE] LOG
          [FILE] MANIFEST-000001
          [DIR] metadata
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
        [FILE] Shortcuts
        [FILE] Shortcuts-journal
        [DIR] Site Characteristics Database
          [FILE] CURRENT
          [FILE] LOCK
          [FILE] LOG
          [FILE] MANIFEST-000001
        [DIR] Sync Data
          [DIR] LevelDB
            [FILE] CURRENT
            [FILE] LOCK
            [FILE] LOG
            [FILE] MANIFEST-000001
        [FILE] Top Sites
        [FILE] Top Sites-journal
        [FILE] Web Data
        [FILE] Web Data-journal
        [DIR] WebStorage
          [FILE] QuotaManager
          [FILE] QuotaManager-journal
    [DIR] dartpad
      [FILE] web_plugin_registrant.dart
    [DIR] extension_discovery
      [FILE] devtools.json
      [FILE] vs_code.json
    [DIR] flutter_build
    [FILE] package_config.json
    [FILE] package_config_subset
    [FILE] package_graph.json
    [FILE] version
  [FILE] .flattenignore
  [FILE] .flutter-plugins-dependencies
  [DIR] .git
  [FILE] .gitignore
  [DIR] .idea
  [FILE] .metadata
  [DIR] .vscode
  [FILE] alteracao_corrente
  [FILE] analysis_options.yaml
  [DIR] android
    [FILE] .gitignore
    [DIR] app
      [FILE] build.gradle.kts
      [FILE] google-services.json
      [DIR] src
        [DIR] debug
          [FILE] AndroidManifest.xml
        [DIR] main
          [FILE] AndroidManifest.xml
          [DIR] java
            [DIR] io
              [DIR] flutter
                [DIR] plugins
                  [FILE] GeneratedPluginRegistrant.java
          [DIR] kotlin
            [DIR] com
              [DIR] example
                [DIR] contask
                  [FILE] MainActivity.kt
          [DIR] res
            [DIR] drawable
              [FILE] launch_background.xml
            [DIR] drawable-v21
              [FILE] launch_background.xml
            [DIR] mipmap-hdpi
            [DIR] mipmap-mdpi
            [DIR] mipmap-xhdpi
            [DIR] mipmap-xxhdpi
            [DIR] mipmap-xxxhdpi
            [DIR] values
              [FILE] styles.xml
            [DIR] values-night
              [FILE] styles.xml
        [DIR] profile
          [FILE] AndroidManifest.xml
    [FILE] build.gradle.kts
    [DIR] gradle
      [DIR] wrapper
    [FILE] gradlew
    [FILE] settings.gradle.kts
  [DIR] build
  [FILE] CHECKLIST_DESENVOLVIMENTO.md
  [DIR] CodeFlattened_Output
  [FILE] devtools_options.yaml
  [DIR] docs
    [FILE] volunteer_management_optimization_analysis.md
  [FILE] firebase.json
  [DIR] ios
    [FILE] .gitignore
    [DIR] Flutter
      [DIR] ephemeral
        [FILE] flutter_lldbinit
        [FILE] flutter_lldb_helper.py
      [FILE] flutter_export_environment.sh
    [DIR] Runner
      [FILE] AppDelegate.swift
      [DIR] Assets.xcassets
        [DIR] AppIcon.appiconset
          [FILE] Contents.json
        [DIR] LaunchImage.imageset
          [FILE] Contents.json
          [FILE] README.md
      [DIR] Base.lproj
      [FILE] GeneratedPluginRegistrant.h
      [FILE] Runner-Bridging-Header.h
    [DIR] Runner.xcodeproj
      [DIR] project.xcworkspace
        [DIR] xcshareddata
      [DIR] xcshareddata
        [DIR] xcschemes
    [DIR] Runner.xcworkspace
      [DIR] xcshareddata
    [DIR] RunnerTests
      [FILE] RunnerTests.swift
  [DIR] lib
    [DIR] core
      [DIR] constants
        [FILE] app_colors.dart
        [FILE] app_constants.dart
        [FILE] app_dimensions.dart
        [FILE] app_strings.dart
      [DIR] exceptions
        [FILE] app_exceptions.dart
      [DIR] theme
        [FILE] app_theme.dart
      [DIR] utils
        [FILE] date_helpers.dart
        [FILE] error_handler.dart
        [FILE] form_validators.dart
        [FILE] string_helpers.dart
        [FILE] validators.dart
    [DIR] data
      [DIR] models
        [FILE] event_model.dart
        [FILE] microtask_model.dart
        [FILE] task_model.dart
        [FILE] user_microtask_model.dart
        [FILE] user_model.dart
        [FILE] volunteer_profile_model.dart
      [DIR] repositories
        [FILE] auth_repository.dart
        [FILE] event_repository.dart
        [FILE] microtask_repository.dart
        [FILE] task_repository.dart
        [FILE] user_repository.dart
      [DIR] services
        [FILE] assignment_service.dart
        [FILE] auth_service.dart
        [FILE] event_service.dart
        [FILE] microtask_service.dart
        [FILE] task_service.dart
        [FILE] user_service.dart
    [FILE] firebase_options.dart
    [FILE] main.dart
    [DIR] presentation
      [DIR] controllers
        [FILE] auth_controller.dart
        [FILE] event_controller.dart
        [FILE] task_controller.dart
      [DIR] routes
        [FILE] app_routes.dart
      [DIR] screens
        [DIR] assignment
          [FILE] assignment_screen.dart
        [DIR] event
          [FILE] create_event_screen.dart
          [FILE] create_tasks_screen.dart
          [FILE] event_details_screen.dart
          [FILE] join_event_screen.dart
          [FILE] manage_volunteers_screen.dart
          [FILE] track_tasks_screen.dart
        [DIR] home
          [FILE] home_screen.dart
        [DIR] profile
        [DIR] task
          [FILE] create_microtask_screen.dart
          [FILE] create_task_screen.dart
      [DIR] widgets
        [DIR] common
          [FILE] confirmation_dialog.dart
          [FILE] custom_app_bar.dart
          [FILE] custom_button.dart
          [FILE] custom_text_field.dart
          [FILE] error_message_widget.dart
          [FILE] error_widget.dart
          [FILE] loading_widget.dart
          [FILE] skill_chip.dart
        [DIR] dialogs
          [FILE] assignment_dialog.dart
          [FILE] confirmation_dialog.dart
        [DIR] event
          [FILE] event_card.dart
          [FILE] event_info_card.dart
          [FILE] event_stats_widget.dart
          [FILE] skill_chip.dart
        [DIR] task
          [FILE] microtask_card.dart
          [FILE] task_card.dart
          [FILE] task_progress_widget.dart
        [DIR] volunteer
          [FILE] volunteer_card.dart
          [FILE] volunteer_list_widget.dart
    [DIR] utils
      [FILE] migration_utils.dart
  [DIR] linux
    [FILE] .gitignore
    [DIR] flutter
      [FILE] generated_plugin_registrant.cc
      [FILE] generated_plugin_registrant.h
    [DIR] runner
      [FILE] main.cc
      [FILE] my_application.cc
      [FILE] my_application.h
  [DIR] macos
    [FILE] .gitignore
    [DIR] Flutter
      [DIR] ephemeral
        [FILE] flutter_export_environment.sh
      [FILE] GeneratedPluginRegistrant.swift
    [DIR] Runner
      [FILE] AppDelegate.swift
      [DIR] Assets.xcassets
        [DIR] AppIcon.appiconset
          [FILE] Contents.json
      [DIR] Base.lproj
      [DIR] Configs
      [FILE] MainFlutterWindow.swift
    [DIR] Runner.xcodeproj
      [DIR] project.xcworkspace
        [DIR] xcshareddata
      [DIR] xcshareddata
        [DIR] xcschemes
    [DIR] Runner.xcworkspace
      [DIR] xcshareddata
    [DIR] RunnerTests
      [FILE] RunnerTests.swift
  [FILE] pubspec.yaml
  [FILE] README.md
  [FILE] SPEC_GERAL.md
  [FILE] SPEC_MY_ATUAL_BASE.md
  [DIR] test
  [FILE] TESTE_FASE2.md
  [FILE] TESTE_FASE3.md
  [FILE] TESTE_FASE3_AJUSTES.md
  [DIR] web
    [DIR] icons
    [FILE] index.html
    [FILE] manifest.json
  [DIR] windows
    [FILE] .gitignore
    [DIR] flutter
      [DIR] ephemeral
        [DIR] .plugin_symlinks
      [FILE] generated_plugin_registrant.cc
      [FILE] generated_plugin_registrant.h
    [DIR] runner
      [FILE] flutter_window.cpp
      [FILE] flutter_window.h
      [FILE] main.cpp
      [FILE] resource.h
      [DIR] resources
      [FILE] utils.cpp
      [FILE] utils.h
      [FILE] win32_window.cpp
      [FILE] win32_window.h

# Files Content

## SPEC_MY_ATUAL_BASE.md <a id="SPEC_MY_ATUAL_BASE_md"></a> üîÑ **[RECENTLY MODIFIED]**



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    PRESENTATION LAYER                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Controllers (AuthController, EventController, TaskController)‚îÇ
‚îÇ  ‚Üì (depend on repositories only)                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      DATA LAYER                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Repositories (coordinate between services)                ‚îÇ
‚îÇ  ‚Üì (delegate to services)                                  ‚îÇ
‚îÇ  Services (direct database/Firebase operations)            ‚îÇ
‚îÇ  ‚Üì (use models for data structure)                         ‚îÇ
‚îÇ  Models (pure data classes with validation & business logic)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   EXTERNAL LAYER                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Firebase Firestore, Firebase Auth, External APIs          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

## .flattenignore <a id="flattenignore"></a> üîÑ **[RECENTLY MODIFIED]**

**/.augment
**/blob_storage
## devtools_options.yaml <a id="devtools_options_yaml"></a> üîÑ **[RECENTLY MODIFIED]**

description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:

## ios\.gitignore <a id="gitignore"></a>

**/dgph
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
**/*sync/
.sconsign.dblite
.tags*
**/.vagrant/
**/DerivedData/
Icon?
**/Pods/
**/.symlinks/
profile
xcuserdata
**/.generated/
Flutter/App.framework
Flutter/Flutter.framework
Flutter/Flutter.podspec
Flutter/Generated.xcconfig
Flutter/ephemeral/
Flutter/app.flx
Flutter/app.zip
Flutter/flutter_assets/
Flutter/flutter_export_environment.sh
ServiceDefinitions.json
Runner/GeneratedPluginRegistrant.*

# Exceptions to above rules.
!default.mode1v3
!default.mode2v3
!default.pbxuser
!default.perspectivev3

## macos\.gitignore <a id="gitignore"></a>

# Flutter-related
**/Flutter/ephemeral/
**/Pods/

# Xcode-related
**/dgph
**/xcuserdata/

## windows\.gitignore <a id="gitignore"></a>

flutter/ephemeral/

# Visual Studio user-specific files.
*.suo
*.user
*.userosscache
*.sln.docstates

# Visual Studio build-related files.
x64/
x86/

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/

## android\.gitignore <a id="gitignore"></a>

gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java
.cxx/

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks

## linux\.gitignore <a id="gitignore"></a>

flutter/ephemeral

## .gitignore <a id="gitignore"></a>

# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.build/
.buildlog/
.history
.svn/
.swiftpm/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release

## ios\Runner\Assets.xcassets\LaunchImage.imageset\README.md <a id="README_md"></a>

# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.
## macos\Runner\AppDelegate.swift <a id="AppDelegate_swift"></a>

### Dependencies

- `Cocoa`
- `FlutterMacOS`

import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }

  override func applicationSupportsSecureRestorableState(_ app: NSApplication) -> Bool {
    return true
  }
}

## windows\runner\main.cpp <a id="main_cpp"></a>

### Dependencies

- `flutter/dart_project.h`
- `flutter/flutter_view_controller.h`
- `windows.h`
- `flutter_window.h`
- `utils.h`

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"contask", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}

## README.md <a id="README_md"></a>

# contask

A new Flutter project.

## Getting Started

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://docs.flutter.dev/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://docs.flutter.dev/cookbook)

For help getting started with Flutter development, view the
[online documentation](https://docs.flutter.dev/), which offers tutorials,
samples, guidance on mobile development, and a full API reference.

## ios\Runner\AppDelegate.swift <a id="AppDelegate_swift"></a>

### Dependencies

- `Flutter`
- `UIKit`

import Flutter
import UIKit

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}

## windows\runner\flutter_window.cpp <a id="flutter_window_cpp"></a>

### Dependencies

- `flutter_window.h`
- `optional`
- `flutter/generated_plugin_registrant.h`

#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}

## ios\Runner\GeneratedPluginRegistrant.h <a id="GeneratedPluginRegistrant_h"></a>

//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GeneratedPluginRegistrant_h
#define GeneratedPluginRegistrant_h

#import <Flutter/Flutter.h>

NS_ASSUME_NONNULL_BEGIN

@interface GeneratedPluginRegistrant : NSObject
+ (void)registerWithRegistry:(NSObject<FlutterPluginRegistry>*)registry;
@end

NS_ASSUME_NONNULL_END
#endif /* GeneratedPluginRegistrant_h */

## ios\Flutter\ephemeral\flutter_lldb_helper.py <a id="flutter_lldb_helper_py"></a>

### Dependencies

- `lldb`

#
# Generated file, do not edit.
#

import lldb

def handle_new_rx_page(frame: lldb.SBFrame, bp_loc, extra_args, intern_dict):
    """Intercept NOTIFY_DEBUGGER_ABOUT_RX_PAGES and touch the pages."""
    base = frame.register["x0"].GetValueAsAddress()
    page_len = frame.register["x1"].GetValueAsUnsigned()

    # Note: NOTIFY_DEBUGGER_ABOUT_RX_PAGES will check contents of the
    # first page to see if handled it correctly. This makes diagnosing
    # misconfiguration (e.g. missing breakpoint) easier.
    data = bytearray(page_len)
    data[0:8] = b'IHELPED!'

    error = lldb.SBError()
    frame.GetThread().GetProcess().WriteMemory(base, data, error)
    if not error.Success():
        print(f'Failed to write into {base}[+{page_len}]', error)
        return

def __lldb_init_module(debugger: lldb.SBDebugger, _):
    target = debugger.GetDummyTarget()
    # Caveat: must use BreakpointCreateByRegEx here and not
    # BreakpointCreateByName. For some reasons callback function does not
    # get carried over from dummy target for the later.
    bp = target.BreakpointCreateByRegex("^NOTIFY_DEBUGGER_ABOUT_RX_PAGES$")
    bp.SetScriptCallbackFunction('{}.handle_new_rx_page'.format(__name__))
    bp.SetAutoContinue(True)
    print("-- LLDB integration loaded --")

## linux\flutter\generated_plugin_registrant.h <a id="generated_plugin_registrant_h"></a>

### Dependencies

- `flutter_linux/flutter_linux.h`

//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter_linux/flutter_linux.h>

// Registers Flutter plugins.
void fl_register_plugins(FlPluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_

## windows\runner\flutter_window.h <a id="flutter_window_h"></a>

### Dependencies

- `flutter/dart_project.h`
- `flutter/flutter_view_controller.h`
- `memory`
- `win32_window.h`

#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_

## windows\flutter\generated_plugin_registrant.h <a id="generated_plugin_registrant_h"></a>

### Dependencies

- `flutter/plugin_registry.h`

//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_

## macos\Flutter\GeneratedPluginRegistrant.swift <a id="GeneratedPluginRegistrant_swift"></a>

### Dependencies

- `FlutterMacOS`
- `Foundation`
- `cloud_firestore`
- `firebase_auth`
- `firebase_core`
- `google_sign_in_ios`
- `path_provider_foundation`
- `sqflite_darwin`

//
//  Generated file. Do not edit.
//

import FlutterMacOS
import Foundation

import cloud_firestore
import firebase_auth
import firebase_core
import google_sign_in_ios
import path_provider_foundation
import sqflite_darwin

func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) {
  FLTFirebaseFirestorePlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseFirestorePlugin"))
  FLTFirebaseAuthPlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseAuthPlugin"))
  FLTFirebaseCorePlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseCorePlugin"))
  FLTGoogleSignInPlugin.register(with: registry.registrar(forPlugin: "FLTGoogleSignInPlugin"))
  PathProviderPlugin.register(with: registry.registrar(forPlugin: "PathProviderPlugin"))
  SqflitePlugin.register(with: registry.registrar(forPlugin: "SqflitePlugin"))
}

## android\app\src\main\java\io\flutter\plugins\GeneratedPluginRegistrant.java <a id="GeneratedPluginRegistrant_java"></a>

### Dependencies

- `androidx.annotation.Keep`
- `androidx.annotation.NonNull`
- `io.flutter.Log`
- `io.flutter.embedding.engine.FlutterEngine`

package io.flutter.plugins;

import androidx.annotation.Keep;
import androidx.annotation.NonNull;
import io.flutter.Log;

import io.flutter.embedding.engine.FlutterEngine;

/**
 * Generated file. Do not edit.
 * This file is generated by the Flutter tool based on the
 * plugins that support the Android platform.
 * /
@Keep
public final class GeneratedPluginRegistrant {
  private static final String TAG = "GeneratedPluginRegistrant";
  public static void registerWith(@NonNull FlutterEngine flutterEngine) {
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin cloud_firestore, io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.auth.FlutterFirebaseAuthPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_auth, io.flutter.plugins.firebase.auth.FlutterFirebaseAuthPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_core, io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.googlesignin.GoogleSignInPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin google_sign_in_android, io.flutter.plugins.googlesignin.GoogleSignInPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.pathprovider.PathProviderPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin path_provider_android, io.flutter.plugins.pathprovider.PathProviderPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.tekartik.sqflite.SqflitePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin sqflite_android, com.tekartik.sqflite.SqflitePlugin", e);
    }
  }
}

## macos\Runner\MainFlutterWindow.swift <a id="MainFlutterWindow_swift"></a>

### Dependencies

- `Cocoa`
- `FlutterMacOS`

import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}

## android\app\src\main\kotlin\com\example\contask\MainActivity.kt <a id="MainActivity_kt"></a>

### Dependencies

- `io.flutter.embedding.android.FlutterActivity`

package com.example.contask

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()

## linux\runner\my_application.h <a id="my_application_h"></a>

### Dependencies

- `gtk/gtk.h`

#ifndef FLUTTER_MY_APPLICATION_H_
#define FLUTTER_MY_APPLICATION_H_

#include <gtk/gtk.h>

G_DECLARE_FINAL_TYPE(MyApplication, my_application, MY, APPLICATION,
                     GtkApplication)

/**
 * my_application_new:
 * 
 * Creates a new Flutter-based application.
 * 
 * Returns: a new #MyApplication.
 * /
MyApplication* my_application_new();

#endif  // FLUTTER_MY_APPLICATION_H_

## windows\runner\utils.cpp <a id="utils_cpp"></a>

### Dependencies

- `utils.h`
- `flutter_windows.h`
- `io.h`
- `stdio.h`
- `windows.h`
- `iostream`

#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}

## windows\runner\resource.h <a id="resource_h"></a>

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

## ios\Runner\Runner-Bridging-Header.h <a id="Runner-Bridging-Header_h"></a>

#import "GeneratedPluginRegistrant.h"

## macos\RunnerTests\RunnerTests.swift <a id="RunnerTests_swift"></a>

### Dependencies

- `Cocoa`
- `FlutterMacOS`
- `XCTest`

import Cocoa
import FlutterMacOS
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}

## windows\runner\utils.h <a id="utils_h"></a>

### Dependencies

- `string`
- `vector`

#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_

## ios\RunnerTests\RunnerTests.swift <a id="RunnerTests_swift"></a>

### Dependencies

- `Flutter`
- `UIKit`
- `XCTest`

import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}

## windows\runner\win32_window.cpp <a id="win32_window_cpp"></a>

### Dependencies

- `win32_window.h`
- `dwmapi.h`
- `flutter_windows.h`
- `resource.h`

#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}

## windows\runner\win32_window.h <a id="win32_window_h"></a>

### Dependencies

- `windows.h`
- `functional`
- `memory`
- `string`

#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_

## CHECKLIST_DESENVOLVIMENTO.md <a id="CHECKLIST_DESENVOLVIMENTO_md"></a>

# üìã Checklist de Desenvolvimento - Task Manager para Eventos

## üéØ Status Geral do Projeto
- **Plataforma:** Flutter
- **Firebase:** ‚úÖ **CONFIGURADO**
- **Progresso Geral:** 5% (1/20 fases principais)

---

## üì¶ Configura√ß√£o Inicial

### ‚úÖ Configura√ß√£o do Ambiente
- [x] **Firebase configurado** (Auth, Firestore, Storage)
- [x] **Depend√™ncias principais instaladas** (Firebase, Provider, utils)
- [x] **Estrutura de pastas criada** (core/, data/, presentation/)
- [x] **Configura√ß√£o do tema base** (cores, dimens√µes, tema Material Design)

### üìÅ Estrutura de Pastas

- [x] **`/lib/core/` - Constantes, utils, tema, exce√ß√µes**
- [x] **`/lib/data/` - Separa√ß√£o por dom√≠nio:**
    - **`models/`** (user, event, task, volunteer)
    - **`repositories/`** (user, event, task, volunteer)
    - **`services/`** (auth, event, task, volunteer, firebase, storage)
- [x] **`/lib/presentation/` - Controllers, screens, widgets, routes**

### ‚úÖ Boas pr√°ticas para models, repositories e services

- [x] Cada model, reposit√≥rio e service em seu pr√≥prio arquivo
- [x] Organiza√ß√£o por dom√≠nio: facilita encontrar e modificar funcionalidades espec√≠ficas
- [x] Evite depend√™ncias cruzadas entre dom√≠nios
- [x] Services s√≥ interagem com dados externos (Firebase, APIs)
- [x] Repositories fazem a ponte entre services e o restante do app
- [x] Models n√£o devem conter l√≥gica de neg√≥cio, apenas estrutura e serializa√ß√£o

---

## üé® Design System & Tema

### Cores e Estilo
- [x] **Definir cores no `app_colors.dart`**
  - [x] **Cor Principal: Roxo (#6B46C1)**
  - [x] **Cor Secund√°ria: Roxo claro (#A78BFA)**
  - [x] **Cores de fundo, texto, sucesso, erro**
- [x] **Configurar tema Material Design**
- [x] **Criar componentes base (bot√µes, campos, etc.)**

---

## üîê FASE 1: Autentica√ß√£o e Estrutura Base

### Modelos de Dados
- [x] **`user_model.dart` - Modelo do usu√°rio**
- [x] **Valida√ß√µes e serializa√ß√£o JSON**

### Servi√ßos de Autentica√ß√£o
- [x] **`auth_service.dart` - Integra√ß√£o Firebase Auth**
- [x] **`auth_repository.dart` - Camada de dados**
- [x] **`auth_controller.dart` - Gerenciamento de estado**

### Telas de Autentica√ß√£o
- [x] **Tela de Login**
  - [x] **Layout com logo centralizado**
  - [x] **Bot√£o "Entrar com Google"**
  - [x] **Link "Criar conta"**
- [x] **Tela de Cadastro**
  - [x] **Campos: nome, email, senha, confirmar senha**
  - [x] **Valida√ß√µes (email v√°lido, senha 6+ chars)**
  - [x] **Bot√£o "Criar conta"**

### Navega√ß√£o Base
- [x] **Configurar rotas (`app_routes.dart`)**
- [x] **Implementar navega√ß√£o entre telas**
- [x] **Prote√ß√£o de rotas (usu√°rio logado)**

---

## ‚úÖ FASE 2: Tela Home e Gerenciamento de Eventos

### Tela Home
- [x] **Layout Principal**
  - [x] AppBar com nome e foto do usu√°rio
  - [x] Lista de cards dos eventos
  - [x] FAB com op√ß√µes "Criar Evento" e "Participar"
- [x] **Event Card**
  - [x] Nome do evento
  - [x] Papel do usu√°rio (Gerenciador/Volunt√°rio)
  - [x] N√∫mero de tarefas pendentes
  - [x] Status do evento

### Modelos de Eventos
- [x] `event_model.dart` - Modelo completo do evento
- [x] `volunteer_profile_model.dart` - Perfil do volunt√°rio

### Servi√ßos de Eventos
- [x] `event_service.dart` - CRUD de eventos
- [x] `event_repository.dart` - Camada de dados
- [x] `event_controller.dart` - Gerenciamento de estado

### Cria√ß√£o de Eventos
- [x] **Tela Criar Evento**
  - [x] Formul√°rio completo (nome, descri√ß√£o, localiza√ß√£o)
  - [x] Sele√ß√£o de habilidades necess√°rias (chips + adicionar nova)
  - [x] Sele√ß√£o de recursos necess√°rios (chips + adicionar novo)
  - [x] Gera√ß√£o autom√°tica de c√≥digo/tag √∫nico
- [x] Sistema de c√≥digos √∫nicos (valida√ß√£o)
- [x] Valida√ß√µes de formul√°rio

### Participa√ß√£o em Eventos
- [x] **Tela Participar de Evento**
  - [x] Campo para inserir c√≥digo/tag
  - [x] Busca e exibi√ß√£o do evento
  - [x] Formul√°rio de perfil do volunt√°rio
  - [x] Sele√ß√£o de disponibilidade (dias/hor√°rios)
  - [x] Sele√ß√£o de habilidades e recursos

### Melhorias de UX Implementadas
- [x] **Alinhamento de bot√µes**: Bot√µes "Buscar" e "Adicionar" alinhados √† esquerda
- [x] **Verifica√ß√£o de participa√ß√£o**: Sistema impede participa√ß√£o dupla
- [x] **Filtros inteligentes**: Habilidades/recursos do evento como op√ß√µes priorit√°rias
- [x] **Feedback visual**: Indicadores claros de status de participa√ß√£o

---

## üìã FASE 3: Sistema de Tarefas

### Modelos de Tarefas
- [x] `task_model.dart` - Modelo da task (organizadora)
- [x] `microtask_model.dart` - Modelo da microtask com **m√∫ltiplos volunt√°rios**
  - [x] Campo `assignedTo` como array de user_ids
  - [x] Campo `maxVolunteers` para limite de volunt√°rios
- [x] `user_microtask_model.dart` - Rela√ß√£o usu√°rio-microtask

### Servi√ßos de Tarefas
- [x] `task_service.dart` - CRUD de tasks no Firebase
- [x] `microtask_service.dart` - CRUD de microtasks no Firebase
- [x] `assignment_service.dart` - Sistema de atribui√ß√£o m√∫ltipla
- [x] `task_repository.dart` - CRUD de tasks
- [x] `microtask_repository.dart` - CRUD de microtasks
- [x] `task_controller.dart` - Gerenciamento de estado

### Tela Detalhes do Evento
- [x] **Sistema de Tabs**
  - [x] Tab "Evento" - Informa√ß√µes gerais + c√≥digo/tag
  - [x] Tab "Criar Tasks" (apenas gerenciadores)
  - [x] Tab "Gerenciar Volunt√°rios" (apenas gerenciadores) - placeholder
  - [x] Tab "Acompanhar Tasks" - implementa√ß√£o b√°sica

### Cria√ß√£o de Tasks
- [x] **Tela Criar Tasks**
  - [x] Se√ß√£o criar Task (nome, descri√ß√£o, prioridade)
  - [x] Se√ß√£o criar Microtask
  - [x] Sele√ß√£o de task pai
  - [x] Campos espec√≠ficos da microtask
  - [x] **Campo "N√∫mero m√°ximo de volunt√°rios"**
  - [x] Valida√ß√µes e persist√™ncia

### Gerenciamento de Volunt√°rios
- [ ] **Tela Gerenciar Volunt√°rios**
  - [ ] Lista de volunt√°rios com cards
  - [ ] Indicadores de disponibilidade
  - [ ] Sistema de atribui√ß√£o de microtasks
  - [ ] **Visualiza√ß√£o dos volunt√°rios j√° atribu√≠dos √† microtask**
  - [ ] **Op√ß√£o de adicionar mais volunt√°rios at√© o limite**
  - [ ] **Op√ß√£o de remover volunt√°rios da microtask**
  - [ ] Filtro por compatibilidade
  - [ ] Promo√ß√£o a gerenciador

### Acompanhamento de Tasks
- [ ] **Tela Acompanhar Tasks**
  - [ ] Visualiza√ß√£o hier√°rquica (Tasks ‚Üí Microtasks)
  - [ ] **Lista de volunt√°rios designados por microtask**
  - [ ] Status visual e progresso
  - [ ] Filtros (status, prioridade, respons√°vel)
  - [ ] **A√ß√µes para cada volunt√°rio atribu√≠do** (Iniciar/Concluir/Cancelar)
  - [ ] **√Årea de colabora√ß√£o/notas entre volunt√°rios**

---

## üß© Componentes e Widgets

### Widgets Comuns
- [x] **`custom_button.dart` - Bot√£o personalizado**
- [x] **`custom_text_field.dart` - Campo de texto**
- [ ] `custom_app_bar.dart` - AppBar personalizada
- [ ] `loading_widget.dart` - Indicador de carregamento
- [ ] `error_widget.dart` - Widget de erro
- [ ] `confirmation_dialog.dart` - Dialog de confirma√ß√£o

### Widgets Espec√≠ficos
- [ ] `event_card.dart` - Card do evento
- [ ] `task_card.dart` - Card da task
- [ ] `volunteer_card.dart` - Card do volunt√°rio
- [ ] `skill_chip.dart` - Chip de habilidade
- [ ] `volunteer_list_widget.dart` - Lista de volunt√°rios por microtask

---

## üîß Funcionalidades Avan√ßadas

### Sistema de Atribui√ß√£o Inteligente
- [ ] Algoritmo de compatibilidade de habilidades
- [ ] Verifica√ß√£o de disponibilidade de hor√°rios
- [ ] Sugest√£o autom√°tica de volunt√°rios para microtasks
- [ ] **Controle de capacidade m√°xima por microtask**
- [ ] **Preven√ß√£o de atribui√ß√£o dupla do mesmo volunt√°rio**
- [ ] Valida√ß√µes de atribui√ß√£o m√∫ltipla

### Gerenciamento de Status
- [ ] Sistema de status para eventos
- [ ] Sistema de status para tasks (baseado nas microtasks)
- [ ] Sistema de status para microtasks
- [ ] **C√°lculo autom√°tico de progresso** (Tasks herdam das microtasks)
- [ ] **Conclus√£o colaborativa** (todos volunt√°rios devem marcar como conclu√≠da)

---

## üß™ Testes e Valida√ß√£o

### Testes Funcionais
- [ ] Teste de autentica√ß√£o
- [ ] Teste de cria√ß√£o de eventos
- [ ] **Teste de atribui√ß√£o m√∫ltipla de volunt√°rios**
- [ ] **Teste de controle de capacidade m√°xima**
- [ ] **Teste de conclus√£o colaborativa**
- [ ] Teste de fluxo completo

### Valida√ß√µes de Neg√≥cio
- [ ] C√≥digos de evento √∫nicos
- [ ] Verifica√ß√£o de permiss√µes por role
- [ ] **Valida√ß√£o de compatibilidade antes da atribui√ß√£o**
- [ ] **Controle de status das microtasks**
- [ ] **Verifica√ß√£o de disponibilidade antes da atribui√ß√£o**
- [ ] **Preven√ß√£o de atribui√ß√£o m√∫ltipla do mesmo volunt√°rio**
- [ ] **Valida√ß√£o de conclus√£o colaborativa**

---

## üì± Polimento e Finaliza√ß√£o

### UX/UI
- [ ] Revis√£o de design em todas as telas
- [ ] Anima√ß√µes e transi√ß√µes
- [ ] Feedback visual para a√ß√µes
- [ ] Tratamento de estados de erro
- [ ] **Interface para visualiza√ß√£o de m√∫ltiplos volunt√°rios**

### Performance
- [ ] Otimiza√ß√£o de consultas Firestore
- [ ] Cache de dados
- [ ] Lazy loading de listas
- [ ] Otimiza√ß√£o de imagens
- [ ] **Otimiza√ß√£o de queries para m√∫ltiplos volunt√°rios**

---

## üìä M√©tricas de Progresso

- **Configura√ß√£o:** ‚úÖ 4/4 (100%)
- **Fase 1 - Autentica√ß√£o:** ‚úÖ 12/12 (100%)
- **Fase 2 - Eventos:** ‚úÖ 19/19 (100%) **(CONCLU√çDA)**
- **Fase 3 - Tarefas:** üöß 14/21 (66.7%) **(EM DESENVOLVIMENTO)**
- **Componentes:** ‚è≥ 2/11 (18%) **(+1 componente)**
- **Funcionalidades Avan√ßadas:** ‚è≥ 0/11 (0%) **(+3 itens para m√∫ltiplos volunt√°rios)**
- **Testes:** ‚è≥ 0/11 (0%) **(+3 testes espec√≠ficos)**
- **Polimento:** ‚è≥ 0/10 (0%) **(+2 itens para m√∫ltiplos volunt√°rios)**

**PROGRESSO TOTAL: 51/99 tarefas (51.5%)**

---

## üéØ Regras de Neg√≥cio Espec√≠ficas

### M√∫ltiplos Volunt√°rios por Microtask
- **Volunt√°rios s√£o atribu√≠dos APENAS √†s microtasks** (n√£o √†s Tasks)
- **Cada microtask pode ter m√∫ltiplos volunt√°rios** (definido por maxVolunteers)
- **Tasks servem apenas como agrupadores organizacionais**
- **Controle de capacidade m√°xima por microtask**
- **Preven√ß√£o de atribui√ß√£o dupla do mesmo volunt√°rio √† mesma microtask**
- **Microtask √© considerada conclu√≠da quando todos os volunt√°rios atribu√≠dos marcam como conclu√≠da**

### Hierarquia e Status
- **Tasks herdam status das microtasks**
- **Progresso da Task calculado automaticamente baseado nas microtasks conclu√≠das**
- **Sistema de conclus√£o colaborativa obrigat√≥rio**

---

*√öltima atualiza√ß√£o: 13/07/2025*
*Firebase configurado ‚úÖ*
*Depend√™ncias instaladas ‚úÖ*
*Estrutura de pastas criada ‚úÖ*
*Design System configurado ‚úÖ*
*Erros corrigidos e c√≥digo validado ‚úÖ*
*FASE 1 - Autentica√ß√£o CONCLU√çDA ‚úÖ*
*FASE 2 - Gerenciamento de Eventos CONCLU√çDA ‚úÖ*
*CHECKLIST ATUALIZADO para m√∫ltiplos volunt√°rios ‚úÖ*
*TESTE_FASE3.md criado - Iniciando Fase 3 ‚úÖ*
*FASE 3 - Modelos, Servi√ßos, Reposit√≥rios e Controllers CONCLU√çDOS ‚úÖ*
*FASE 3 - Telas b√°sicas implementadas (EventDetailsScreen, CreateTasksScreen) ‚úÖ*
## .augment\rules\rule1.md <a id="rule1_md"></a>

---
type: "always_apply"
description: "Atualizar a documenta√ß√£o Geral do app"
---
Sempre ao final da tarefa atualize a regra na documenta√ß√£o geral do projeto com o ajuste SPEC_GERAL.md
## SPEC_GERAL.md <a id="SPEC_GERAL_md"></a>

# Especifica√ß√£o do Projeto - Task Manager para Eventos

## üìã Vis√£o Geral do Projeto

**Plataforma:** Flutter
**Objetivo:** Aplicativo para gerenciamento de tarefas em eventos com sistema de voluntariado
**Banco de Dados:** Firebase Firestore
**Autentica√ß√£o:** Firebase Auth (Google Sign-In)

## üéØ Conceito Principal

Sistema onde usu√°rios podem criar eventos, gerenciar tarefas hier√°rquicas (Tasks ‚Üí Microtasks) e coordenar volunt√°rios para execu√ß√£o das atividades atrav√©s de um sistema de tags/c√≥digos √∫nicos.

## üë• Personas e Fluxos

### Gerenciador de Evento
- Cria eventos com informa√ß√µes detalhadas
- Define habilidades e recursos necess√°rios
- Compartilha c√≥digo/tag do evento
- Cria e organiza Tasks e Microtasks
- Atribui volunt√°rios √†s microtasks
- Pode promover volunt√°rios a gerenciadores

### Volunt√°rio
- Ingressa em eventos via c√≥digo/tag
- Define disponibilidade (dias, hor√°rios)
- Especifica habilidades e recursos pr√≥prios
- Recebe e executa microtasks atribu√≠das

## üîÑ Fluxo Principal

1. **Cria√ß√£o de Evento**
   - Usu√°rio cria evento ‚Üí torna-se gerenciador
   - Sistema gera c√≥digo/tag √∫nico
   - Define: nome, descri√ß√£o, localiza√ß√£o, habilidades necess√°rias, recursos necess√°rios

2. **Ingresso de Volunt√°rios**
   - Volunt√°rio insere c√≥digo/tag
   - Preenche perfil: disponibilidade, habilidades, recursos
   - Aguarda atribui√ß√£o de microtasks

3. **Gest√£o de Tarefas**
   - Gerenciador cria Tasks (grupos de atividades)
   - Cada Task cont√©m m√∫ltiplas Microtasks
   - **Volunt√°rios s√£o atribu√≠dos APENAS √†s Microtasks** (n√£o √†s Tasks)
   - **Cada microtask pode ter m√∫ltiplos volunt√°rios trabalhando em equipe**
   - Sistema considera compatibilidade: habilidades + disponibilidade + recursos

## üì± Especifica√ß√£o de Telas

### Design System
- **Cor Principal:** Roxo (#6B46C1)
- **Cor Secund√°ria:** Roxo claro (#A78BFA)
- **Cor de Fundo:** Branco (#FFFFFF)
- **Cor de Texto:** Cinza escuro (#374151)
- **Cor de Sucesso:** Verde (#10B981)
- **Cor de Erro:** Vermelho (#EF4444)
- **Estilo:** Clean, minimalista, Material Design

### 1. Tela de Login
- **Componentes:**
  - Logo centralizado
  - Bot√£o "Entrar com Google" (√≠cone + texto)
  - Link "Criar conta" na parte inferior
- **Estilo:** Fundo branco, elementos centralizados, bot√£o roxo com bordas arredondadas

### 2. Tela de Cadastro
- **Componentes:**
  - Campos: Nome completo, E-mail, Senha, Confirmar senha
  - Bot√£o "Criar conta"
  - Link "J√° tenho conta"
- **Valida√ß√µes:** E-mail v√°lido, senha m√≠nima 6 caracteres, senhas iguais

### 3. Tela Home
- **Layout:**
  - AppBar com nome do usu√°rio e foto
  - Lista de cards dos eventos vinculados
  - FAB (Floating Action Button) com op√ß√µes:
    - "Criar Evento"
    - "Participar de Evento"
- **Event Card:**
  - Nome do evento
  - Papel do usu√°rio (Gerenciador/Volunt√°rio)
  - N√∫mero de tarefas pendentes
  - Status do evento

### 4. Tela Criar Evento
- **Formul√°rio:**
  - Nome do evento (obrigat√≥rio)
  - Descri√ß√£o (texto longo)
  - Localiza√ß√£o (campo descritivo)
  - Habilidades necess√°rias (chips selecion√°veis + adicionar nova)
  - Recursos necess√°rios (chips selecion√°veis + adicionar novo)
  - Bot√£o "Criar Evento"
- **P√≥s-cria√ß√£o:** Exibe c√≥digo/tag gerado

### 5. Tela Participar de Evento
- **Componentes:**
  - Campo para inserir c√≥digo/tag
  - Bot√£o "Buscar Evento" (alinhado √† esquerda com o campo)
  - Exibi√ß√£o dos detalhes do evento encontrado
  - **Verifica√ß√£o de Participa√ß√£o:** Se usu√°rio j√° √© participante, exibe detalhes mas impede nova participa√ß√£o
  - Formul√°rio de perfil do volunt√°rio (apenas se ainda n√£o for participante):
    - Dias dispon√≠veis (checkboxes)
    - Hor√°rio dispon√≠vel (time picker)
    - **Habilidades:** Lista priorit√°ria das habilidades necess√°rias do evento + op√ß√£o de adicionar nova
    - **Recursos:** Lista priorit√°ria dos recursos necess√°rios do evento + op√ß√£o de adicionar novo
    - Bot√£o "Adicionar" para novas habilidades/recursos (alinhado √† esquerda)
  - Bot√£o "Confirmar Participa√ß√£o" (apenas se ainda n√£o for participante)

### 6. Tela Detalhes do Evento
- **Tabs de Navega√ß√£o:**
  - **Evento:** Informa√ß√µes gerais, localiza√ß√£o, c√≥digo/tag
  - **Criar Tasks:** (apenas gerenciadores)
  - **Gerenciar Volunt√°rios:** (apenas gerenciadores)
  - **Acompanhar Tasks:** Visualiza√ß√£o de todas as tasks/microtasks

### 7. Tela Criar Tasks
- **Se√ß√£o Criar Task:**
  - Nome da task
  - Descri√ß√£o
  - Prioridade (Alta/M√©dia/Baixa)
- **Se√ß√£o Criar Microtask:**
  - Selecionar task pai
  - Nome da microtask
  - Descri√ß√£o detalhada
  - Habilidades necess√°rias
  - Recursos necess√°rios
  - Tempo estimado
  - Prioridade
  - **N√∫mero m√°ximo de volunt√°rios** (campo maxVolunteers)

### 8. Tela Gerenciar Volunt√°rios
- **Lista de Volunt√°rios:**
  - Cards com foto, nome, habilidades
  - Indicador de disponibilidade
  - Bot√£o "Atribuir Microtask"
  - Bot√£o "Promover a Gerenciador"
- **Atribui√ß√£o de Microtasks:**
  - Lista de microtasks dispon√≠veis
  - Filtro por compatibilidade com o volunt√°rio selecionado
  - Visualiza√ß√£o dos volunt√°rios j√° atribu√≠dos √† microtask
  - Confirma√ß√£o de atribui√ß√£o adicional √† microtask
  - Op√ß√£o de remover volunt√°rios da microtask

### 9. Tela Acompanhar Tasks
- **Visualiza√ß√£o Hier√°rquica:**
  - Tasks expand√≠veis (containers das microtasks)
  - Microtasks com status visual e **lista de volunt√°rios atribu√≠dos**
  - Filtros: Status, Prioridade, Respons√°vel
  - Indicadores de progresso por Task (baseado nas microtasks conclu√≠das)
- **Detalhes da Microtask:**
  - **Lista de volunt√°rios designados** (pode ser m√∫ltiplos)
  - Tempo estimado vs realizado (por volunt√°rio)
  - Status atual da microtask
  - Bot√µes de a√ß√£o (Iniciar/Concluir/Cancelar) - para cada volunt√°rio atribu√≠do
  - √Årea de colabora√ß√£o/notas entre volunt√°rios

## üóÇÔ∏è Estrutura de Pastas

```
lib/
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ constants/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app_colors.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app_strings.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app_dimensions.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app_constants.dart
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validators.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date_helpers.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ string_helpers.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ permission_helpers.dart
‚îÇ   ‚îú‚îÄ‚îÄ theme/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app_theme.dart
‚îÇ   ‚îî‚îÄ‚îÄ exceptions/
‚îÇ       ‚îî‚îÄ‚îÄ app_exceptions.dart
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user_model.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ event_model.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_model.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ microtask_model.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ volunteer/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ volunteer_profile_model.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user_microtask_model.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ... (outros models)
‚îÇ   ‚îú‚îÄ‚îÄ repositories/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user_repository.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ event_repository.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_repository.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ microtask_repository.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ volunteer/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ volunteer_repository.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ... (outros reposit√≥rios)
‚îÇ   ‚îî‚îÄ‚îÄ services/
‚îÇ       ‚îú‚îÄ‚îÄ auth/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ auth_service.dart
‚îÇ       ‚îú‚îÄ‚îÄ event/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ event_service.dart
‚îÇ       ‚îú‚îÄ‚îÄ task/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ task_service.dart
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ microtask_service.dart
‚îÇ       ‚îú‚îÄ‚îÄ volunteer/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ assignment_service.dart
‚îÇ       ‚îú‚îÄ‚îÄ firebase/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ firebase_service.dart
‚îÇ       ‚îú‚îÄ‚îÄ storage/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ storage_service.dart
‚îÇ       ‚îî‚îÄ‚îÄ ... (outros services)
‚îú‚îÄ‚îÄ presentation/
‚îÇ   ‚îú‚îÄ‚îÄ controllers/ (usando GetX ou Provider)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_controller.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event_controller.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_controller.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ volunteer_controller.dart
‚îÇ   ‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ register_screen.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ home/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ home_screen.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create_event_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ join_event_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event_details_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create_tasks_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manage_volunteers_screen.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ track_tasks_screen.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ profile/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ volunteer_profile_screen.dart
‚îÇ   ‚îú‚îÄ‚îÄ widgets/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ custom_button.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ custom_text_field.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ custom_app_bar.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ loading_widget.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ error_widget.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ confirmation_dialog.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event_card.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_card.dart
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ event_info_card.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ volunteer/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ volunteer_card.dart
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ skill_chip.dart
‚îÇ   ‚îî‚îÄ‚îÄ routes/
‚îÇ       ‚îî‚îÄ‚îÄ app_routes.dart
‚îî‚îÄ‚îÄ main.dart
```

### Boas pr√°ticas para organiza√ß√£o de models, repositories e services

- **Separa√ß√£o por dom√≠nio:** Crie subpastas para cada dom√≠nio (usu√°rio, evento, tarefa, volunt√°rio) dentro de models, repositories e services.
- **Responsabilidade √∫nica:** Cada arquivo deve ter apenas uma classe principal.
- **Nada de l√≥gica de UI:** Models, reposit√≥rios e services n√£o devem importar nada de Flutter UI.
- **Services:** Respons√°veis por interagir diretamente com Firebase, APIs externas, armazenamento, etc.
- **Repositories:** Camada de abstra√ß√£o entre os services e o restante do app. S√≥ chamam services e retornam models.
- **Models:** Representam as entidades do dom√≠nio, com m√©todos de serializa√ß√£o (`fromJson`, `toJson`). N√£o misturar l√≥gica de neg√≥cio ou acesso a dados aqui.

## üóÑÔ∏è Estrutura do Banco de Dados (Firestore)

### Collection: users
```json
{
  "id": "user_id",
  "name": "Nome do Usu√°rio",
  "email": "email@exemplo.com",
  "photoUrl": "url_da_foto",
  "createdAt": "timestamp",
  "updatedAt": "timestamp"
}
```

### Collection: events
```json
{
  "id": "event_id",
  "name": "Nome do Evento",
  "description": "Descri√ß√£o do evento",
  "tag": "ABC123",
  "location": "Endere√ßo descritivo",
  "createdBy": "user_id",
  "managers": ["user_id1", "user_id2"],
  "volunteers": ["user_id3", "user_id4"],
  "requiredSkills": ["skill1", "skill2"],
  "requiredResources": ["resource1", "resource2"],
  "status": "active|completed|cancelled",
  "createdAt": "timestamp",
  "updatedAt": "timestamp"
}
```

### Collection: tasks
```json
{
  "id": "task_id",
  "eventId": "event_id",
  "title": "T√≠tulo da Tarefa",
  "description": "Descri√ß√£o da tarefa",
  "priority": "high|medium|low",
  "status": "pending|in_progress|completed",
  "createdBy": "user_id",
  "microtaskCount": 5,
  "completedMicrotasks": 2,
  "createdAt": "timestamp",
  "updatedAt": "timestamp"
}
```

### Collection: microtasks
```json
{
  "id": "microtask_id",
  "taskId": "task_id",
  "eventId": "event_id",
  "title": "T√≠tulo da Microtarefa",
  "description": "Descri√ß√£o da microtarefa",
  "assignedTo": ["user_id1", "user_id2", "user_id3"],
  "maxVolunteers": 5,
  "requiredSkills": ["skill1"],
  "requiredResources": ["resource1"],
  "startDateTime": "timestamp", // Data e hora inicial espec√≠fica (dd/mm/yyyy HH:MM)
  "endDateTime": "timestamp", // Data e hora final espec√≠fica (dd/mm/yyyy HH:MM)
  "priority": "high|medium|low",
  "status": "pending|assigned|in_progress|completed|cancelled",
  "createdBy": "user_id",
  "assignedAt": "timestamp",
  "startedAt": "timestamp",
  "completedAt": "timestamp",
  "notes": "Observa√ß√µes gerais da microtask",
  "createdAt": "timestamp",
  "updatedAt": "timestamp"
}
```

### Collection: volunteer_profiles
```json
{
  // Dados denormalizados do usu√°rio
  "userName": "Nome do Usu√°rio",
  "userEmail": "email@exemplo.com",
  "userPhotoUrl": "url_da_foto",
  // Dados do perfil
  "assignedMicrotasksCount": 0,
  "id": "volunteer_profile_id",
  "userId": "user_id",
  "eventId": "event_id",
  "availableDays": ["monday", "tuesday", "wednesday"],
  "availableHours": {
    "start": "09:00",
    "end": "18:00"
  },
  "isFullTimeAvailable": false, // Disponibilidade integral (qualquer hor√°rio)
  "skills": ["skill1", "skill2"],
  "resources": ["resource1", "resource2"],
  "joinedAt": "timestamp"
}
```
### Collection: user_microtasks
```json
{
  "id": "user_microtask_id",
  "userId": "user_id",
  "microtaskId": "microtask_id",
  "eventId": "event_id",
  "status": "assigned|in_progress|completed",
  "assignedAt": "timestamp",
  "startedAt": "timestamp",
  "completedAt": "timestamp",
  "actualHours": 0.0,
  "notes": "Observa√ß√µes do volunt√°rio",
  "createdAt": "timestamp",
  "updatedAt": "timestamp"
}
```

## üõ†Ô∏è Stack Tecnol√≥gica

### Frontend
- **Flutter** (vers√£o est√°vel mais recente)
- **Dart** (linguagem principal)

### Gerenciamento de Estado
- **Provider** ou **GetX** (a definir)

### Backend & Servi√ßos
- **Firebase Auth** (autentica√ß√£o)
- **Firebase Firestore** (banco de dados)
- **Firebase Storage** (armazenamento de arquivos)

### Depend√™ncias Principais
```yaml
dependencies:
  flutter:
    sdk: flutter
  firebase_core: ^2.15.1
  firebase_auth: ^4.7.3
  cloud_firestore: ^4.8.5
  firebase_storage: ^11.2.6
  google_sign_in: ^6.1.4
  provider: ^6.0.5  # ou get: ^4.6.5
  cached_network_image: ^3.2.3
  intl: ^0.18.1
  uuid: ^3.0.7
```

## üîß Funcionalidades Espec√≠ficas

### Sistema de Atribui√ß√£o Inteligente
- Compatibilidade autom√°tica entre habilidades necess√°rias e dispon√≠veis
- Verifica√ß√£o de disponibilidade de hor√°rios espec√≠ficos (dd/mm/yyyy HH:MM)
- Suporte a disponibilidade integral (volunt√°rios dispon√≠veis a qualquer momento)
- Sugest√£o de volunt√°rios mais adequados **para microtasks espec√≠ficas**
- Tasks servem apenas como agrupadores organizacionais
- **Controle de capacidade m√°xima por microtask**
- Algoritmo de distribui√ß√£o equilibrada entre volunt√°rios

### Gerenciamento de C√≥digos/Tags
- Gera√ß√£o autom√°tica de c√≥digos √∫nicos alfanum√©ricos
- Valida√ß√£o de c√≥digos existentes
- Expira√ß√£o opcional de c√≥digos

### Sistema de Status
- **Eventos:** active, completed, cancelled
- **Tasks:** pending, in_progress, completed
- **Microtasks:** pending, assigned, in_progress, completed, cancelled

### Sistema de Data/Hora Espec√≠fica para Microtasks
- **Defini√ß√£o precisa de hor√°rios**: Cada microtask possui data/hora inicial e final espec√≠ficas (formato dd/mm/yyyy HH:MM)
- **Substitui√ß√£o do sistema de horas estimadas**: Ao inv√©s de estimar dura√ß√£o, define-se per√≠odo exato de execu√ß√£o
- **Valida√ß√£o de per√≠odos**: Sistema impede cria√ß√£o de microtasks com data/hora inicial posterior √† final
- **Compatibilidade com disponibilidade**: Verifica se volunt√°rios est√£o dispon√≠veis no per√≠odo da microtask

### Sistema de Disponibilidade Integral para Volunt√°rios
- **Op√ß√£o de disponibilidade total**: Volunt√°rios podem marcar disponibilidade integral (qualquer hor√°rio)
- **Flexibilidade m√°xima**: Volunt√°rios com disponibilidade integral podem ser atribu√≠dos a qualquer microtask
- **Interface simplificada**: Quando marcada disponibilidade integral, campos espec√≠ficos de dias/hor√°rios s√£o ocultados
- **Valida√ß√£o inteligente**: Sistema aceita tanto disponibilidade espec√≠fica quanto integral

### Sistema de Participa√ß√£o Inteligente
- **Verifica√ß√£o de participa√ß√£o existente** antes de permitir nova inscri√ß√£o
- **Exibi√ß√£o de status de participa√ß√£o** no resultado da busca
- **Filtragem de habilidades/recursos** baseada nas necessidades do evento
- **Alinhamento de interface** para melhor experi√™ncia do usu√°rio

## üöÄ Fases de Desenvolvimento

### ‚úÖ Fase 1: Autentica√ß√£o e Estrutura Base
- Sistema de login/cadastro
- Configura√ß√£o Firebase
- Estrutura de pastas
- Tema e componentes b√°sicos

### ‚úÖ Fase 2: Gerenciamento de Eventos
- Cria√ß√£o de eventos
- Sistema de tags/c√≥digos
- Ingresso de volunt√°rios
- **Melhorias de UX:** Alinhamento de bot√µes, verifica√ß√£o de participa√ß√£o, filtros de habilidades

### üöß Fase 3: Sistema de Tarefas (EM DESENVOLVIMENTO)
- Cria√ß√£o de tasks e microtasks
- Atribui√ß√£o manual de volunt√°rios
- Acompanhamento de progresso

### Fase 4: Funcionalidades Avan√ßadas
- Sistema de atribui√ß√£o inteligente
- Perfis detalhados de volunt√°rios
- Relat√≥rios e estat√≠sticas

## üìù Considera√ß√µes Importantes

### Exclus√µes da Vers√£o 1.0
- Sistema de notifica√ß√µes push
- Testes automatizados
- Chat/mensagens entre usu√°rios
- Sistema de avalia√ß√µes/feedback

### Regras de Neg√≥cio
- Apenas gerenciadores podem criar tasks/microtasks
- Volunt√°rios podem ser promovidos a gerenciadores
- **Volunt√°rios s√£o atribu√≠dos exclusivamente √†s microtasks** (Tasks s√£o apenas organizadores)
- Microtasks s√≥ podem ser atribu√≠das a volunt√°rios com habilidades compat√≠veis
- **Cada microtask pode ter m√∫ltiplos volunt√°rios** (definido pelo campo maxVolunteers)
- O progresso da Task √© calculado automaticamente baseado nas microtasks conclu√≠das
- Eventos podem ter m√∫ltiplos gerenciadores
- **Microtask √© considerada conclu√≠da quando todos os volunt√°rios atribu√≠dos marcam como conclu√≠da**

### Valida√ß√µes Principais
- C√≥digos de evento √∫nicos
- Verifica√ß√£o de permiss√µes por role
- Valida√ß√£o de compatibilidade antes da atribui√ß√£o de microtasks
- Controle de status das microtasks (Tasks herdam status das microtasks)
- Verifica√ß√£o de disponibilidade do volunt√°rio antes da atribui√ß√£o
- **Controle de capacidade m√°xima por microtask**
- **Preven√ß√£o de atribui√ß√£o dupla do mesmo volunt√°rio √† mesma microtask**
- Valida√ß√£o de conclus√£o colaborativa (todos os volunt√°rios devem marcar como conclu√≠da)
- **Verifica√ß√£o de participa√ß√£o existente** antes de permitir nova inscri√ß√£o no evento

### Melhorias de UX Implementadas
- **Alinhamento de bot√µes:** Bot√µes "Buscar" e "Adicionar" alinhados √† esquerda com campos de texto
- **Verifica√ß√£o de participa√ß√£o:** Sistema impede participa√ß√£o dupla e informa status atual
- **Filtros inteligentes:** Habilidades/recursos do evento aparecem como op√ß√µes priorit√°rias
- **Feedback visual:** Indicadores claros de status de participa√ß√£o

---

**Observa√ß√£o:** Esta especifica√ß√£o serve como base para desenvolvimento. Detalhes de implementa√ß√£o e ajustes podem ser refinados durante o processo de desenvolvimento.
## .cursorignore <a id="cursorignore"></a>

# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.build/
.buildlog/
.history
.svn/
.swiftpm/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release
# Add directories or file patterns to ignore during indexing (e.g. foo/ or *.csv)

## docs\volunteer_management_optimization_analysis.md <a id="volunteer_management_optimization_analysis_md"></a>

# Volunteer Management Screen Optimization Analysis

## Overview
This document analyzes the performance improvements achieved by optimizing the data fetching strategy for the volunteer management screen.

## Before Optimization

### Data Fetching Strategy
1. **Primary Query**: `volunteer_profiles` collection
   - Query: `WHERE eventId = {eventId}`
   - Returns: All volunteer profiles for the event

2. **Secondary Queries**: `users` collection (multiple queries due to Firestore limitations)
   - Query: `WHERE id IN [userId1, userId2, ..., userId10]` (max 10 per query)
   - Number of queries: `ceil(volunteer_count / 10)`
   - Returns: User data (name, email, photoUrl) for each volunteer

### Firestore Read Count (Before)
- **1 read** for volunteer profiles
- **N reads** for user data (where N = ceil(volunteer_count / 10))
- **Total reads**: `1 + ceil(volunteer_count / 10)`

### Examples:
- **10 volunteers**: 1 + 1 = **2 reads**
- **25 volunteers**: 1 + 3 = **4 reads**
- **50 volunteers**: 1 + 5 = **6 reads**
- **100 volunteers**: 1 + 10 = **11 reads**

### Performance Issues
1. **Multiple network requests** for user data
2. **Sequential processing** (profiles first, then users)
3. **No caching** - repeated queries for same data
4. **UI blocking** during multiple async operations
5. **Data consistency issues** if user data changes

## After Optimization

### Data Fetching Strategy
1. **Single Query**: `volunteer_profiles` collection (with denormalized user data)
   - Query: `WHERE eventId = {eventId}`
   - Returns: All volunteer profiles with embedded user data (name, email, photoUrl)

2. **Local Caching**: In-memory cache with 5-minute expiration
   - Cache key: "[REDACTED]"
   - Cache validation: Timestamp-based expiration
   - Cache invalidation: Manual clearing when data changes

### Firestore Read Count (After)
- **1 read** for volunteer profiles (with denormalized user data)
- **0 additional reads** for user data
- **Total reads**: `1` (or `0` if cached)

### Examples:
- **10 volunteers**: **1 read** (2 reads saved)
- **25 volunteers**: **1 read** (3 reads saved)
- **50 volunteers**: **1 read** (5 reads saved)
- **100 volunteers**: **1 read** (10 reads saved)

### Performance Improvements
1. **Single network request** for all data
2. **Parallel processing** eliminated (no secondary queries)
3. **Local caching** reduces repeated queries
4. **Non-blocking UI** with faster data loading
5. **Data consistency** through denormalization sync

## Implementation Details

### 1. Enhanced VolunteerProfileModel
```dart
class VolunteerProfileModel {
  // Existing fields...

  // Denormalized user data
  final String userName;
  final String userEmail;
  final String? userPhotoUrl;

  // Convenience methods
  bool get hasValidUserData;
  String get userInitials;
  String get userFirstName;
  bool get hasUserPhoto;
}
```

### 2. Optimized Controller Method
```dart
Future<List<VolunteerProfileModel>> getEventVolunteersOptimized(String eventId) async {
  // Check cache first
  if (_isCacheValid(eventId)) {
    return List.from(_volunteersCache[eventId]!);
  }

  // Single query with denormalized data
  final profiles = await _eventRepository.getEventVolunteers(eventId);

  // Update cache
  _volunteersCache[eventId] = List.from(profiles);
  _cacheTimestamps[eventId] = DateTime.now();

  return profiles;
}
```

### 3. Data Synchronization
```dart
Future<void> updateUserDataInVolunteerProfiles(
  String userId,
  String userName,
  String userEmail,
  String? userPhotoUrl,
) async {
  // Updates all volunteer profiles when user data changes
  // Maintains data consistency across denormalized fields
}
```

## Performance Metrics

### Read Reduction
| Volunteers | Before | After | Savings | Improvement |
|------------|--------|-------|---------|-------------|
| 10         | 2      | 1     | 1       | 50%         |
| 25         | 4      | 1     | 3       | 75%         |
| 50         | 6      | 1     | 5       | 83%         |
| 100        | 11     | 1     | 10      | 91%         |

### With Caching (Subsequent Loads)
| Volunteers | Before | After | Savings | Improvement |
|------------|--------|-------|---------|-------------|
| 10         | 2      | 0     | 2       | 100%        |
| 25         | 4      | 0     | 4       | 100%        |
| 50         | 6      | 0     | 6       | 100%        |
| 100        | 11     | 0     | 11      | 100%        |

### Network Latency Impact
- **Before**: Multiple sequential requests (cumulative latency)
- **After**: Single request (single latency)
- **Improvement**: ~60-90% reduction in total loading time

### Cost Savings (Firestore Pricing)
- **Read operations**: $0.06 per 100,000 reads
- **Monthly savings** (1000 volunteers, 100 views/day):
  - Before: 1,100 reads/day √ó 30 days = 33,000 reads/month
  - After: 100 reads/day √ó 30 days = 3,000 reads/month
  - **Savings**: 30,000 reads/month = ~$0.018/month per event

## Trade-offs and Considerations

### Benefits
‚úÖ **Significant read reduction** (50-91% fewer Firestore reads)
‚úÖ **Faster loading times** (single network request)
‚úÖ **Better user experience** (local caching)
‚úÖ **Cost savings** (reduced Firestore usage)
‚úÖ **Simplified data flow** (no complex joins)

### Trade-offs
‚ö†Ô∏è **Increased storage** (denormalized data duplication)
‚ö†Ô∏è **Data synchronization complexity** (keeping user data in sync)
‚ö†Ô∏è **Memory usage** (local caching)
‚ö†Ô∏è **Migration effort** (updating existing profiles)

### Mitigation Strategies
1. **Automated sync**: User data updates trigger profile updates
2. **Cache management**: Automatic expiration and manual invalidation
3. **Migration utility**: One-time script to populate user data
4. **Fallback logic**: Graceful handling of missing user data

## Conclusion

The optimization provides substantial performance improvements with manageable trade-offs. The 50-91% reduction in Firestore reads, combined with local caching, significantly improves the user experience while reducing operational costs.

The denormalization strategy is well-suited for this use case where:
- User data changes infrequently
- Read operations far exceed write operations
- Performance is critical for user experience
- Cost optimization is important

## Next Steps

1. **Monitor performance** in production
2. **Implement automated sync** for user data changes
3. **Add metrics collection** for optimization validation
4. **Consider similar optimizations** for other screens
5. **Evaluate caching strategies** for other data types

## TESTE_FASE2.md <a id="TESTE_FASE2_md"></a>

# Testes da Fase 2: Tela Home e Gerenciamento de Eventos

## ‚úÖ Funcionalidades Implementadas

### 1. Modelos de Dados
- [x] **EventModel**: Modelo completo para eventos com valida√ß√µes
- [x] **VolunteerProfileModel**: Modelo para perfil de volunt√°rios
- [x] **TimeRange**: Classe para representar intervalos de tempo
- [x] **Enums**: EventStatus, UserRole para tipagem segura

### 2. Servi√ßos e Reposit√≥rios
- [x] **EventService**: Servi√ßo para opera√ß√µes no Firebase
- [x] **EventRepository**: Camada de abstra√ß√£o para dados
- [x] **EventController**: Gerenciamento de estado com Provider
- [x] **Tratamento de Exce√ß√µes**: Sistema robusto de erros

### 3. Telas Implementadas
- [x] **HomeScreen**: Tela principal com lista de eventos
- [x] **CreateEventScreen**: Cria√ß√£o de eventos com formul√°rio completo
- [x] **JoinEventScreen**: Participa√ß√£o em eventos via c√≥digo

### 4. Widgets Reutiliz√°veis
- [x] **EventCard**: Card para exibir eventos na lista
- [x] **EventInfoCard**: Card detalhado de informa√ß√µes do evento
- [x] **EventStatsWidget**: Widget de estat√≠sticas do evento
- [x] **SkillChip**: Chip para habilidades e recursos
- [x] **ErrorMessageWidget**: Widget para mensagens de erro
- [x] **LoadingWidget**: Widget de loading consistente

### 5. Sistema de Navega√ß√£o
- [x] **AppRoutes**: Rotas organizadas e m√©todos de navega√ß√£o
- [x] **Navega√ß√£o entre telas**: Fluxo completo implementado
- [x] **Passagem de par√¢metros**: Sistema robusto de argumentos

### 6. Valida√ß√µes e Tratamento de Erros
- [x] **FormValidators**: Valida√ß√µes de formul√°rios
- [x] **ErrorHandler**: Tratamento de erros do Firebase
- [x] **Estados de loading**: Feedback visual para usu√°rio
- [x] **Mensagens de erro**: Sistema consistente de feedback

### 7. Melhorias de UX Implementadas
- [x] **Alinhamento de bot√µes**: Bot√µes "Buscar" e "Adicionar" alinhados √† esquerda com campos de texto
- [x] **Verifica√ß√£o de participa√ß√£o**: Sistema impede participa√ß√£o dupla e informa status atual
- [x] **Filtros inteligentes**: Habilidades/recursos do evento aparecem como op√ß√µes priorit√°rias
- [x] **Feedback visual**: Indicadores claros de status de participa√ß√£o

## üß™ Plano de Testes

### Teste 1: Fluxo de Cria√ß√£o de Evento
**Objetivo**: Validar cria√ß√£o completa de um evento

**Passos**:
1. Abrir o app e fazer login
2. Na tela home, tocar no FAB
3. Selecionar "Criar Evento"
4. Preencher formul√°rio:
   - Nome: "Evento de Teste"
   - Descri√ß√£o: "Descri√ß√£o do evento de teste"
   - Localiza√ß√£o: "S√£o Paulo, SP"
   - Selecionar 2-3 habilidades
   - Selecionar 1-2 recursos
5. Tocar em "Criar Evento"
6. Verificar dialog de sucesso com c√≥digo
7. Verificar se evento aparece na lista da home

**Resultado Esperado**:
- Evento criado com sucesso
- C√≥digo √∫nico gerado
- Evento vis√≠vel na home
- Usu√°rio aparece como criador

### Teste 2: Fluxo de Participa√ß√£o em Evento
**Objetivo**: Validar participa√ß√£o em evento via c√≥digo

**Passos**:
1. Usar c√≥digo do evento criado no Teste 1
2. Na tela home, tocar no FAB
3. Selecionar "Participar de Evento"
4. Inserir c√≥digo do evento
5. Tocar em "Buscar"
6. Verificar detalhes do evento encontrado
7. Preencher perfil de volunt√°rio:
   - Selecionar dias dispon√≠veis
   - Definir hor√°rio (ex: 09:00 - 17:00)
   - Selecionar habilidades pessoais
   - Selecionar recursos dispon√≠veis
8. Tocar em "Confirmar Participa√ß√£o"
9. Verificar dialog de sucesso
10. Verificar se evento aparece na home

**Resultado Esperado**:
- Evento encontrado corretamente
- Perfil de volunt√°rio criado
- Participa√ß√£o confirmada
- Evento vis√≠vel na home com papel de volunt√°rio

### Teste 3: Valida√ß√µes de Formul√°rio
**Objetivo**: Validar sistema de valida√ß√µes

**Cen√°rios de Teste**:

#### 3.1 Criar Evento - Campos Obrigat√≥rios
- Tentar criar evento sem nome ‚Üí Erro: "Nome do evento √© obrigat√≥rio"
- Tentar criar evento sem localiza√ß√£o ‚Üí Erro: "Localiza√ß√£o √© obrigat√≥ria"
- Nome com menos de 3 caracteres ‚Üí Erro: "Nome deve ter pelo menos 3 caracteres"
- Nome com mais de 100 caracteres ‚Üí Erro: "Nome deve ter no m√°ximo 100 caracteres"

#### 3.2 Participar de Evento - Valida√ß√µes de C√≥digo
- Campo vazio ‚Üí Erro: "C√≥digo do evento √© obrigat√≥rio"
- C√≥digo com menos de 6 caracteres ‚Üí Erro: "C√≥digo deve ter exatamente 6 caracteres"
- C√≥digo inexistente ‚Üí Erro: "Evento n√£o encontrado"

#### 3.3 Perfil de Volunt√°rio - Valida√ß√µes
- Nenhum dia selecionado ‚Üí Erro: "Selecione pelo menos um dia de disponibilidade"
- Hor√°rio inv√°lido ‚Üí Valida√ß√£o autom√°tica do TimePicker

### Teste 4: Estados de Loading e Erro
**Objetivo**: Validar feedback visual para usu√°rio

**Cen√°rios**:
1. **Loading na cria√ß√£o**: Verificar indicador durante cria√ß√£o de evento
2. **Loading na busca**: Verificar indicador durante busca por c√≥digo
3. **Loading na participa√ß√£o**: Verificar indicador durante confirma√ß√£o
4. **Erro de rede**: Simular erro de conex√£o e verificar mensagem
5. **Erro de valida√ß√£o**: Verificar exibi√ß√£o de erros de formul√°rio

### Teste 5: Interface e UX
**Objetivo**: Validar experi√™ncia do usu√°rio

**Aspectos a Verificar**:
- [x] AppBar com foto do usu√°rio
- [x] Lista de eventos responsiva
- [x] Cards de eventos informativos
- [x] FAB com op√ß√µes claras
- [x] Formul√°rios bem organizados
- [x] Chips de habilidades/recursos funcionais
- [x] Navega√ß√£o intuitiva
- [x] Feedback visual consistente

## üêõ Bugs Conhecidos e Limita√ß√µes

### Limita√ß√µes Atuais
1. **C√≥pia para clipboard**: N√£o implementada (TODO)
2. **Fotos de usu√°rio**: Usando iniciais como fallback
3. **Notifica√ß√µes**: N√£o implementadas nesta fase
4. **Busca avan√ßada**: Apenas por c√≥digo exato
5. **Edi√ß√£o de eventos**: N√£o implementada nesta fase

### Melhorias Futuras
1. **Filtros na home**: Por status, localiza√ß√£o, etc.
2. **Busca por texto**: Buscar eventos por nome
3. **Geolocaliza√ß√£o**: Eventos pr√≥ximos
4. **Chat**: Comunica√ß√£o entre participantes
5. **Calend√°rio**: Visualiza√ß√£o temporal dos eventos

## üìä M√©tricas de Qualidade

### Cobertura de Funcionalidades
- ‚úÖ Cria√ß√£o de eventos: 100%
- ‚úÖ Participa√ß√£o em eventos: 100%
- ‚úÖ Listagem de eventos: 100%
- ‚úÖ Valida√ß√µes: 100%
- ‚úÖ Tratamento de erros: 100%
- ‚úÖ Navega√ß√£o: 100%

### Arquitetura
- ‚úÖ Separa√ß√£o de responsabilidades
- ‚úÖ Padr√£o Repository implementado
- ‚úÖ Gerenciamento de estado com Provider
- ‚úÖ Tratamento de exce√ß√µes robusto
- ‚úÖ Widgets reutiliz√°veis
- ‚úÖ Valida√ß√µes centralizadas

## üöÄ Pr√≥ximos Passos (Fase 3)

1. **Detalhes do Evento**: Tela completa com informa√ß√µes
2. **Gerenciamento de Volunt√°rios**: Para organizadores
3. **Sistema de Tarefas**: Cria√ß√£o e atribui√ß√£o
4. **Notifica√ß√µes**: Push notifications
5. **Perfil do Usu√°rio**: Edi√ß√£o e configura√ß√µes

## ‚úÖ Checklist de Valida√ß√£o Final

### Funcionalidades Core
- [x] Usu√°rio pode criar eventos
- [x] Usu√°rio pode participar de eventos via c√≥digo
- [x] Eventos aparecem na tela home
- [x] Sistema de pap√©is funciona (criador/gerenciador/volunt√°rio)
- [x] Valida√ß√µes impedem dados inv√°lidos
- [x] Erros s√£o tratados adequadamente

### Qualidade de C√≥digo
- [x] C√≥digo bem estruturado e documentado
- [x] Separa√ß√£o clara de responsabilidades
- [x] Tratamento robusto de exce√ß√µes
- [x] Widgets reutiliz√°veis implementados
- [x] Navega√ß√£o organizada
- [x] Estados de loading implementados

### Experi√™ncia do Usu√°rio
- [x] Interface intuitiva e responsiva
- [x] Feedback visual adequado
- [x] Fluxos de navega√ß√£o claros
- [x] Mensagens de erro compreens√≠veis
- [x] Estados vazios tratados
- [x] Loading states implementados

## üéØ Conclus√£o

A **Fase 2: Tela Home e Gerenciamento de Eventos** foi implementada com sucesso, atendendo a todos os requisitos especificados no SPEC_GERAL.md. O sistema permite:

1. **Cria√ß√£o de eventos** com formul√°rio completo e valida√ß√µes
2. **Participa√ß√£o em eventos** via c√≥digo √∫nico
3. **Visualiza√ß√£o de eventos** na tela home
4. **Gerenciamento de estado** robusto
5. **Tratamento de erros** consistente
6. **Interface responsiva** e intuitiva

O c√≥digo est√° pronto para a pr√≥xima fase de desenvolvimento, com uma base s√≥lida e arquitetura bem estruturada.

## TESTE_FASE3.md <a id="TESTE_FASE3_md"></a>

# Testes da Fase 3: Sistema de Tarefas

## üéØ Objetivo da Fase 3
Implementar o sistema completo de tarefas hier√°rquicas (Tasks ‚Üí Microtasks) com suporte a m√∫ltiplos volunt√°rios por microtask, incluindo cria√ß√£o, atribui√ß√£o, acompanhamento e gerenciamento colaborativo.

## üìã Funcionalidades a Implementar

### 1. Modelos de Dados
- [x] **TaskModel**: Modelo para tasks (organizadoras)
- [x] **MicrotaskModel**: Modelo para microtasks com m√∫ltiplos volunt√°rios
- [x] **UserMicrotaskModel**: Rela√ß√£o usu√°rio-microtask para controle individual
- [x] **Enums**: TaskStatus, MicrotaskStatus, TaskPriority

### 2. Servi√ßos e Reposit√≥rios
- [x] **TaskService**: Opera√ß√µes CRUD para tasks
- [x] **MicrotaskService**: Opera√ß√µes CRUD para microtasks
- [x] **TaskRepository**: Camada de abstra√ß√£o para tasks
- [x] **MicrotaskRepository**: Camada de abstra√ß√£o para microtasks
- [x] **AssignmentService**: Sistema de atribui√ß√£o m√∫ltipla
- [x] **TaskController**: Gerenciamento de estado

### 3. Telas Principais
- [x] **EventDetailsScreen**: Tela com sistema de tabs
- [x] **CreateTasksScreen**: Cria√ß√£o de tasks e microtasks
- [x] **ManageVolunteersScreen**: Gerenciamento e atribui√ß√£o (placeholder)
- [x] **TrackTasksScreen**: Acompanhamento hier√°rquico (b√°sico)

### 4. Widgets Espec√≠ficos
- [x] **LoadingWidget**: Widget de carregamento
- [x] **TaskCard**: Card para exibir tasks com progresso e expans√£o
- [x] **MicrotaskCard**: Card para microtasks com m√∫ltiplos volunt√°rios
- [x] **VolunteerCard**: Card de volunt√°rio com informa√ß√µes e disponibilidade
- [x] **TaskProgressWidget**: Indicador de progresso (linear e circular)
- [x] **AssignmentDialog**: Dialog para atribui√ß√£o com filtros de compatibilidade
- [x] **ManageVolunteersScreen**: Tela completa para gerenciamento (estrutura pronta)

## üß™ Plano de Testes Detalhado

### Teste 1: Cria√ß√£o de Tasks
**Objetivo**: Validar cria√ß√£o de tasks organizadoras

**Pr√©-requisitos**:
- Usu√°rio logado como gerenciador de evento
- Evento criado na Fase 2

**Passos**:
1. Navegar para detalhes do evento
2. Acessar tab "Criar Tasks"
3. Preencher formul√°rio de task:
   - Nome: "Organiza√ß√£o do Local"
   - Descri√ß√£o: "Preparar e organizar o espa√ßo do evento"
   - Prioridade: Alta
4. Salvar task
5. Verificar se task aparece na lista
6. Verificar se task aparece no tab "Acompanhar Tasks"

**Resultado Esperado**:
- Task criada com sucesso
- Status inicial: "pending"
- Aparece em todas as visualiza√ß√µes relevantes

### Teste 2: Cria√ß√£o de Microtasks
**Objetivo**: Validar cria√ß√£o de microtasks com configura√ß√£o de m√∫ltiplos volunt√°rios

**Pr√©-requisitos**:
- Task criada no Teste 1

**Passos**:
1. Na tela "Criar Tasks", se√ß√£o "Criar Microtask"
2. Selecionar task pai: "Organiza√ß√£o do Local"
3. Preencher formul√°rio:
   - Nome: "Montagem de Palco"
   - Descri√ß√£o: "Montar estrutura do palco principal"
   - Habilidades necess√°rias: ["Montagem", "Trabalho em Altura"]
   - Recursos necess√°rios: ["Ferramentas", "EPI"]
   - **Data e hora inicial: 15/07/2025 08:00**
   - **Data e hora final: 15/07/2025 12:00**
   - Prioridade: Alta
   - **N√∫mero m√°ximo de volunt√°rios: 3**
4. Salvar microtask
5. Repetir para criar mais 2-3 microtasks

**Resultado Esperado**:
- Microtasks criadas com sucesso
- Campo maxVolunteers configurado corretamente
- **Data/hora inicial e final definidas corretamente**
- **Dura√ß√£o calculada automaticamente (4 horas)**
- Microtasks vinculadas √† task pai
- Status inicial: "pending"

### Teste 3: Sistema de Atribui√ß√£o M√∫ltipla
**Objetivo**: Validar atribui√ß√£o de m√∫ltiplos volunt√°rios √† mesma microtask

**Pr√©-requisitos**:
- Microtasks criadas no Teste 2
- Pelo menos 5 volunt√°rios no evento com habilidades compat√≠veis

**Passos**:
1. Navegar para tab "Gerenciar Volunt√°rios"
2. Selecionar primeiro volunt√°rio
3. Clicar em "Atribuir Microtask"
4. Selecionar microtask "Montagem de Palco"
5. Confirmar atribui√ß√£o
6. Repetir para mais 2 volunt√°rios (at√© o limite de 3)
7. Tentar atribuir um 4¬∫ volunt√°rio
8. Verificar se sistema impede (limite atingido)
9. Tentar atribuir o mesmo volunt√°rio novamente
10. Verificar se sistema impede (duplica√ß√£o)

**Resultado Esperado**:
- Primeiros 3 volunt√°rios atribu√≠dos com sucesso
- 4¬∫ volunt√°rio rejeitado (limite atingido)
- Duplica√ß√£o impedida
- Status da microtask muda para "assigned"
- Volunt√°rios aparecem na lista da microtask

### Teste 4: Acompanhamento Hier√°rquico
**Objetivo**: Validar visualiza√ß√£o hier√°rquica e controle de progresso

**Pr√©-requisitos**:
- Tasks e microtasks criadas
- Volunt√°rios atribu√≠dos

**Passos**:
1. Navegar para tab "Acompanhar Tasks"
2. Verificar estrutura hier√°rquica:
   - Tasks como containers expand√≠veis
   - Microtasks dentro das tasks
   - Lista de volunt√°rios por microtask
3. Expandir task "Organiza√ß√£o do Local"
4. Verificar microtasks e volunt√°rios atribu√≠dos
5. Clicar em microtask para ver detalhes
6. Verificar a√ß√µes dispon√≠veis para cada volunt√°rio

**Resultado Esperado**:
- Hierarquia clara e naveg√°vel
- Informa√ß√µes completas por microtask
- Lista de volunt√°rios vis√≠vel
- A√ß√µes contextuais dispon√≠veis

### Teste 5: Execu√ß√£o Colaborativa
**Objetivo**: Validar sistema de execu√ß√£o com m√∫ltiplos volunt√°rios

**Pr√©-requisitos**:
- Microtask com 3 volunt√°rios atribu√≠dos

**Cen√°rios de Teste**:

#### 5.1 In√≠cio de Trabalho
1. Volunt√°rio 1 marca microtask como "Iniciada"
2. Verificar se status muda para "in_progress"
3. Verificar se outros volunt√°rios veem a mudan√ßa
4. Volunt√°rio 2 tamb√©m marca como "Iniciada"
5. Verificar se n√£o h√° conflito

#### 5.2 Conclus√£o Parcial
1. Volunt√°rio 1 marca como "Conclu√≠da"
2. Verificar se microtask permanece "in_progress"
3. Verificar indicador de progresso (1/3 conclu√≠do)
4. Volunt√°rio 2 marca como "Conclu√≠da"
5. Verificar progresso (2/3 conclu√≠do)

#### 5.3 Conclus√£o Total
1. Volunt√°rio 3 marca como "Conclu√≠da"
2. Verificar se microtask muda para "completed"
3. Verificar se progresso da task pai √© atualizado
4. Verificar se task pai muda status se todas microtasks conclu√≠das

**Resultado Esperado**:
- Sistema de conclus√£o colaborativa funcional
- Progresso calculado corretamente
- Status propagado hierarquicamente

### Teste 6: Gerenciamento de Volunt√°rios
**Objetivo**: Validar opera√ß√µes de gerenciamento

**Cen√°rios**:

#### 6.1 Remo√ß√£o de Volunt√°rio
1. Na tela "Gerenciar Volunt√°rios"
2. Selecionar microtask com m√∫ltiplos volunt√°rios
3. Remover um volunt√°rio da microtask
4. Verificar se limite de vagas aumenta
5. Verificar se volunt√°rio n√£o aparece mais na lista

#### 6.2 Substitui√ß√£o de Volunt√°rio
1. Remover volunt√°rio de microtask
2. Atribuir novo volunt√°rio √† mesma microtask
3. Verificar se substitui√ß√£o funciona corretamente

#### 6.3 Promo√ß√£o a Gerenciador
1. Selecionar volunt√°rio
2. Promover a gerenciador
3. Verificar se ganha acesso √†s funcionalidades de gerenciamento

### Teste 7: Filtros e Busca
**Objetivo**: Validar sistema de filtros

**Passos**:
1. Na tela "Acompanhar Tasks"
2. Aplicar filtro por status: "pending"
3. Verificar se apenas tasks/microtasks pendentes aparecem
4. Filtrar por prioridade: "Alta"
5. Filtrar por volunt√°rio espec√≠fico
6. Combinar m√∫ltiplos filtros
7. Limpar filtros

**Resultado Esperado**:
- Filtros funcionam individualmente
- Combina√ß√£o de filtros funciona
- Limpeza de filtros restaura visualiza√ß√£o completa

### Teste 8: Sistema de Data/Hora Espec√≠fica
**Objetivo**: Validar novo sistema de data/hora para microtasks

**Cen√°rios**:

#### 8.1 Cria√ß√£o com Data/Hora V√°lida
1. Criar microtask com data/hora inicial: 15/07/2025 09:00
2. Definir data/hora final: 15/07/2025 13:00
3. Verificar se microtask √© criada com sucesso
4. Verificar se dura√ß√£o √© calculada corretamente (4 horas)

#### 8.2 Valida√ß√£o de Per√≠odos Inv√°lidos
1. Tentar criar microtask com data/hora inicial posterior √† final
2. Verificar se sistema impede cria√ß√£o
3. Verificar mensagem de erro apropriada

#### 8.3 Compatibilidade com Disponibilidade
1. Criar microtask para per√≠odo espec√≠fico
2. Tentar atribuir volunt√°rio dispon√≠vel no per√≠odo
3. Tentar atribuir volunt√°rio indispon√≠vel no per√≠odo
4. Verificar se sistema considera disponibilidade corretamente

### Teste 9: Sistema de Disponibilidade Integral
**Objetivo**: Validar op√ß√£o de disponibilidade integral para volunt√°rios

**Cen√°rios**:

#### 9.1 Cadastro com Disponibilidade Integral
1. Na tela de participa√ß√£o em evento
2. Marcar op√ß√£o "Disponibilidade integral"
3. Verificar se campos espec√≠ficos s√£o ocultados
4. Confirmar participa√ß√£o
5. Verificar se perfil √© criado corretamente

#### 9.2 Atribui√ß√£o de Volunt√°rio Integral
1. Atribuir volunt√°rio com disponibilidade integral a qualquer microtask
2. Verificar se atribui√ß√£o √© sempre aceita
3. Verificar se n√£o h√° restri√ß√µes de hor√°rio

#### 9.3 Altern√¢ncia entre Tipos de Disponibilidade
1. Marcar disponibilidade integral
2. Desmarcar e definir disponibilidade espec√≠fica
3. Verificar se campos aparecem/desaparecem corretamente
4. Verificar se valida√ß√µes funcionam adequadamente

### Teste 10: Valida√ß√µes de Neg√≥cio
**Objetivo**: Validar regras de neg√≥cio espec√≠ficas

**Cen√°rios**:

#### 10.1 Compatibilidade de Habilidades
1. Tentar atribuir volunt√°rio sem habilidades necess√°rias
2. Verificar se sistema impede ou alerta
3. Atribuir volunt√°rio com habilidades compat√≠veis
4. Verificar se atribui√ß√£o √© aceita

#### 10.2 Disponibilidade de Hor√°rios Espec√≠ficos
1. Verificar se sistema considera disponibilidade para per√≠odos espec√≠ficos
2. Tentar atribuir volunt√°rio indispon√≠vel no per√≠odo da microtask
3. Verificar tratamento adequado para disponibilidade integral

#### 10.3 Limites e Restri√ß√µes
1. Verificar limite m√°ximo de volunt√°rios por microtask
2. Verificar preven√ß√£o de atribui√ß√£o dupla
3. Verificar valida√ß√µes de formul√°rio para data/hora

## üêõ Cen√°rios de Erro a Testar

### Erros de Conectividade
- [ ] Cria√ß√£o de task sem internet
- [ ] Atribui√ß√£o de volunt√°rio com conex√£o inst√°vel
- [ ] Sincroniza√ß√£o de status entre dispositivos

### Erros de Valida√ß√£o
- [ ] Campos obrigat√≥rios vazios
- [ ] Limites de caracteres excedidos
- [ ] Valores inv√°lidos em campos num√©ricos

### Erros de Permiss√£o
- [ ] Volunt√°rio tentando criar tasks
- [ ] Acesso a funcionalidades restritas
- [ ] Modifica√ß√£o de dados sem permiss√£o

## üìä M√©tricas de Sucesso

### Funcionalidades Core
- [ ] Cria√ß√£o de tasks: 100% funcional
- [ ] Cria√ß√£o de microtasks: 100% funcional
- [ ] Atribui√ß√£o m√∫ltipla: 100% funcional
- [ ] Acompanhamento hier√°rquico: 100% funcional
- [ ] Execu√ß√£o colaborativa: 100% funcional
- [ ] Gerenciamento de volunt√°rios: 100% funcional

### Performance
- [ ] Carregamento de listas < 2 segundos
- [ ] Sincroniza√ß√£o em tempo real
- [ ] Interface responsiva

### Usabilidade
- [ ] Fluxos intuitivos
- [ ] Feedback visual adequado
- [ ] Navega√ß√£o clara
- [ ] Tratamento de erros compreens√≠vel

## üöÄ Crit√©rios de Aceita√ß√£o

Para considerar a Fase 3 conclu√≠da, todos os seguintes crit√©rios devem ser atendidos:

1. **Funcionalidades Implementadas**: Todas as funcionalidades listadas funcionando
2. **Sistema de Data/Hora**: Microtasks com data/hora espec√≠fica funcionando corretamente
3. **Disponibilidade Integral**: Op√ß√£o de disponibilidade integral para volunt√°rios implementada
4. **Testes Passando**: Todos os cen√°rios de teste executados com sucesso
5. **Valida√ß√µes Funcionando**: Regras de neg√≥cio implementadas e validadas
6. **Interface Completa**: Todas as telas e componentes implementados
7. **Performance Adequada**: Tempos de resposta dentro do esperado
8. **Tratamento de Erros**: Cen√°rios de erro tratados adequadamente

## üìù Pr√≥ximos Passos (Fase 4)

Ap√≥s conclus√£o da Fase 3:
1. Sistema de atribui√ß√£o inteligente autom√°tica
2. Relat√≥rios e estat√≠sticas avan√ßadas
3. Notifica√ß√µes push
4. Sistema de chat/comunica√ß√£o
5. Perfis detalhados de volunt√°rios

## TESTE_FASE3_AJUSTES.md <a id="TESTE_FASE3_AJUSTES_md"></a>

# **PRD: Melhorias no Gerenciamento de Volunt√°rios e Atribui√ß√£o de Tarefas**

Vers√£o: 1.0
Autor: Gemini
Data: 14 de Julho de 2025

## **1\. Introdu√ß√£o e Vis√£o Geral**

Este documento descreve os requisitos para aprimorar a tela de "Gerenciar Volunt√°rios" no aplicativo de gerenciamento de eventos. O objetivo √© transformar a tela atual em um painel de controle mais robusto, que forne√ßa aos gerentes de eventos informa√ß√µes claras sobre a disponibilidade, carga de trabalho e compatibilidade dos volunt√°rios, otimizando o processo de atribui√ß√£o de tarefas.

As melhorias propostas incluem a adi√ß√£o de indicadores visuais, filtros avan√ßados e um fluxo de atribui√ß√£o de tarefas mais intuitivo, alinhado com a l√≥gica de neg√≥cio de "Tasks" e "Microtasks" j√° especificada no projeto.

## **2\. O Problema**

A tela atual de gerenciamento de volunt√°rios √© funcional, mas apresenta algumas lacunas:

* **Falta de Informa√ß√£o Visual:** N√£o h√° uma indica√ß√£o clara da carga de trabalho de cada volunt√°rio (quantas tarefas j√° foram atribu√≠das).
* **Filtros B√°sicos:** Os filtros "Todos", "Dispon√≠veis" e "Com Tarefas" s√£o √∫teis, mas insuficientes para uma tomada de decis√£o r√°pida. Um gerente precisa filtrar por habilidades espec√≠ficas para encontrar o volunt√°rio certo para uma microtask.
* **Fluxo de Atribui√ß√£o Gen√©rico:** O modal atual apresenta as op√ß√µes "Atribuir Microtask" e "Promover a Gerente" juntas. A atribui√ß√£o de tarefas √© uma a√ß√£o complexa que merece uma tela dedicada para selecionar a microtask correta com base na compatibilidade.
* **Disponibilidade Incompleta:** A indica√ß√£o de "Indispon√≠vel hoje" √© boa, mas n√£o informa ao gerente *quando* o volunt√°rio estar√° dispon√≠vel, dificultando o planejamento.

## **3\. Solu√ß√£o Proposta**

Propomos uma reestrutura√ß√£o da se√ß√£o de gerenciamento de volunt√°rios, focando em tr√™s √°reas principais:

1. **Melhorar o Card do Volunt√°rio:** Enriquecer o card com mais informa√ß√µes visuais.
2. **Criar Filtros Avan√ßados:** Implementar um sistema de filtro por habilidades.
3. **Desenvolver Telas Dedicadas:** Criar telas espec√≠ficas para "Atribuir Microtask" e "Promover a Gerente", tornando o fluxo mais claro e funcional.

### **3.1. Mockups e Design das Novas Telas**

#### Tela 1: Gerenciamento de Volunt√°rios (Aprimorada)

**Melhorias no Card do Volunt√°rio:**

* **Indicador de Carga de Trabalho:** Um √≠cone de "tarefas" (assignment) com um n√∫mero indicando quantas microtasks est√£o atribu√≠das ao volunt√°rio.
* **Indicador de Compatibilidade:** Um √≠cone de "estrela" (star) que, ao ser usado com o filtro de habilidades, destacar√° volunt√°rios compat√≠veis.
* **Disponibilidade Detalhada:** Al√©m dos dias da semana, mostrar o hor√°rio de disponibilidade (ex: "10h-18h").

**Filtros Avan√ßados:**

* **Filtro por Habilidades:** Um bot√£o "Filtrar por Habilidade" que abre um modal para selecionar uma ou mais habilidades. A lista de volunt√°rios ser√° atualizada para mostrar apenas aqueles que possuem as habilidades selecionadas, destacando-os com o √≠cone de estrela.

#### Tela 2: Atribuir Microtask (Modal/Nova Tela)

Ao clicar em "Atribuir Microtask" no menu de op√ß√µes do volunt√°rio, o gerente ser√° levado a uma nova tela.

**Funcionalidades:**

* **Listagem Inteligente:** A lista de microtasks ser√° priorizada para mostrar as mais compat√≠veis com as habilidades do volunt√°rio selecionado.
* **Informa√ß√µes da Microtask:** Cada item da lista mostrar√°:
  * Nome da Microtask e da Task pai.
  * Habilidades necess√°rias (destacando as que o volunt√°rio possui).
  * Vagas dispon√≠veis (ex: "2 de 3 vagas preenchidas").
* **Confirma√ß√£o:** Um bot√£o "Atribuir" que s√≥ fica ativo se houver vagas dispon√≠veis.

#### Tela 3: Promover a Gerente (Modal de Confirma√ß√£o)

Ao clicar em "Promover a Gerente", um modal de confirma√ß√£o simples e direto ser√° exibido.

**Funcionalidades:**

* **Texto de Confirma√ß√£o:** Um texto claro perguntando se o gerente tem certeza de que deseja promover o usu√°rio, explicando que a a√ß√£o concede permiss√µes de gerenciamento.
* **A√ß√£o Irrevers√≠vel:** Um aviso de que a a√ß√£o n√£o pode ser desfeita facilmente.
* **Bot√µes:** "Confirmar Promo√ß√£o" e "Cancelar".

## **4\. Tarefas Detalhadas para Implementa√ß√£o**

Aqui est√° a lista de tarefas para um agente de IA ou equipe de desenvolvimento, baseada nos documentos de especifica√ß√£o e checklist.

### Tarefa 1: Atualizar o Modelo de Dados e a L√≥gica de Neg√≥cio

1. **Backend (Firestore):**
   * No volunteer\_profiles, adicione o campo assignedMicrotasksCount (Number) para armazenar a contagem de tarefas.
   * Garanta que a cole√ß√£o events no campo managers (Array) seja atualizada corretamente quando um volunt√°rio for promovido.
2. **Frontend (Model):**
   * Atualize o volunteer\_profile\_model.dart para incluir o novo campo assignedMicrotasksCount.

### Tarefa 2: Refatorar a Tela "Gerenciar Volunt√°rios" (manage\_volunteers\_screen.dart)

1. **Atualizar o VolunteerCard (volunteer\_card.dart):**
   * Adicione um Row para os novos indicadores visuais.
   * Inclua um Icon(Icons.assignment) junto com um Text para exibir volunteer.assignedMicrotasksCount.
   * Adicione um Icon(Icons.star) que ser√° controlado por uma vari√°vel de estado (ex: isCompatible).
   * Exiba o hor√°rio de disponibilidade (availableHours) do perfil do volunt√°rio.
2. **Implementar Filtro por Habilidades:**
   * Adicione um ElevatedButton "Filtrar por Habilidade" na tela.
   * Ao clicar, exiba um AlertDialog ou showModalBottomSheet que lista todas as requiredSkills do evento.
   * Permita a sele√ß√£o de m√∫ltiplas habilidades (usando CheckboxListTile).
   * Armazene as habilidades selecionadas em um StateProvider ou ChangeNotifier.
   * Filtre a lista de volunt√°rios com base nas habilidades selecionadas. O volunt√°rio deve possuir **todas** as habilidades do filtro para ser exibido.
   * Quando um filtro de habilidade estiver ativo, ative o √≠cone de estrela (isCompatible \= true) no VolunteerCard para os volunt√°rios que correspondem ao filtro.
3. **Refatorar o Menu de Op√ß√µes:**
   * No PopupMenuButton (ou similar) do VolunteerCard, mantenha as op√ß√µes "Atribuir Microtask" e "Promover a Gerente".
   * Ajuste a navega√ß√£o para que cada op√ß√£o chame sua respectiva nova tela/modal.

### Tarefa 3: Criar a Tela "Atribuir Microtask" (assignment\_screen.dart)

1. **Estrutura da Tela:**
   * Crie uma nova StatefulWidget chamada AssignmentScreen.
   * Receba o volunteerId e o eventId como par√¢metros.
   * Use um FutureBuilder ou um StreamBuilder para carregar as microtasks do evento que ainda n√£o est√£o conclu√≠das e que possuem vagas (assignedTo.length \< maxVolunteers).
2. **L√≥gica de Compatibilidade e Ordena√ß√£o:**
   * Busque o perfil do volunt√°rio (volunteer\_profile\_model) para obter suas habilidades.
   * Crie uma fun√ß√£o que ordene a lista de microtasks:
     1. Primeiro, as microtasks que requerem habilidades que o volunt√°rio possui.
     2. Depois, as demais microtasks.
   * Para cada microtask na lista, calcule as vagas restantes (maxVolunteers \- assignedTo.length).
3. **Construir o MicrotaskAssignmentCard:**
   * Crie um widget reutiliz√°vel para exibir cada microtask.
   * O card deve mostrar:
     * Nome da microtask e da task pai.
     * Wrap de Chips para as requiredSkills, destacando com uma cor diferente as que o volunt√°rio possui.
     * Texto "Vagas: X de Y".
     * Um ElevatedButton "Atribuir".
   * A l√≥gica do bot√£o "Atribuir" deve:
     * Estar desabilitado se n√£o houver vagas.
     * Ao ser clicado, chamar o AssignmentService para adicionar o userId do volunt√°rio ao array assignedTo da microtask.
     * Exibir um SnackBar de sucesso e fechar a tela (Navigator.pop).
     * Implementar tratamento de erro (ex: se a vaga for preenchida por outro gerente simultaneamente).

### Tarefa 4: Implementar o Modal "Promover a Gerente"

1. **Criar o ConfirmationDialog (confirmation\_dialog.dart):**
   * Crie um widget de di√°logo gen√©rico que possa ser reutilizado.
   * Ele deve aceitar title, content (texto descritivo) e uma fun√ß√£o onConfirm.
2. **L√≥gica da Promo√ß√£o:**
   * Na op√ß√£o "Promover a Gerente", chame showDialog com o ConfirmationDialog.
   * O texto deve alertar sobre a concess√£o de permiss√µes.
   * A fun√ß√£o onConfirm deve:
     1. Chamar um m√©todo no EventService ou EventRepository.
     2. Este m√©todo deve adicionar o userId do volunt√°rio ao array managers no documento do evento no Firestore.
     3. Exibir um SnackBar de sucesso.
## alteracao_corrente <a id="alteracao_corrente"></a>

REGRA alteradas
vamos fazer uns pequenos ajustes:
1 - para o voluntario na hora de selecionar a habiliidade e os recursos devem listar como op√ß√£o somente as habilidades necess√°rias definidas no evento, por√©m deve permitir ele inserir uma nova tbm digitando, como j√° est√° atualmente.
2 - os bot√µes de "Buscar" e "Adicionar" n√£o est√£o alinhados com a caixa de texto √° esquerda.
3 - quando o usuario j√° for participante do evento, e clicar pra buscar o evento, mostre os detalhes do evento como j√° est√° acontecendo hoje, por√©m mostre assim como √© mostrado em ativo, mas que ele j√° est√° participando, e nem mesmo permita ele se cadastrar por favor.


FASE 3
fa√ßa os seguintes ajustes antes de prosseguirmos os proximos passos da fase 3;
1- separe os bot√µes estatisticas, pois ficaram colados um no outro.
2 - ao sair da aplica√ß√£o e entrar novamente n√£o est√° encontrando as tasks criadas no evento
3 - vamos  substituir a aba tasks para telas de tasks e microtaks separadas, crie um bot√£o flutuante onde d√° a op√ß√£o de adicionar uma task ou uma microtask caso j√° tenha uma task (somente se j√° existir uma task caso n√£o exista exibe a mensagem que √© preciso criar uma task primeiro) e vamos remover a aba de tasks
4 - na microtask adicione somente as op√ß√µes de habilidades e recursos pr√© definidas no evento.


## .metadata <a id="metadata"></a>

# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "fcf2c11572af6f390246c056bc905eca609533a0"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: fcf2c11572af6f390246c056bc905eca609533a0
      base_revision: fcf2c11572af6f390246c056bc905eca609533a0
    - platform: android
      create_revision: fcf2c11572af6f390246c056bc905eca609533a0
      base_revision: fcf2c11572af6f390246c056bc905eca609533a0
    - platform: ios
      create_revision: fcf2c11572af6f390246c056bc905eca609533a0
      base_revision: fcf2c11572af6f390246c056bc905eca609533a0
    - platform: linux
      create_revision: fcf2c11572af6f390246c056bc905eca609533a0
      base_revision: fcf2c11572af6f390246c056bc905eca609533a0
    - platform: macos
      create_revision: fcf2c11572af6f390246c056bc905eca609533a0
      base_revision: fcf2c11572af6f390246c056bc905eca609533a0
    - platform: web
      create_revision: fcf2c11572af6f390246c056bc905eca609533a0
      base_revision: fcf2c11572af6f390246c056bc905eca609533a0
    - platform: windows
      create_revision: fcf2c11572af6f390246c056bc905eca609533a0
      base_revision: fcf2c11572af6f390246c056bc905eca609533a0

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'

## analysis_options.yaml <a id="analysis_options_yaml"></a>

# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options

## android\app\src\debug\AndroidManifest.xml <a id="AndroidManifest_xml"></a>

<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

## lib\core\constants\app_dimensions.dart <a id="app_dimensions_dart"></a>

/// Classe que define todas as dimens√µes utilizadas no aplicativo
/// Padroniza espa√ßamentos, tamanhos e bordas para consist√™ncia visual
class AppDimensions {
  // Espa√ßamentos
  static const double spacingXs = 4.0;
  static const double spacingSm = 8.0;
  static const double spacingMd = 16.0;
  static const double spacingLg = 24.0;
  static const double spacingXl = 32.0;
  static const double spacingXxl = 48.0;

  // Padding
  static const double paddingXs = 4.0;
  static const double paddingSm = 8.0;
  static const double paddingMd = 16.0;
  static const double paddingLg = 24.0;
  static const double paddingXl = 32.0;

  // Margin
  static const double marginXs = 4.0;
  static const double marginSm = 8.0;
  static const double marginMd = 16.0;
  static const double marginLg = 24.0;
  static const double marginXl = 32.0;

  // Border Radius
  static const double radiusXs = 4.0;
  static const double radiusSm = 8.0;
  static const double radiusMd = 12.0;
  static const double radiusLg = 16.0;
  static const double radiusXl = 24.0;
  static const double radiusRound = 50.0;

  // Tamanhos de Bot√µes
  static const double buttonHeightSm = 36.0;
  static const double buttonHeightMd = 48.0;
  static const double buttonHeightLg = 56.0;
  static const double buttonMinWidth = 88.0;

  // Tamanhos de √çcones
  static const double iconXs = 16.0;
  static const double iconSm = 20.0;
  static const double iconMd = 24.0;
  static const double iconLg = 32.0;
  static const double iconXl = 48.0;

  // Tamanhos de Avatar
  static const double avatarSm = 32.0;
  static const double avatarMd = 48.0;
  static const double avatarLg = 64.0;
  static const double avatarXl = 96.0;

  // Alturas de Componentes
  static const double textFieldHeight = 56.0;
  static const double appBarHeight = 56.0;
  static const double cardMinHeight = 80.0;
  static const double listItemHeight = 72.0;

  // Larguras
  static const double maxContentWidth = 600.0;
  static const double minButtonWidth = 120.0;
  static const double fabSize = 56.0;

  // Eleva√ß√µes (Material Design)
  static const double elevationNone = 0.0;
  static const double elevationSm = 2.0;
  static const double elevationMd = 4.0;
  static const double elevationLg = 8.0;
  static const double elevationXl = 16.0;

  // Bordas
  static const double borderWidthThin = 1.0;
  static const double borderWidthMedium = 2.0;
  static const double borderWidthThick = 4.0;

  // Tamanhos de Fonte (complementar ao tema)
  static const double fontSizeXs = 10.0;
  static const double fontSizeSm = 12.0;
  static const double fontSizeMd = 14.0;
  static const double fontSizeLg = 16.0;
  static const double fontSizeXl = 18.0;
  static const double fontSizeXxl = 20.0;
  static const double fontSizeTitle = 24.0;
  static const double fontSizeHeading = 32.0;

  // Opacidades
  static const double opacityDisabled = 0.38;
  static const double opacityMedium = 0.54;
  static const double opacityHigh = 0.87;
  static const double opacityFull = 1.0;

  // Dura√ß√£o de Anima√ß√µes
  static const int animationDurationFast = 150;
  static const int animationDurationMedium = 300;
  static const int animationDurationSlow = 500;

  // Breakpoints para Responsividade
  static const double breakpointMobile = 600.0;
  static const double breakpointTablet = 900.0;
  static const double breakpointDesktop = 1200.0;
}

## android\app\src\main\AndroidManifest.xml <a id="AndroidManifest_xml"></a>

<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="contask"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>

## lib\core\constants\app_colors.dart <a id="app_colors_dart"></a>

### Dependencies

- `package:flutter/material.dart`

import 'package:flutter/material.dart';

/// Classe que define todas as cores utilizadas no aplicativo
/// Baseado no Design System especificado no SPEC_GERAL.md
class AppColors {
  // Cores Principais
  static const Color primary = Color(0xFF6B46C1); // Roxo principal
  static const Color secondary = Color(0xFFA78BFA); // Roxo claro

  // Cores de Fundo
  static const Color background = Color(0xFFFFFFFF); // Branco
  static const Color surface = Color(0xFFF9FAFB); // Branco levemente acinzentado
  static const Color cardBackground = Color(0xFFFFFFFF); // Branco para cards

  // Cores de Texto
  static const Color textPrimary = Color(0xFF374151); // Cinza escuro
  static const Color textSecondary = Color(0xFF6B7280); // Cinza m√©dio
  static const Color textLight = Color(0xFF9CA3AF); // Cinza claro
  static const Color textOnPrimary = Color(0xFFFFFFFF); // Branco para texto em fundo roxo

  // Cores de Status
  static const Color success = Color(0xFF10B981); // Verde
  static const Color error = Color(0xFFEF4444); // Vermelho
  static const Color warning = Color(0xFFF59E0B); // Amarelo/Laranja
  static const Color info = Color(0xFF3B82F6); // Azul

  // Cores de Estado
  static const Color disabled = Color(0xFFD1D5DB); // Cinza para elementos desabilitados
  static const Color border = Color(0xFFE5E7EB); // Cinza para bordas
  static const Color divider = Color(0xFFF3F4F6); // Cinza muito claro para divisores

  // Cores de Prioridade (para tasks)
  static const Color priorityHigh = Color(0xFFEF4444); // Vermelho
  static const Color priorityMedium = Color(0xFFF59E0B); // Amarelo/Laranja
  static const Color priorityLow = Color(0xFF10B981); // Verde

  // Cores de Status de Task/Microtask
  static const Color statusPending = Color(0xFF6B7280); // Cinza
  static const Color statusInProgress = Color(0xFF3B82F6); // Azul
  static const Color statusCompleted = Color(0xFF10B981); // Verde
  static const Color statusCancelled = Color(0xFFEF4444); // Vermelho

  // Gradientes
  static const LinearGradient primaryGradient = LinearGradient(
    colors: [primary, secondary],
    begin: Alignment.topLeft,
    end: Alignment.bottomRight,
  );

  // Sombras
  static const Color shadowLight = Color(0x0F000000); // Sombra leve
  static const Color shadowMedium = Color(0x1A000000); // Sombra m√©dia
  static const Color shadowDark = Color(0x26000000); // Sombra escura
}

## lib\core\constants\app_constants.dart <a id="app_constants_dart"></a>

/// Classe que define constantes gerais da aplica√ß√£o
/// Inclui configura√ß√µes, limites e valores padr√£o
class AppConstants {
  // Configura√ß√µes de Autentica√ß√£o
  static const int passwordMinLength = 6;
  static const int passwordMaxLength = 128;
  static const int nameMinLength = 2;
  static const int nameMaxLength = 50;

  // Configura√ß√µes de Eventos
  static const int eventNameMinLength = 3;
  static const int eventNameMaxLength = 100;
  static const int eventDescriptionMaxLength = 500;
  static const int eventLocationMaxLength = 200;
  static const int eventTagLength = 6; // C√≥digo alfanum√©rico de 6 caracteres
  static const int maxSkillsPerEvent = 20;
  static const int maxResourcesPerEvent = 20;

  // Configura√ß√µes de Tasks
  static const int taskNameMinLength = 3;
  static const int taskNameMaxLength = 100;
  static const int taskDescriptionMaxLength = 500;
  static const int microtaskNameMinLength = 3;
  static const int microtaskNameMaxLength = 100;
  static const int microtaskDescriptionMaxLength = 1000;
  static const int maxMicrotasksPerTask = 50;
  static const double maxEstimatedHours = 100.0;
  static const double minEstimatedHours = 0.5;

  // Configura√ß√µes de Volunt√°rios
  static const int maxSkillsPerVolunteer = 15;
  static const int maxResourcesPerVolunteer = 15;
  static const int maxVolunteersPerEvent = 500;

  // Status de Eventos
  static const String eventStatusActive = 'active';
  static const String eventStatusCompleted = 'completed';
  static const String eventStatusCancelled = 'cancelled';

  // Status de Tasks
  static const String taskStatusPending = 'pending';
  static const String taskStatusInProgress = 'in_progress';
  static const String taskStatusCompleted = 'completed';

  // Status de Microtasks
  static const String microtaskStatusPending = 'pending';
  static const String microtaskStatusAssigned = 'assigned';
  static const String microtaskStatusInProgress = 'in_progress';
  static const String microtaskStatusCompleted = 'completed';
  static const String microtaskStatusCancelled = 'cancelled';

  // Prioridades
  static const String priorityHigh = 'high';
  static const String priorityMedium = 'medium';
  static const String priorityLow = 'low';

  // Roles de Usu√°rio
  static const String roleManager = 'manager';
  static const String roleVolunteer = 'volunteer';

  // Dias da Semana
  static const String dayMonday = 'monday';
  static const String dayTuesday = 'tuesday';
  static const String dayWednesday = 'wednesday';
  static const String dayThursday = 'thursday';
  static const String dayFriday = 'friday';
  static const String daySaturday = 'saturday';
  static const String daySunday = 'sunday';

  static const List<String> weekDays = [
    dayMonday,
    dayTuesday,
    dayWednesday,
    dayThursday,
    dayFriday,
    daySaturday,
    daySunday,
  ];

  // Cole√ß√µes do Firestore
  static const String usersCollection = 'users';
  static const String eventsCollection = 'events';
  static const String tasksCollection = 'tasks';
  static const String microtasksCollection = 'microtasks';
  static const String volunteerProfilesCollection = 'volunteer_profiles';

  // Configura√ß√µes de Cache
  static const int cacheExpirationHours = 24;
  static const int maxCacheSize = 100; // MB

  // Configura√ß√µes de Pagina√ß√£o
  static const int defaultPageSize = 20;
  static const int maxPageSize = 100;

  // Configura√ß√µes de Imagem
  static const int maxImageSizeMB = 5;
  static const List<String> allowedImageFormats = ['jpg', 'jpeg', 'png', 'webp'];

  // Timeouts
  static const int networkTimeoutSeconds = 30;
  static const int authTimeoutSeconds = 60;

  // Regex Patterns
  static const String emailPattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
  static const String eventTagPattern = r'^[A-Z0-9]{6}$';
  static const String phonePattern = r'^\+?[1-9]\d{1,14}$';

  // Configura√ß√µes de Notifica√ß√£o (para futuras implementa√ß√µes)
  static const String notificationChannelId = 'contask_notifications';
  static const String notificationChannelName = 'ConTask Notifications';

  // URLs e Links
  static const String privacyPolicyUrl = 'https://contask.app/privacy';
  static const String termsOfServiceUrl = 'https://contask.app/terms';
  static const String supportEmail = 'support@contask.app';

  // Configura√ß√µes de Debug
  static const bool enableDebugMode = true;
  static const bool enableAnalytics = false; // Para produ√ß√£o

  // Habilidades Padr√£o (podem ser expandidas pelos usu√°rios)
  static const List<String> defaultSkills = [
    'Organiza√ß√£o',
    'Comunica√ß√£o',
    'Lideran√ßa',
    'Trabalho em equipe',
    'Criatividade',
    'Resolu√ß√£o de problemas',
    'Gest√£o de tempo',
    'Tecnologia',
    'Design',
    'Marketing',
    'Vendas',
    'Atendimento ao cliente',
    'Log√≠stica',
    'Seguran√ßa',
    'Primeiros socorros',
  ];

  // Recursos Padr√£o (podem ser expandidos pelos usu√°rios)
  static const List<String> defaultResources = [
    'Ve√≠culo pr√≥prio',
    'Notebook/Computador',
    'Smartphone',
    'C√¢mera fotogr√°fica',
    'Equipamento de som',
    'Microfone',
    'Projetor',
    'Material de escrit√≥rio',
    'Ferramentas b√°sicas',
    'Equipamento de limpeza',
    'Mesa e cadeiras',
    'Tendas/Barracas',
    'Equipamento de cozinha',
    'Material esportivo',
    'Instrumentos musicais',
  ];
}

## lib\core\exceptions\app_exceptions.dart <a id="app_exceptions_dart"></a>

/// Classe base para todas as exce√ß√µes personalizadas da aplica√ß√£o
abstract class AppException implements Exception {
  final String message;
  final String? code;
  final dynamic originalException;

  const AppException(this.message, {this.code, this.originalException});

  @override
  String toString() => 'AppException: $message';
}

/// Exce√ß√µes relacionadas √† autentica√ß√£o
class AuthException extends AppException {
  const AuthException(super.message, {super.code, super.originalException});

  @override
  String toString() => 'AuthException: $message';
}

/// Exce√ß√µes relacionadas √† rede/conectividade
class NetworkException extends AppException {
  const NetworkException(super.message, {super.code, super.originalException});

  @override
  String toString() => 'NetworkException: $message';
}

/// Exce√ß√µes relacionadas ao Firestore
class FirestoreException extends AppException {
  const FirestoreException(
    super.message, {
    super.code,
    super.originalException,
  });

  @override
  String toString() => 'FirestoreException: $message';
}

/// Exce√ß√µes relacionadas √† valida√ß√£o de dados
class ValidationException extends AppException {
  const ValidationException(
    super.message, {
    super.code,
    super.originalException,
  });

  @override
  String toString() => 'ValidationException: $message';
}

/// Exce√ß√µes relacionadas a eventos
class EventException extends AppException {
  const EventException(super.message, {super.code, super.originalException});

  @override
  String toString() => 'EventException: $message';
}

/// Exce√ß√µes relacionadas a tarefas
class TaskException extends AppException {
  const TaskException(super.message, {super.code, super.originalException});

  @override
  String toString() => 'TaskException: $message';
}

/// Exce√ß√µes relacionadas a volunt√°rios
class VolunteerException extends AppException {
  const VolunteerException(
    super.message, {
    super.code,
    super.originalException,
  });

  @override
  String toString() => 'VolunteerException: $message';
}

/// Exce√ß√µes relacionadas a permiss√µes
class PermissionException extends AppException {
  const PermissionException(
    super.message, {
    super.code,
    super.originalException,
  });

  @override
  String toString() => 'PermissionException: $message';
}

/// Exce√ß√µes relacionadas ao cache/storage
class StorageException extends AppException {
  const StorageException(super.message, {super.code, super.originalException});

  @override
  String toString() => 'StorageException: $message';
}

/// Exce√ß√µes relacionadas ao banco de dados
class DatabaseException extends AppException {
  const DatabaseException(super.message, {super.code, super.originalException});

  @override
  String toString() => 'DatabaseException: $message';
}

/// Exce√ß√µes relacionadas ao reposit√≥rio
class RepositoryException extends AppException {
  const RepositoryException(
    super.message, {
    super.code,
    super.originalException,
  });

  @override
  String toString() => 'RepositoryException: $message';
}

/// Exce√ß√µes relacionadas a opera√ß√µes n√£o encontradas
class NotFoundException extends AppException {
  const NotFoundException(super.message, {super.code, super.originalException});

  @override
  String toString() => 'NotFoundException: $message';
}

/// Exce√ß√µes relacionadas a opera√ß√µes n√£o autorizadas
class UnauthorizedException extends AppException {
  const UnauthorizedException(
    super.message, {
    super.code,
    super.originalException,
  });

  @override
  String toString() => 'UnauthorizedException: $message';
}

/// Exce√ß√µes relacionadas a conflitos de dados
class ConflictException extends AppException {
  final String resource;

  const ConflictException(
    this.resource, {
    String? customMessage,
    super.code,
    super.originalException,
  }) : super(customMessage ?? 'Conflict with resource: $resource');

  @override
  String toString() => 'ConflictException: $resource';
}

/// Classe utilit√°ria para tratamento de exce√ß√µes
class ExceptionHandler {
  /// Converte exce√ß√µes do Firebase Auth em exce√ß√µes personalizadas
  static AuthException handleAuthException(dynamic exception) {
    final errorString = exception.toString().toLowerCase();
    String userMessage;
    String? code;

    if (errorString.contains('user-not-found')) {
      userMessage = 'Usu√°rio n√£o encontrado. Verifique o e-mail digitado.';
      code = 'user-not-found';
    } else if (errorString.contains('wrong-password')) {
      userMessage = 'Senha incorreta. Tente novamente ou redefina sua senha.';
      code = 'wrong-password';
    } else if (errorString.contains('email-already-in-use')) {
      userMessage =
          'Este e-mail j√° est√° em uso. Tente fazer login ou use outro e-mail.';
      code = 'email-already-in-use';
    } else if (errorString.contains('weak-password')) {
      userMessage = 'Senha muito fraca. Use pelo menos 6 caracteres.';
      code = 'weak-password';
    } else if (errorString.contains('invalid-email')) {
      userMessage = 'E-mail inv√°lido. Verifique o formato do e-mail.';
      code = 'invalid-email';
    } else if (errorString.contains('network-request-failed')) {
      userMessage =
          'Erro de conex√£o. Verifique sua internet e tente novamente.';
      code = 'network-request-failed';
    } else if (errorString.contains('too-many-requests')) {
      userMessage =
          'Muitas tentativas. Aguarde alguns minutos antes de tentar novamente.';
      code = 'too-many-requests';
    } else if (errorString.contains('user-disabled')) {
      userMessage =
          'Esta conta foi desabilitada. Entre em contato com o suporte.';
      code = 'user-disabled';
    } else if (errorString.contains('operation-not-allowed')) {
      userMessage = 'Opera√ß√£o n√£o permitida. Entre em contato com o suporte.';
      code = 'operation-not-allowed';
    } else if (errorString.contains('invalid-credential')) {
      userMessage = 'Credenciais inv√°lidas. Verifique e-mail e senha.';
      code = 'invalid-credential';
    } else {
      // Para erros n√£o mapeados, inclui a mensagem original
      userMessage =
          'Erro de autentica√ß√£o: ${_extractFirebaseErrorMessage(exception)}';
      code = 'unknown';
    }

    return AuthException(userMessage, code: code, originalException: exception);
  }

  /// Extrai a mensagem de erro do Firebase de forma mais limpa
  static String _extractFirebaseErrorMessage(dynamic exception) {
    final errorString = exception.toString();

    // Tenta extrair a mensagem entre colchetes ou ap√≥s dois pontos
    final regex = RegExp(r'\[(.*?)\]|:\s*(.+)$');
    final match = regex.firstMatch(errorString);

    if (match != null) {
      return match.group(1) ?? match.group(2) ?? errorString;
    }

    return errorString;
  }

  /// Converte exce√ß√µes do Firestore em exce√ß√µes personalizadas
  static FirestoreException handleFirestoreException(dynamic exception) {
    final errorString = exception.toString().toLowerCase();
    String userMessage;
    String? code;

    if (errorString.contains('permission-denied')) {
      userMessage = 'Permiss√£o negada. Voc√™ n√£o tem acesso a este recurso.';
      code = 'permission-denied';
    } else if (errorString.contains('not-found')) {
      userMessage = 'Dados n√£o encontrados. O item pode ter sido removido.';
      code = 'not-found';
    } else if (errorString.contains('already-exists')) {
      userMessage = 'Este item j√° existe. Tente usar um nome diferente.';
      code = 'already-exists';
    } else if (errorString.contains('unavailable')) {
      userMessage =
          'Servi√ßo temporariamente indispon√≠vel. Tente novamente em alguns minutos.';
      code = 'unavailable';
    } else if (errorString.contains('deadline-exceeded')) {
      userMessage =
          'Opera√ß√£o demorou muito para responder. Verifique sua conex√£o.';
      code = 'deadline-exceeded';
    } else if (errorString.contains('resource-exhausted')) {
      userMessage = 'Limite de uso excedido. Tente novamente mais tarde.';
      code = 'resource-exhausted';
    } else {
      userMessage =
          'Erro no banco de dados: ${_extractFirebaseErrorMessage(exception)}';
      code = 'unknown';
    }

    return FirestoreException(
      userMessage,
      code: code,
      originalException: exception,
    );
  }

  /// Converte exce√ß√µes de rede em exce√ß√µes personalizadas
  static NetworkException handleNetworkException(dynamic exception) {
    final errorString = exception.toString().toLowerCase();
    String userMessage;

    if (errorString.contains('timeout')) {
      userMessage =
          'Conex√£o expirou. Verifique sua internet e tente novamente.';
    } else if (errorString.contains('host lookup failed')) {
      userMessage =
          'N√£o foi poss√≠vel conectar ao servidor. Verifique sua internet.';
    } else if (errorString.contains('connection refused')) {
      userMessage = 'Servidor indispon√≠vel. Tente novamente mais tarde.';
    } else {
      userMessage =
          'Erro de conex√£o: ${_extractFirebaseErrorMessage(exception)}';
    }

    return NetworkException(userMessage, originalException: exception);
  }

  /// M√©todo gen√©rico para tratar qualquer exce√ß√£o
  static AppException handleGenericException(dynamic exception) {
    if (exception is AppException) {
      return exception;
    }

    // Retorna uma exce√ß√£o concreta em vez da classe abstrata
    return NetworkException(
      'Erro inesperado: ${_extractFirebaseErrorMessage(exception)}',
      originalException: exception,
    );
  }
}

## android\app\src\profile\AndroidManifest.xml <a id="AndroidManifest_xml"></a>

<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

## lib\presentation\routes\app_routes.dart <a id="app_routes_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../screens/auth/login_screen.dart`
- `../screens/auth/register_screen.dart`
- `../screens/home/home_screen.dart`
- `../screens/event/create_event_screen.dart`
- `../screens/event/join_event_screen.dart`
- `../screens/event/event_details_screen.dart`
- `../screens/task/create_task_screen.dart`
- `../screens/task/create_microtask_screen.dart`

import 'package:flutter/material.dart';
import '../screens/auth/login_screen.dart';
import '../screens/auth/register_screen.dart';
import '../screens/home/home_screen.dart';
import '../screens/event/create_event_screen.dart';
import '../screens/event/join_event_screen.dart';
import '../screens/event/event_details_screen.dart';
import '../screens/task/create_task_screen.dart';
import '../screens/task/create_microtask_screen.dart';

/// Classe respons√°vel por definir todas as rotas da aplica√ß√£o
class AppRoutes {
  // Nomes das rotas
  static const String login = '/login';
  static const String register = '/register';
  static const String home = '/home';
  static const String createEvent = '/create-event';
  static const String joinEvent = '/join-event';
  static const String eventDetails = '/event-details';
  static const String createTask = '/create-task';
  static const String createMicrotask = '/create-microtask';
  static const String createTasks = '/create-tasks';
  static const String manageVolunteers = '/manage-volunteers';
  static const String trackTasks = '/track-tasks';
  static const String profile = '/profile';

  /// Rota inicial da aplica√ß√£o
  static const String initialRoute = login;

  /// Mapa de todas as rotas da aplica√ß√£o
  static Map<String, WidgetBuilder> get routes {
    return {
      login: (context) => const LoginScreen(),
      register: (context) => const RegisterScreen(),
      home: (context) => const HomeScreen(),
      createEvent: (context) => const CreateEventScreen(),
      joinEvent: (context) => const JoinEventScreen(),
      // Outras rotas ser√£o adicionadas conforme implementadas
    };
  }

  /// Gerador de rotas para rotas din√¢micas
  static Route<dynamic>? onGenerateRoute(RouteSettings settings) {
    switch (settings.name) {
      case login:
        return _createRoute(const LoginScreen());
      case register:
        return _createRoute(const RegisterScreen());
      case home:
        return _createRoute(const HomeScreen());
      case createEvent:
        return _createRoute(const CreateEventScreen());
      case joinEvent:
        return _createRoute(const JoinEventScreen());

      // Rotas com par√¢metros
      case eventDetails:
        final eventId = settings.arguments as String;
        return _createRoute(EventDetailsScreen(eventId: eventId));

      case createTask:
        final eventId = settings.arguments as String;
        return _createRoute(CreateTaskScreen(eventId: eventId));

      case createMicrotask:
        final eventId = settings.arguments as String;
        return _createRoute(CreateMicrotaskScreen(eventId: eventId));

      default:
        return _createRoute(const NotFoundScreen());
    }
  }

  /// Cria uma rota com anima√ß√£o personalizada
  static PageRoute<T> _createRoute<T>(Widget page) {
    return PageRouteBuilder<T>(
      pageBuilder: (context, animation, secondaryAnimation) => page,
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        const begin = Offset(1.0, 0.0);
        const end = Offset.zero;
        const curve = Curves.easeInOut;

        var tween = Tween(
          begin: begin,
          end: end,
        ).chain(CurveTween(curve: curve));

        return SlideTransition(position: animation.drive(tween), child: child);
      },
      transitionDuration: const Duration(milliseconds: 300),
    );
  }

  /// Navega para uma rota removendo todas as anteriores
  static void pushAndRemoveUntil(
    BuildContext context,
    String routeName, {
    Object? arguments,
  }) {
    Navigator.of(context).pushNamedAndRemoveUntil(
      routeName,
      (route) => false,
      arguments: arguments,
    );
  }

  /// Navega para uma rota substituindo a atual
  static void pushReplacement(
    BuildContext context,
    String routeName, {
    Object? arguments,
  }) {
    Navigator.of(context).pushReplacementNamed(routeName, arguments: arguments);
  }

  /// Navega para uma rota
  static void push(
    BuildContext context,
    String routeName, {
    Object? arguments,
  }) {
    Navigator.of(context).pushNamed(routeName, arguments: arguments);
  }

  /// Volta para a rota anterior
  static void pop(BuildContext context, [Object? result]) {
    Navigator.of(context).pop(result);
  }

  /// Verifica se pode voltar
  static bool canPop(BuildContext context) {
    return Navigator.of(context).canPop();
  }

  /// Navega para a tela de login removendo todas as rotas anteriores
  static void goToLogin(BuildContext context) {
    pushAndRemoveUntil(context, login);
  }

  /// Navega para a tela home removendo todas as rotas anteriores
  static void goToHome(BuildContext context) {
    pushAndRemoveUntil(context, home);
  }

  /// Navega para a tela de cadastro
  static void goToRegister(BuildContext context) {
    push(context, register);
  }

  /// Navega para a tela de criar evento
  static void goToCreateEvent(BuildContext context) {
    push(context, createEvent);
  }

  /// Navega para a tela de participar de evento
  static void goToJoinEvent(BuildContext context) {
    push(context, joinEvent);
  }

  /// Navega para os detalhes de um evento
  static void goToEventDetails(BuildContext context, String eventId) {
    push(context, eventDetails, arguments: eventId);
  }

  /// Navega para a tela de criar tasks
  static void goToCreateTasks(BuildContext context, String eventId) {
    push(context, createTasks, arguments: eventId);
  }

  /// Navega para a tela de gerenciar volunt√°rios
  static void goToManageVolunteers(BuildContext context, String eventId) {
    push(context, manageVolunteers, arguments: eventId);
  }

  /// Navega para a tela de acompanhar tasks
  static void goToTrackTasks(BuildContext context, String eventId) {
    push(context, trackTasks, arguments: eventId);
  }

  /// Navega para a tela de perfil
  static void goToProfile(BuildContext context) {
    push(context, profile);
  }
}

/// Tela exibida quando uma rota n√£o √© encontrada
class NotFoundScreen extends StatelessWidget {
  const NotFoundScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('P√°gina n√£o encontrada')),
      body: const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, size: 64, color: Colors.grey),
            SizedBox(height: 16),
            Text(
              'P√°gina n√£o encontrada',
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 8),
            Text(
              'A p√°gina que voc√™ est√° procurando n√£o existe.',
              style: TextStyle(fontSize: 16, color: Colors.grey),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}

## lib\core\theme\app_theme.dart <a id="app_theme_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `package:flutter/services.dart`
- `../constants/app_colors.dart`
- `../constants/app_dimensions.dart`

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../constants/app_colors.dart';
import '../constants/app_dimensions.dart';

/// Classe respons√°vel por definir o tema da aplica√ß√£o
/// Implementa Material Design 3 com as cores personalizadas
class AppTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,

      // Color Scheme
      colorScheme: ColorScheme.fromSeed(
        seedColor: AppColors.primary,
        brightness: Brightness.light,
        primary: AppColors.primary,
        secondary: AppColors.secondary,
        surface: AppColors.surface,
        error: AppColors.error,
        onPrimary: AppColors.textOnPrimary,
        onSecondary: AppColors.textPrimary,
        onSurface: AppColors.textPrimary,
        onError: Colors.white,
      ),

      // App Bar Theme
      appBarTheme: const AppBarTheme(
        backgroundColor: AppColors.background,
        foregroundColor: AppColors.textPrimary,
        elevation: AppDimensions.elevationSm,
        centerTitle: true,
        titleTextStyle: TextStyle(
          color: AppColors.textPrimary,
          fontSize: AppDimensions.fontSizeXl,
          fontWeight: FontWeight.w600,
        ),
        systemOverlayStyle: SystemUiOverlayStyle(
          statusBarColor: Colors.transparent,
          statusBarIconBrightness: Brightness.dark,
        ),
      ),

      // Card Theme
      cardTheme: CardThemeData(
        color: AppColors.cardBackground,
        elevation: AppDimensions.elevationSm,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        ),
        margin: const EdgeInsets.symmetric(
          horizontal: AppDimensions.marginMd,
          vertical: AppDimensions.marginSm,
        ),
      ),

      // Elevated Button Theme
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppColors.primary,
          foregroundColor: AppColors.textOnPrimary,
          elevation: AppDimensions.elevationSm,
          minimumSize: const Size(
            AppDimensions.minButtonWidth,
            AppDimensions.buttonHeightMd,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
          ),
          textStyle: const TextStyle(
            fontSize: AppDimensions.fontSizeLg,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),

      // Outlined Button Theme
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: AppColors.primary,
          side: const BorderSide(
            color: AppColors.primary,
            width: AppDimensions.borderWidthThin,
          ),
          minimumSize: const Size(
            AppDimensions.minButtonWidth,
            AppDimensions.buttonHeightMd,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
          ),
          textStyle: const TextStyle(
            fontSize: AppDimensions.fontSizeLg,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),

      // Text Button Theme
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: AppColors.primary,
          minimumSize: const Size(
            AppDimensions.buttonMinWidth,
            AppDimensions.buttonHeightMd,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
          ),
          textStyle: const TextStyle(
            fontSize: AppDimensions.fontSizeLg,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),

      // Input Decoration Theme
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: AppColors.surface,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
          borderSide: const BorderSide(
            color: AppColors.border,
            width: AppDimensions.borderWidthThin,
          ),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
          borderSide: const BorderSide(
            color: AppColors.border,
            width: AppDimensions.borderWidthThin,
          ),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
          borderSide: const BorderSide(
            color: AppColors.primary,
            width: AppDimensions.borderWidthMedium,
          ),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
          borderSide: const BorderSide(
            color: AppColors.error,
            width: AppDimensions.borderWidthThin,
          ),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
          borderSide: const BorderSide(
            color: AppColors.error,
            width: AppDimensions.borderWidthMedium,
          ),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: AppDimensions.paddingMd,
          vertical: AppDimensions.paddingMd,
        ),
        hintStyle: const TextStyle(
          color: AppColors.textLight,
          fontSize: AppDimensions.fontSizeMd,
        ),
        labelStyle: const TextStyle(
          color: AppColors.textSecondary,
          fontSize: AppDimensions.fontSizeMd,
        ),
      ),

      // Floating Action Button Theme
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: AppColors.primary,
        foregroundColor: AppColors.textOnPrimary,
        elevation: AppDimensions.elevationMd,
        shape: CircleBorder(),
      ),

      // Chip Theme
      chipTheme: ChipThemeData(
        backgroundColor: AppColors.surface,
        selectedColor: AppColors.secondary,
        labelStyle: const TextStyle(
          color: AppColors.textPrimary,
          fontSize: AppDimensions.fontSizeSm,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusLg),
        ),
        padding: const EdgeInsets.symmetric(
          horizontal: AppDimensions.paddingSm,
          vertical: AppDimensions.paddingXs,
        ),
      ),

      // Divider Theme
      dividerTheme: const DividerThemeData(
        color: AppColors.divider,
        thickness: AppDimensions.borderWidthThin,
        space: AppDimensions.spacingMd,
      ),

      // List Tile Theme
      listTileTheme: const ListTileThemeData(
        contentPadding: EdgeInsets.symmetric(
          horizontal: AppDimensions.paddingMd,
          vertical: AppDimensions.paddingSm,
        ),
        titleTextStyle: TextStyle(
          color: AppColors.textPrimary,
          fontSize: AppDimensions.fontSizeMd,
          fontWeight: FontWeight.w500,
        ),
        subtitleTextStyle: TextStyle(
          color: AppColors.textSecondary,
          fontSize: AppDimensions.fontSizeSm,
        ),
      ),

      // Bottom Navigation Bar Theme
      bottomNavigationBarTheme: const BottomNavigationBarThemeData(
        backgroundColor: AppColors.background,
        selectedItemColor: AppColors.primary,
        unselectedItemColor: AppColors.textLight,
        type: BottomNavigationBarType.fixed,
        elevation: AppDimensions.elevationMd,
      ),

      // Tab Bar Theme
      tabBarTheme: const TabBarThemeData(
        labelColor: AppColors.primary,
        unselectedLabelColor: AppColors.textSecondary,
        indicatorColor: AppColors.primary,
        labelStyle: TextStyle(
          fontSize: AppDimensions.fontSizeMd,
          fontWeight: FontWeight.w600,
        ),
        unselectedLabelStyle: TextStyle(
          fontSize: AppDimensions.fontSizeMd,
          fontWeight: FontWeight.w400,
        ),
      ),

      // Dialog Theme
      dialogTheme: DialogThemeData(
        backgroundColor: AppColors.background,
        elevation: AppDimensions.elevationLg,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusLg),
        ),
        titleTextStyle: const TextStyle(
          color: AppColors.textPrimary,
          fontSize: AppDimensions.fontSizeXl,
          fontWeight: FontWeight.w600,
        ),
        contentTextStyle: const TextStyle(
          color: AppColors.textSecondary,
          fontSize: AppDimensions.fontSizeMd,
        ),
      ),

      // Snack Bar Theme
      snackBarTheme: SnackBarThemeData(
        backgroundColor: AppColors.textPrimary,
        contentTextStyle: const TextStyle(
          color: AppColors.textOnPrimary,
          fontSize: AppDimensions.fontSizeMd,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusSm),
        ),
        behavior: SnackBarBehavior.floating,
      ),
    );
  }
}

## lib\core\constants\app_strings.dart <a id="app_strings_dart"></a>

/// Classe que define todas as strings utilizadas no aplicativo
/// Centraliza textos para facilitar manuten√ß√£o e futura internacionaliza√ß√£o
class AppStrings {
  // App
  static const String appName = 'ConTask';
  static const String appDescription = 'Gerenciador de Tarefas para Eventos';

  // Autentica√ß√£o
  static const String login = 'Entrar';
  static const String loginWithGoogle = 'Entrar com Google';
  static const String register = 'Criar conta';
  static const String alreadyHaveAccount = 'J√° tenho conta';
  static const String dontHaveAccount = 'N√£o tenho conta';
  static const String logout = 'Sair';

  // Campos de Formul√°rio
  static const String name = 'Nome';
  static const String fullName = 'Nome completo';
  static const String email = 'E-mail';
  static const String password =  "[REDACTED]";
  static const String confirmPassword =  "[REDACTED]";
  static const String description = 'Descri√ß√£o';
  static const String location = 'Localiza√ß√£o';

  // Eventos
  static const String events = 'Eventos';
  static const String createEvent = 'Criar Evento';
  static const String joinEvent = 'Participar de Evento';
  static const String eventName = 'Nome do evento';
  static const String eventDescription = 'Descri√ß√£o do evento';
  static const String eventLocation = 'Localiza√ß√£o do evento';
  static const String eventCode = 'C√≥digo do evento';
  static const String eventTag = 'Tag do evento';
  static const String requiredSkills = 'Habilidades necess√°rias';
  static const String requiredResources = 'Recursos necess√°rios';
  static const String eventDetails = 'Detalhes do Evento';
  static const String eventCreated = 'Evento criado com sucesso!';
  static const String joinedEvent = 'Voc√™ ingressou no evento!';

  // Tarefas
  static const String tasks = 'Tarefas';
  static const String createTask = 'Criar Tarefa';
  static const String createTasks = 'Criar Tasks';
  static const String taskName = 'Nome da tarefa';
  static const String taskDescription = 'Descri√ß√£o da tarefa';
  static const String microtasks = 'Microtarefas';
  static const String createMicrotask = 'Criar Microtarefa';
  static const String microtaskName = 'Nome da microtarefa';
  static const String microtaskDescription = 'Descri√ß√£o da microtarefa';
  static const String startDateTime = 'Data e hora inicial';
  static const String endDateTime = 'Data e hora final';
  static const String estimatedHours =
      'Dura√ß√£o estimada'; // Mantido para compatibilidade
  static const String actualHours = 'Horas realizadas';
  static const String trackTasks = 'Acompanhar Tasks';

  // Volunt√°rios
  static const String volunteers = 'Volunt√°rios';
  static const String manageVolunteers = 'Gerenciar Volunt√°rios';
  static const String volunteerProfile = 'Perfil do Volunt√°rio';
  static const String assignMicrotask = 'Atribuir Microtarefa';
  static const String promoteToManager = 'Promover a Gerenciador';
  static const String availableDays = 'Dias dispon√≠veis';
  static const String availableHours = 'Hor√°rios dispon√≠veis';
  static const String skills = 'Habilidades';
  static const String resources = 'Recursos';
  static const String availability = 'Disponibilidade';

  // Status
  static const String pending = 'Pendente';
  static const String inProgress = 'Em Progresso';
  static const String completed = 'Conclu√≠do';
  static const String cancelled = 'Cancelado';
  static const String assigned = 'Atribu√≠do';
  static const String active = 'Ativo';

  // Prioridades
  static const String priority = 'Prioridade';
  static const String high = 'Alta';
  static const String medium = 'M√©dia';
  static const String low = 'Baixa';

  // A√ß√µes
  static const String save = 'Salvar';
  static const String cancel = 'Cancelar';
  static const String delete = 'Excluir';
  static const String edit = 'Editar';
  static const String confirm = 'Confirmar';
  static const String search = 'Buscar';
  static const String filter = 'Filtrar';
  static const String add = 'Adicionar';
  static const String remove = 'Remover';
  static const String start = 'Iniciar';
  static const String finish = 'Finalizar';
  static const String assign = 'Atribuir';

  // Navega√ß√£o
  static const String home = 'In√≠cio';
  static const String profile = 'Perfil';
  static const String settings = 'Configura√ß√µes';
  static const String back = 'Voltar';

  // Mensagens de Erro
  static const String errorGeneric = 'Ocorreu um erro inesperado';
  static const String errorNetwork = 'Erro de conex√£o com a internet';
  static const String errorAuth =  "[REDACTED]";
  static const String errorInvalidEmail = 'E-mail inv√°lido';
  static const String errorPasswordTooShort =
      'Senha deve ter pelo menos 6 caracteres';
  static const String errorPasswordsDontMatch = 'Senhas n√£o coincidem';
  static const String errorEventNotFound = 'Evento n√£o encontrado';
  static const String errorInvalidEventCode = 'C√≥digo de evento inv√°lido';

  // Mensagens de Sucesso
  static const String successGeneric = 'Opera√ß√£o realizada com sucesso';
  static const String successSaved = 'Salvo com sucesso';
  static const String successDeleted = 'Exclu√≠do com sucesso';

  // Dias da Semana
  static const String monday = 'Segunda-feira';
  static const String tuesday = 'Ter√ßa-feira';
  static const String wednesday = 'Quarta-feira';
  static const String thursday = 'Quinta-feira';
  static const String friday = 'Sexta-feira';
  static const String saturday = 'S√°bado';
  static const String sunday = 'Domingo';

  // Roles
  static const String manager = 'Gerenciador';
  static const String volunteer = 'Volunt√°rio';

  // Placeholders
  static const String noEventsFound = 'Nenhum evento encontrado';
  static const String noTasksFound = 'Nenhuma tarefa encontrada';
  static const String noVolunteersFound = 'Nenhum volunt√°rio encontrado';
  static const String loading = 'Carregando...';
}

## lib\presentation\widgets\dialogs\assignment_dialog.dart <a id="assignment_dialog_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/microtask_model.dart`
- `../../../data/models/user_model.dart`
- `../../../data/models/volunteer_profile_model.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/microtask_model.dart';
import '../../../data/models/user_model.dart';
import '../../../data/models/volunteer_profile_model.dart';

/// Dialog para atribui√ß√£o de volunt√°rios a microtasks
class AssignmentDialog extends StatefulWidget {
  final List<MicrotaskModel> availableMicrotasks;
  final UserModel volunteer;
  final VolunteerProfileModel? volunteerProfile;
  final Function(String microtaskId) onAssign;

  const AssignmentDialog({
    super.key,
    required this.availableMicrotasks,
    required this.volunteer,
    this.volunteerProfile,
    required this.onAssign,
  });

  @override
  State<AssignmentDialog> createState() => _AssignmentDialogState();
}

class _AssignmentDialogState extends State<AssignmentDialog> {
  String? _selectedMicrotaskId;
  List<MicrotaskModel> _filteredMicrotasks = [];
  bool _showOnlyCompatible = false;

  @override
  void initState() {
    super.initState();
    _filteredMicrotasks = widget.availableMicrotasks;
    _filterMicrotasks();
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        width: MediaQuery.of(context).size.width * 0.9,
        constraints: BoxConstraints(
          maxHeight: MediaQuery.of(context).size.height * 0.8,
        ),
        padding: const EdgeInsets.all(AppDimensions.paddingLg),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            Row(
              children: [
                const Icon(
                  Icons.assignment,
                  color: AppColors.primary,
                  size: 24,
                ),
                const SizedBox(width: AppDimensions.spacingSm),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Atribuir Microtask',
                        style: TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                          color: AppColors.textPrimary,
                        ),
                      ),
                      Text(
                        'Para: ${widget.volunteer.name}',
                        style: const TextStyle(
                          fontSize: 14,
                          color: AppColors.textSecondary,
                        ),
                      ),
                    ],
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.of(context).pop(),
                  icon: const Icon(Icons.close),
                  color: AppColors.textSecondary,
                ),
              ],
            ),

            const SizedBox(height: AppDimensions.spacingLg),

            // Filtro de compatibilidade
            if (widget.volunteerProfile != null) _buildCompatibilityFilter(),

            const SizedBox(height: AppDimensions.spacingMd),

            // Lista de microtasks
            Expanded(
              child: _filteredMicrotasks.isEmpty
                  ? _buildEmptyState()
                  : _buildMicrotasksList(),
            ),

            const SizedBox(height: AppDimensions.spacingLg),

            // Bot√µes de a√ß√£o
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Cancelar'),
                  ),
                ),
                const SizedBox(width: AppDimensions.spacingMd),
                Expanded(
                  child: ElevatedButton(
                    onPressed: _selectedMicrotaskId != null
                        ? () {
                            widget.onAssign(_selectedMicrotaskId!);
                            Navigator.of(context).pop();
                          }
                        : null,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppColors.primary,
                      foregroundColor: AppColors.textOnPrimary,
                    ),
                    child: const Text('Atribuir'),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildCompatibilityFilter() {
    return Container(
      padding: const EdgeInsets.all(AppDimensions.paddingMd),
      decoration: BoxDecoration(
        color: AppColors.primary.withOpacity(0.05),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: AppColors.primary.withOpacity(0.2)),
      ),
      child: Row(
        children: [
          Icon(Icons.filter_list, size: 20, color: AppColors.primary),
          const SizedBox(width: AppDimensions.spacingSm),
          Expanded(
            child: Text(
              'Mostrar apenas microtasks compat√≠veis',
              style: const TextStyle(
                fontSize: 14,
                color: AppColors.textPrimary,
              ),
            ),
          ),
          Switch(
            value: _showOnlyCompatible,
            onChanged: (value) {
              setState(() {
                _showOnlyCompatible = value;
                _filterMicrotasks();
              });
            },
            activeColor: AppColors.primary,
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.assignment_outlined,
            size: 64,
            color: AppColors.textSecondary.withOpacity(0.5),
          ),
          const SizedBox(height: AppDimensions.spacingMd),
          Text(
            _showOnlyCompatible
                ? 'Nenhuma microtask compat√≠vel encontrada'
                : 'Nenhuma microtask dispon√≠vel',
            style: TextStyle(fontSize: 16, color: AppColors.textSecondary),
            textAlign: TextAlign.center,
          ),
          if (_showOnlyCompatible) ...[
            const SizedBox(height: AppDimensions.spacingSm),
            Text(
              'Tente desabilitar o filtro de compatibilidade',
              style: TextStyle(
                fontSize: 14,
                color: AppColors.textSecondary.withOpacity(0.7),
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildMicrotasksList() {
    return ListView.builder(
      itemCount: _filteredMicrotasks.length,
      itemBuilder: (context, index) {
        final microtask = _filteredMicrotasks[index];
        final isSelected = _selectedMicrotaskId == microtask.id;
        final isCompatible = _isCompatible(microtask);

        return Card(
          elevation: isSelected ? 4 : 1,
          margin: const EdgeInsets.only(bottom: AppDimensions.spacingSm),
          child: InkWell(
            onTap: () {
              setState(() {
                _selectedMicrotaskId = isSelected ? null : microtask.id;
              });
            },
            borderRadius: BorderRadius.circular(8),
            child: Container(
              padding: const EdgeInsets.all(AppDimensions.paddingMd),
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(8),
                border: isSelected
                    ? Border.all(color: AppColors.primary, width: 2)
                    : null,
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Header
                  Row(
                    children: [
                      // Indicador de compatibilidade
                      Container(
                        width: 12,
                        height: 12,
                        decoration: BoxDecoration(
                          color: isCompatible
                              ? AppColors.success
                              : AppColors.warning,
                          shape: BoxShape.circle,
                        ),
                      ),
                      const SizedBox(width: AppDimensions.spacingSm),

                      // T√≠tulo
                      Expanded(
                        child: Text(
                          microtask.title,
                          style: const TextStyle(
                            fontSize: 14,
                            fontWeight: FontWeight.w600,
                            color: AppColors.textPrimary,
                          ),
                        ),
                      ),

                      // Badge de prioridade
                      _buildPriorityBadge(microtask.priority as int),
                    ],
                  ),

                  const SizedBox(height: AppDimensions.spacingSm),

                  // Descri√ß√£o
                  if (microtask.description.isNotEmpty)
                    Text(
                      microtask.description,
                      style: const TextStyle(
                        fontSize: 12,
                        color: AppColors.textSecondary,
                        height: 1.3,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),

                  const SizedBox(height: AppDimensions.spacingSm),

                  // Informa√ß√µes
                  Row(
                    children: [
                      _buildInfoChip(
                        icon: Icons.schedule,
                        label: microtask.hasSchedule
                            ? '${microtask.estimatedHours.toStringAsFixed(1)}h'
                            : 'N√£o definido',
                        color: AppColors.secondary,
                      ),
                      const SizedBox(width: AppDimensions.spacingSm),
                      _buildInfoChip(
                        icon: Icons.people,
                        label:
                            '0/${microtask.maxVolunteers}', // TODO: Buscar volunt√°rios atribu√≠dos
                        color: AppColors.primary,
                      ),
                    ],
                  ),

                  // Habilidades e recursos necess√°rios
                  if (microtask.requiredSkills.isNotEmpty ||
                      microtask.requiredResources.isNotEmpty) ...[
                    const SizedBox(height: AppDimensions.spacingSm),
                    _buildRequirementsInfo(microtask, isCompatible),
                  ],
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildPriorityBadge(int priority) {
    Color color;
    String text;

    switch (priority) {
      case 3: // high
        color = AppColors.error;
        text = 'Alta';
        break;
      case 2: // medium
        color = AppColors.warning;
        text = 'M√©dia';
        break;
      case 1: // low
        color = AppColors.success;
        text = 'Baixa';
        break;
      default:
        color = AppColors.warning;
        text = 'M√©dia';
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontSize: 9,
          fontWeight: FontWeight.w600,
          color: color,
        ),
      ),
    );
  }

  Widget _buildInfoChip({
    required IconData icon,
    required String label,
    required Color color,
  }) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 12, color: color),
          const SizedBox(width: 2),
          Text(
            label,
            style: TextStyle(
              fontSize: 10,
              fontWeight: FontWeight.w500,
              color: color,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildRequirementsInfo(MicrotaskModel microtask, bool isCompatible) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (microtask.requiredSkills.isNotEmpty) ...[
          Text(
            'Habilidades: ${microtask.requiredSkills.join(', ')}',
            style: TextStyle(
              fontSize: 10,
              color: isCompatible ? AppColors.success : AppColors.warning,
            ),
          ),
        ],
        if (microtask.requiredResources.isNotEmpty) ...[
          Text(
            'Recursos: ${microtask.requiredResources.join(', ')}',
            style: TextStyle(
              fontSize: 10,
              color: isCompatible ? AppColors.success : AppColors.warning,
            ),
          ),
        ],
      ],
    );
  }

  void _filterMicrotasks() {
    if (_showOnlyCompatible && widget.volunteerProfile != null) {
      _filteredMicrotasks = widget.availableMicrotasks
          .where((microtask) => _isCompatible(microtask))
          .toList();
    } else {
      _filteredMicrotasks = widget.availableMicrotasks;
    }
  }

  bool _isCompatible(MicrotaskModel microtask) {
    if (widget.volunteerProfile == null) return true;

    final volunteerSkills = widget.volunteerProfile!.skills;
    final volunteerResources = widget.volunteerProfile!.resources;

    // Verificar se o volunt√°rio tem todas as habilidades necess√°rias
    final hasRequiredSkills = microtask.requiredSkills.every(
      (skill) => volunteerSkills.contains(skill),
    );

    // Verificar se o volunt√°rio tem todos os recursos necess√°rios
    final hasRequiredResources = microtask.requiredResources.every(
      (resource) => volunteerResources.contains(resource),
    );

    return hasRequiredSkills && hasRequiredResources;
  }
}

## lib\presentation\screens\assignment\assignment_screen.dart <a id="assignment_screen_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `package:provider/provider.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../core/constants/app_strings.dart`
- `../../../data/models/user_model.dart`
- `../../../data/models/volunteer_profile_model.dart`
- `../../../data/models/microtask_model.dart`
- `../../../data/models/task_model.dart`
- `../../controllers/task_controller.dart`
- `../../widgets/common/loading_widget.dart`

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../core/constants/app_strings.dart';
import '../../../data/models/user_model.dart';
import '../../../data/models/volunteer_profile_model.dart';
import '../../../data/models/microtask_model.dart';
import '../../../data/models/task_model.dart';
import '../../controllers/task_controller.dart';
import '../../widgets/common/loading_widget.dart';

/// Tela dedicada para atribui√ß√£o de microtasks a volunt√°rios
class AssignmentScreen extends StatefulWidget {
  final String eventId;
  final UserModel volunteer;
  final VolunteerProfileModel? volunteerProfile;

  const AssignmentScreen({
    super.key,
    required this.eventId,
    required this.volunteer,
    this.volunteerProfile,
  });

  @override
  State<AssignmentScreen> createState() => _AssignmentScreenState();
}

class _AssignmentScreenState extends State<AssignmentScreen> {
  List<MicrotaskModel> _availableMicrotasks = [];
  List<TaskModel> _tasks = [];
  bool _isLoading = true;
  String _searchQuery = '';

  @override
  void initState() {
    super.initState();
    _loadMicrotasks();
  }

  Future<void> _loadMicrotasks() async {
    try {
      final taskController = Provider.of<TaskController>(
        context,
        listen: false,
      );

      // Carrega tasks do evento
      await taskController.loadTasksByEventId(widget.eventId);

      // Coleta todas as microtasks dispon√≠veis
      final availableMicrotasks = <MicrotaskModel>[];
      for (final task in taskController.tasks) {
        final microtasks = taskController.getMicrotasksByTaskId(task.id);
        availableMicrotasks.addAll(
          microtasks.where(
            (m) =>
                m.status != MicrotaskStatus.completed &&
                m.status != MicrotaskStatus.cancelled &&
                m.assignedTo.length < m.maxVolunteers &&
                !m.assignedTo.contains(widget.volunteer.id),
          ),
        );
      }

      if (mounted) {
        setState(() {
          _tasks = taskController.tasks;
          _availableMicrotasks = _sortMicrotasksByCompatibility(
            availableMicrotasks,
          );
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Erro ao carregar microtasks: $e'),
            backgroundColor: AppColors.error,
          ),
        );
      }
    }
  }

  // Ordena microtasks por compatibilidade com as habilidades do volunt√°rio
  List<MicrotaskModel> _sortMicrotasksByCompatibility(
    List<MicrotaskModel> microtasks,
  ) {
    if (widget.volunteerProfile == null) return microtasks;

    final volunteerSkills = widget.volunteerProfile!.skills;

    // Separa microtasks compat√≠veis e n√£o compat√≠veis
    final compatible = <MicrotaskModel>[];
    final notCompatible = <MicrotaskModel>[];

    for (final microtask in microtasks) {
      if (microtask.requiredSkills.isEmpty ||
          microtask.requiredSkills.any(
            (skill) => volunteerSkills.contains(skill),
          )) {
        compatible.add(microtask);
      } else {
        notCompatible.add(microtask);
      }
    }

    // Ordena compat√≠veis por n√∫mero de habilidades em comum (mais compat√≠veis primeiro)
    compatible.sort((a, b) {
      final aMatches = a.requiredSkills
          .where((skill) => volunteerSkills.contains(skill))
          .length;
      final bMatches = b.requiredSkills
          .where((skill) => volunteerSkills.contains(skill))
          .length;
      return bMatches.compareTo(aMatches);
    });

    return [...compatible, ...notCompatible];
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Atribuir Microtask'),
        backgroundColor: AppColors.primary,
        foregroundColor: Colors.white,
      ),
      body: Column(
        children: [
          _buildHeader(),
          _buildSearchBar(),
          Expanded(
            child: _isLoading
                ? const LoadingWidget(message: 'Carregando microtasks...')
                : _buildMicrotasksList(),
          ),
        ],
      ),
    );
  }

  Widget _buildHeader() {
    return Container(
      padding: const EdgeInsets.all(AppDimensions.paddingMd),
      decoration: const BoxDecoration(
        color: AppColors.background,
        border: Border(bottom: BorderSide(color: AppColors.border)),
      ),
      child: Row(
        children: [
          CircleAvatar(
            radius: 24,
            backgroundColor: AppColors.primary.withOpacity(0.1),
            backgroundImage: widget.volunteer.photoUrl != null
                ? NetworkImage(widget.volunteer.photoUrl!)
                : null,
            child: widget.volunteer.photoUrl == null
                ? Text(
                    widget.volunteer.name.isNotEmpty
                        ? widget.volunteer.name[0].toUpperCase()
                        : '?',
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      color: AppColors.primary,
                    ),
                  )
                : null,
          ),
          const SizedBox(width: AppDimensions.spacingMd),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  widget.volunteer.name,
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 2),
                Text(
                  'Selecione uma microtask para atribuir',
                  style: const TextStyle(
                    fontSize: 14,
                    color: AppColors.textSecondary,
                  ),
                ),
                if (widget.volunteerProfile != null &&
                    widget.volunteerProfile!.skills.isNotEmpty) ...[
                  const SizedBox(height: 4),
                  Text(
                    'Habilidades: ${widget.volunteerProfile!.skills.join(', ')}',
                    style: const TextStyle(
                      fontSize: 12,
                      color: AppColors.textSecondary,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSearchBar() {
    return Container(
      padding: const EdgeInsets.all(AppDimensions.paddingMd),
      child: TextField(
        onChanged: (value) {
          setState(() {
            _searchQuery = value;
          });
        },
        decoration: InputDecoration(
          hintText: 'Buscar microtasks...',
          prefixIcon: const Icon(Icons.search),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
          contentPadding: const EdgeInsets.symmetric(
            horizontal: AppDimensions.paddingMd,
            vertical: AppDimensions.paddingSm,
          ),
        ),
      ),
    );
  }

  Widget _buildMicrotasksList() {
    final filteredMicrotasks = _getFilteredMicrotasks();

    if (filteredMicrotasks.isEmpty) {
      return _buildEmptyState();
    }

    return ListView.builder(
      padding: const EdgeInsets.all(AppDimensions.paddingSm),
      itemCount: filteredMicrotasks.length,
      itemBuilder: (context, index) {
        final microtask = filteredMicrotasks[index];
        final task = _getTaskForMicrotask(microtask.taskId);
        return _buildMicrotaskAssignmentCard(microtask, task);
      },
    );
  }

  List<MicrotaskModel> _getFilteredMicrotasks() {
    if (_searchQuery.isEmpty) return _availableMicrotasks;

    return _availableMicrotasks.where((microtask) {
      final query = _searchQuery.toLowerCase();
      final task = _getTaskForMicrotask(microtask.taskId);

      return microtask.title.toLowerCase().contains(query) ||
          microtask.description.toLowerCase().contains(query) ||
          (task?.title.toLowerCase().contains(query) ?? false) ||
          microtask.requiredSkills.any(
            (skill) => skill.toLowerCase().contains(query),
          );
    }).toList();
  }

  TaskModel? _getTaskForMicrotask(String taskId) {
    try {
      return _tasks.firstWhere((task) => task.id == taskId);
    } catch (e) {
      return null;
    }
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.assignment_outlined,
            size: 64,
            color: AppColors.textSecondary.withOpacity(0.5),
          ),
          const SizedBox(height: AppDimensions.spacingLg),
          const Text(
            'Nenhuma microtask dispon√≠vel',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.w500,
              color: AppColors.textSecondary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingSm),
          const Text(
            'N√£o h√° microtasks dispon√≠veis para atribui√ß√£o no momento.',
            style: TextStyle(fontSize: 14, color: AppColors.textSecondary),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildMicrotaskAssignmentCard(
    MicrotaskModel microtask,
    TaskModel? task,
  ) {
    final isCompatible = _isVolunteerCompatible(microtask);
    final availableSlots =
        microtask.maxVolunteers - microtask.assignedTo.length;

    return Card(
      margin: const EdgeInsets.only(bottom: AppDimensions.spacingMd),
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(AppDimensions.paddingMd),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header com t√≠tulo e task pai
            Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        microtask.title,
                        style: const TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      if (task != null) ...[
                        const SizedBox(height: 2),
                        Text(
                          'Task: ${task.title}',
                          style: const TextStyle(
                            fontSize: 12,
                            color: AppColors.textSecondary,
                          ),
                        ),
                      ],
                    ],
                  ),
                ),
                if (isCompatible)
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: AppColors.success.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(12),
                      border: Border.all(
                        color: AppColors.success.withOpacity(0.3),
                      ),
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(Icons.star, size: 12, color: AppColors.success),
                        const SizedBox(width: 2),
                        Text(
                          'Compat√≠vel',
                          style: TextStyle(
                            fontSize: 10,
                            color: AppColors.success,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ],
                    ),
                  ),
              ],
            ),

            const SizedBox(height: AppDimensions.spacingMd),

            // Descri√ß√£o
            Text(
              microtask.description,
              style: const TextStyle(
                fontSize: 14,
                color: AppColors.textSecondary,
              ),
              maxLines: 3,
              overflow: TextOverflow.ellipsis,
            ),

            const SizedBox(height: AppDimensions.spacingMd),

            // Informa√ß√µes da microtask
            Wrap(
              spacing: AppDimensions.spacingSm,
              runSpacing: AppDimensions.spacingSm,
              children: [
                _buildInfoChip(
                  icon: Icons.schedule,
                  label: microtask.hasSchedule
                      ? microtask.periodFormatted
                      : 'Hor√°rio flex√≠vel',
                  color: AppColors.secondary,
                ),
                _buildInfoChip(
                  icon: Icons.people,
                  label: 'Vagas: $availableSlots de ${microtask.maxVolunteers}',
                  color: _getVacancyColor(
                    availableSlots,
                    microtask.maxVolunteers,
                  ),
                ),
                if (microtask.status != MicrotaskStatus.pending)
                  _buildInfoChip(
                    icon: Icons.info_outline,
                    label: _getStatusText(microtask.status),
                    color: _getStatusColor(microtask.status),
                  ),
              ],
            ),

            // Habilidades necess√°rias
            if (microtask.requiredSkills.isNotEmpty) ...[
              const SizedBox(height: AppDimensions.spacingMd),
              _buildSkillsSection(microtask),
            ],

            const SizedBox(height: AppDimensions.spacingMd),

            // Bot√£o de atribui√ß√£o
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: availableSlots > 0
                    ? () => _assignMicrotask(microtask)
                    : null,
                style: ElevatedButton.styleFrom(
                  backgroundColor: isCompatible
                      ? AppColors.success
                      : AppColors.primary,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 12),
                ),
                child: Text(
                  availableSlots > 0
                      ? (isCompatible ? 'Atribuir (Compat√≠vel)' : 'Atribuir')
                      : 'Sem vagas dispon√≠veis',
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // Verifica se o volunt√°rio √© compat√≠vel com a microtask
  bool _isVolunteerCompatible(MicrotaskModel microtask) {
    if (widget.volunteerProfile == null || microtask.requiredSkills.isEmpty) {
      return false;
    }

    final volunteerSkills = widget.volunteerProfile!.skills;
    return microtask.requiredSkills.any(
      (skill) => volunteerSkills.contains(skill),
    );
  }

  // Widget de chip informativo
  Widget _buildInfoChip({
    required IconData icon,
    required String label,
    required Color color,
  }) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 12, color: color),
          const SizedBox(width: 4),
          Text(
            label,
            style: TextStyle(
              fontSize: 10,
              color: color,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }

  // Cor baseada no n√∫mero de vagas dispon√≠veis
  Color _getVacancyColor(int available, int total) {
    final ratio = available / total;
    if (ratio > 0.5) return AppColors.success;
    if (ratio > 0.2) return AppColors.warning;
    return AppColors.error;
  }

  // Texto do status da microtask
  String _getStatusText(MicrotaskStatus status) {
    switch (status) {
      case MicrotaskStatus.pending:
        return 'Pendente';
      case MicrotaskStatus.assigned:
        return 'Atribu√≠da';
      case MicrotaskStatus.inProgress:
        return 'Em andamento';
      case MicrotaskStatus.completed:
        return 'Conclu√≠da';
      case MicrotaskStatus.cancelled:
        return 'Cancelada';
    }
  }

  // Cor do status da microtask
  Color _getStatusColor(MicrotaskStatus status) {
    switch (status) {
      case MicrotaskStatus.pending:
        return AppColors.textSecondary;
      case MicrotaskStatus.assigned:
        return AppColors.primary;
      case MicrotaskStatus.inProgress:
        return AppColors.warning;
      case MicrotaskStatus.completed:
        return AppColors.success;
      case MicrotaskStatus.cancelled:
        return AppColors.error;
    }
  }

  // Se√ß√£o de habilidades necess√°rias
  Widget _buildSkillsSection(MicrotaskModel microtask) {
    final volunteerSkills = widget.volunteerProfile?.skills ?? [];

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Habilidades necess√°rias:',
          style: TextStyle(
            fontSize: 12,
            fontWeight: FontWeight.w500,
            color: AppColors.textSecondary,
          ),
        ),
        const SizedBox(height: 4),
        Wrap(
          spacing: 4,
          runSpacing: 4,
          children: microtask.requiredSkills.map((skill) {
            final hasSkill = volunteerSkills.contains(skill);
            return Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(
                color: hasSkill
                    ? AppColors.success.withOpacity(0.1)
                    : AppColors.textSecondary.withOpacity(0.1),
                borderRadius: BorderRadius.circular(8),
                border: Border.all(
                  color: hasSkill
                      ? AppColors.success.withOpacity(0.3)
                      : AppColors.textSecondary.withOpacity(0.3),
                ),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  if (hasSkill)
                    Icon(
                      Icons.check_circle,
                      size: 10,
                      color: AppColors.success,
                    ),
                  if (hasSkill) const SizedBox(width: 2),
                  Text(
                    skill,
                    style: TextStyle(
                      fontSize: 10,
                      color: hasSkill
                          ? AppColors.success
                          : AppColors.textSecondary,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  // Atribui a microtask ao volunt√°rio
  Future<void> _assignMicrotask(MicrotaskModel microtask) async {
    try {
      final taskController = Provider.of<TaskController>(
        context,
        listen: false,
      );

      // Atribui a microtask
      await taskController.assignVolunteerToMicrotask(
        microtaskId: microtask.id,
        userId: widget.volunteer.id,
        eventId: widget.eventId,
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Microtask "${microtask.title}" atribu√≠da com sucesso!',
            ),
            backgroundColor: AppColors.success,
          ),
        );

        // Volta para a tela anterior
        Navigator.of(context).pop(true);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Erro ao atribuir microtask: $e'),
            backgroundColor: AppColors.error,
          ),
        );
      }
    }
  }
}

## lib\data\services\assignment_service.dart <a id="assignment_service_dart"></a>

### Dependencies

- `package:cloud_firestore/cloud_firestore.dart`
- `../models/microtask_model.dart`
- `../models/user_microtask_model.dart`
- `../models/volunteer_profile_model.dart`
- `../services/microtask_service.dart`
- `../services/event_service.dart`
- `../../core/exceptions/app_exceptions.dart`

import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/microtask_model.dart';
import '../models/user_microtask_model.dart';
import '../models/volunteer_profile_model.dart';
import '../services/microtask_service.dart';
import '../services/event_service.dart';
import '../../core/exceptions/app_exceptions.dart';

/// Servi√ßo respons√°vel pelo sistema de atribui√ß√£o m√∫ltipla de volunt√°rios
///
/// ARCHITECTURAL NOTE: This service currently violates clean architecture
/// by depending on other services (MicrotaskService, EventService).
/// In proper clean architecture, this coordination should be done in repositories.
///
/// TODO: Refactor to move business logic to repositories and make this service
/// handle only direct database operations for assignment-related data.
class AssignmentService {
  final MicrotaskService _microtaskService;
  final EventService _eventService;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  AssignmentService({
    MicrotaskService? microtaskService,
    EventService? eventService,
  }) : _microtaskService = microtaskService ?? MicrotaskService(),
       _eventService = eventService ?? EventService();

  // Refer√™ncia da cole√ß√£o
  CollectionReference get _userMicrotasksCollection =>
      _firestore.collection('user_microtasks');

  /// Atribui um volunt√°rio a uma microtask com valida√ß√µes completas
  Future<MicrotaskModel> assignVolunteerToMicrotask({
    required String microtaskId,
    required String userId,
    required String eventId,
  }) async {
    try {
      // Busca a microtask
      final microtask = await _microtaskService.getMicrotaskById(microtaskId);
      if (microtask == null) {
        throw ValidationException('Microtask n√£o encontrada');
      }

      // Busca o perfil do volunt√°rio no evento
      final volunteerProfile = await _eventService.getVolunteerProfile(
        userId,
        eventId,
      );
      if (volunteerProfile == null) {
        throw ValidationException('Perfil de volunt√°rio n√£o encontrado');
      }

      // Valida√ß√µes de atribui√ß√£o
      await _validateAssignment(microtask, userId, volunteerProfile);
      print("ABACAXI5: assinando microtask");

      // Atribui o volunt√°rio
      final updatedMicrotask = await _microtaskService.assignVolunteer(
        microtaskId,
        userId,
      );

      // Incrementa o contador de microtasks atribu√≠das para o volunt√°rio
      await _eventService.incrementVolunteerMicrotaskCount(eventId, userId);

      return updatedMicrotask;
    } catch (e) {
      if (e is ValidationException || e is DatabaseException) rethrow;
      throw DatabaseException('Erro ao atribuir volunt√°rio: ${e.toString()}');
    }
  }

  /// Remove um volunt√°rio de uma microtask
  Future<MicrotaskModel> unassignVolunteerFromMicrotask({
    required String microtaskId,
    required String userId,
  }) async {
    try {
      // Busca a microtask para obter o eventId
      final microtask = await _microtaskService.getMicrotaskById(microtaskId);
      if (microtask == null) {
        throw ValidationException('Microtask n√£o encontrada');
      }

      // Remove o volunt√°rio
      final updatedMicrotask = await _microtaskService.unassignVolunteer(
        microtaskId,
        userId,
      );

      // Decrementa o contador de microtasks atribu√≠das para o volunt√°rio
      await _eventService.decrementVolunteerMicrotaskCount(
        microtask.eventId,
        userId,
      );

      return updatedMicrotask;
    } catch (e) {
      if (e is ValidationException || e is DatabaseException) rethrow;
      throw DatabaseException('Erro ao remover volunt√°rio: ${e.toString()}');
    }
  }

  /// Busca volunt√°rios compat√≠veis com uma microtask
  Future<List<VolunteerProfileModel>> getCompatibleVolunteers({
    required String eventId,
    required String microtaskId,
  }) async {
    try {
      // Busca a microtask
      final microtask = await _microtaskService.getMicrotaskById(microtaskId);
      if (microtask == null) {
        throw ValidationException('Microtask n√£o encontrada');
      }

      // Busca todos os volunt√°rios do evento
      final allVolunteers = await _eventService.getEventVolunteerProfiles(
        eventId,
      );

      // Filtra volunt√°rios compat√≠veis
      final compatibleVolunteers = <VolunteerProfileModel>[];

      for (final volunteer in allVolunteers) {
        // Verifica se j√° est√° atribu√≠do
        if (microtask.isAssignedTo(volunteer.userId)) {
          continue;
        }

        // Verifica compatibilidade de habilidades
        if (!microtask.isCompatibleWith(volunteer.skills)) {
          continue;
        }

        // TODO: Adicionar verifica√ß√£o de disponibilidade de hor√°rios
        // TODO: Adicionar verifica√ß√£o de recursos dispon√≠veis

        compatibleVolunteers.add(volunteer);
      }

      // Ordena por score de compatibilidade
      compatibleVolunteers.sort((a, b) {
        final scoreA = microtask.getCompatibilityScore(a.skills);
        final scoreB = microtask.getCompatibilityScore(b.skills);
        return scoreB.compareTo(scoreA);
      });

      return compatibleVolunteers;
    } catch (e) {
      if (e is ValidationException || e is DatabaseException) rethrow;
      throw DatabaseException(
        'Erro ao buscar volunt√°rios compat√≠veis: ${e.toString()}',
      );
    }
  }

  /// Busca microtasks dispon√≠veis para um volunt√°rio
  Future<List<MicrotaskModel>> getAvailableMicrotasksForVolunteer({
    required String eventId,
    required String userId,
  }) async {
    try {
      // Busca o perfil do volunt√°rio
      final volunteerProfile = await _eventService.getVolunteerProfile(
        eventId,
        userId,
      );
      if (volunteerProfile == null) {
        throw ValidationException('Perfil de volunt√°rio n√£o encontrado');
      }

      // Busca todas as microtasks do evento
      final allMicrotasks = await _microtaskService.getMicrotasksByEventId(
        eventId,
      );

      // Filtra microtasks dispon√≠veis
      final availableMicrotasks = <MicrotaskModel>[];

      for (final microtask in allMicrotasks) {
        // Verifica se j√° est√° atribu√≠do
        if (microtask.isAssignedTo(userId)) {
          continue;
        }

        // Verifica se h√° vagas dispon√≠veis
        if (!microtask.hasAvailableSlots) {
          continue;
        }

        // Verifica se n√£o est√° cancelada
        if (microtask.isCancelled) {
          continue;
        }

        // Verifica compatibilidade de habilidades
        if (!microtask.isCompatibleWith(volunteerProfile.skills)) {
          continue;
        }

        availableMicrotasks.add(microtask);
      }

      // Ordena por prioridade e compatibilidade
      availableMicrotasks.sort((a, b) {
        // Primeiro por prioridade
        final priorityOrder = {'high': 3, 'medium': 2, 'low': 1};
        final priorityA = priorityOrder[a.priority] ?? 2;
        final priorityB = priorityOrder[b.priority] ?? 2;

        if (priorityA != priorityB) {
          return priorityB.compareTo(priorityA);
        }

        // Depois por score de compatibilidade
        final scoreA = a.getCompatibilityScore(volunteerProfile.skills);
        final scoreB = b.getCompatibilityScore(volunteerProfile.skills);
        return scoreB.compareTo(scoreA);
      });

      return availableMicrotasks;
    } catch (e) {
      if (e is ValidationException || e is DatabaseException) rethrow;
      throw DatabaseException(
        'Erro ao buscar microtasks dispon√≠veis: ${e.toString()}',
      );
    }
  }

  /// Busca o status individual de um usu√°rio em uma microtask
  Future<UserMicrotaskModel?> getUserMicrotaskStatus({
    required String userId,
    required String microtaskId,
  }) async {
    try {
      final querySnapshot = await _userMicrotasksCollection
          .where('userId', isEqualTo: userId)
          .where('microtaskId', isEqualTo: microtaskId)
          .limit(1)
          .get();

      if (querySnapshot.docs.isEmpty) {
        return null;
      }

      return UserMicrotaskModel.fromFirestore(querySnapshot.docs.first);
    } catch (e) {
      throw DatabaseException(
        'Erro ao buscar status do usu√°rio na microtask: ${e.toString()}',
      );
    }
  }

  /// Atualiza o status individual de um usu√°rio em uma microtask
  Future<UserMicrotaskModel> updateUserMicrotaskStatus({
    required String userId,
    required String microtaskId,
    required UserMicrotaskStatus status,
    double? actualHours,
    String? notes,
  }) async {
    try {
      final userMicrotask = await getUserMicrotaskStatus(
        userId: userId,
        microtaskId: microtaskId,
      );

      if (userMicrotask == null) {
        throw ValidationException('Rela√ß√£o usu√°rio-microtask n√£o encontrada');
      }

      UserMicrotaskModel updatedUserMicrotask;
      switch (status) {
        case UserMicrotaskStatus.started:
          updatedUserMicrotask = userMicrotask.markAsStarted();
          break;
        case UserMicrotaskStatus.completed:
          updatedUserMicrotask = userMicrotask.markAsCompleted(
            actualHours: actualHours,
          );
          break;
        case UserMicrotaskStatus.cancelled:
          updatedUserMicrotask = userMicrotask.markAsCancelled();
          break;
        default:
          updatedUserMicrotask = userMicrotask.copyWith(
            status: status,
            updatedAt: DateTime.now(),
          );
      }

      if (notes != null) {
        updatedUserMicrotask = updatedUserMicrotask.updateNotes(notes);
      }

      // Salva no Firestore
      await _userMicrotasksCollection
          .doc(userMicrotask.id)
          .update(updatedUserMicrotask.toFirestore());

      // Verifica se precisa atualizar o status da microtask
      await _checkAndUpdateMicrotaskStatus(microtaskId);

      return updatedUserMicrotask;
    } catch (e) {
      if (e is ValidationException || e is DatabaseException) rethrow;
      throw DatabaseException(
        'Erro ao atualizar status do usu√°rio: ${e.toString()}',
      );
    }
  }

  /// Busca todas as rela√ß√µes usu√°rio-microtask de uma microtask
  Future<List<UserMicrotaskModel>> getUserMicrotasksByMicrotaskId(
    String microtaskId,
  ) async {
    try {
      final querySnapshot = await _userMicrotasksCollection
          .where('microtaskId', isEqualTo: microtaskId)
          .get();

      return querySnapshot.docs
          .map((doc) => UserMicrotaskModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      throw DatabaseException(
        'Erro ao buscar rela√ß√µes usu√°rio-microtask: ${e.toString()}',
      );
    }
  }

  /// Busca todas as microtasks de um usu√°rio com seus status
  Future<List<UserMicrotaskModel>> getUserMicrotasksByUserId(
    String userId,
  ) async {
    try {
      final querySnapshot = await _userMicrotasksCollection
          .where('userId', isEqualTo: userId)
          .orderBy('assignedAt', descending: true)
          .get();

      return querySnapshot.docs
          .map((doc) => UserMicrotaskModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      throw DatabaseException(
        'Erro ao buscar microtasks do usu√°rio: ${e.toString()}',
      );
    }
  }

  /// Valida se um volunt√°rio pode ser atribu√≠do a uma microtask
  Future<void> _validateAssignment(
    MicrotaskModel microtask,
    String userId,
    VolunteerProfileModel volunteerProfile,
  ) async {
    // Verifica se j√° est√° atribu√≠do
    if (microtask.isAssignedTo(userId)) {
      throw ValidationException(
        'Volunt√°rio j√° est√° atribu√≠do a esta microtask',
      );
    }

    // Verifica se h√° vagas dispon√≠veis
    if (!microtask.hasAvailableSlots) {
      throw ValidationException('N√£o h√° vagas dispon√≠veis nesta microtask');
    }

    // Verifica se a microtask n√£o est√° cancelada
    if (microtask.isCancelled) {
      throw ValidationException(
        'N√£o √© poss√≠vel atribuir volunt√°rio a microtask cancelada',
      );
    }

    // Verifica compatibilidade de habilidades
    if (!microtask.isCompatibleWith(volunteerProfile.skills)) {
      throw ValidationException(
        'Volunt√°rio n√£o possui as habilidades necess√°rias',
      );
    }

    // TODO: Adicionar valida√ß√£o de disponibilidade de hor√°rios
    // TODO: Adicionar valida√ß√£o de recursos dispon√≠veis
  }

  /// Verifica e atualiza o status da microtask baseado nos status individuais
  Future<void> _checkAndUpdateMicrotaskStatus(String microtaskId) async {
    try {
      final microtask = await _microtaskService.getMicrotaskById(microtaskId);
      if (microtask == null) return;

      final userMicrotasks = await getUserMicrotasksByMicrotaskId(microtaskId);

      if (userMicrotasks.isEmpty) {
        // Sem volunt√°rios atribu√≠dos
        if (microtask.status != MicrotaskStatus.pending) {
          await _microtaskService.updateMicrotaskStatus(
            microtaskId,
            MicrotaskStatus.pending,
          );
        }
        return;
      }

      // Verifica se todos completaram
      final allCompleted = userMicrotasks.every((um) => um.isCompleted);
      if (allCompleted && microtask.status != MicrotaskStatus.completed) {
        await _microtaskService.updateMicrotaskStatus(
          microtaskId,
          MicrotaskStatus.completed,
        );
        return;
      }

      // Verifica se algum iniciou
      final anyStarted = userMicrotasks.any(
        (um) => um.isStarted || um.isCompleted,
      );
      if (anyStarted && microtask.status == MicrotaskStatus.assigned) {
        await _microtaskService.updateMicrotaskStatus(
          microtaskId,
          MicrotaskStatus.inProgress,
        );
        return;
      }
    } catch (e) {
      // Log do erro, mas n√£o propaga para n√£o quebrar o fluxo principal
      print('Erro ao atualizar status da microtask: $e');
    }
  }
}

## lib\data\repositories\auth_repository.dart <a id="auth_repository_dart"></a>

### Dependencies

- `package:cloud_firestore/cloud_firestore.dart`
- `package:firebase_auth/firebase_auth.dart`
- `../../core/constants/app_constants.dart`
- `../../core/exceptions/app_exceptions.dart`
- `../models/user_model.dart`
- `../services/auth_service.dart`

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../core/constants/app_constants.dart';
import '../../core/exceptions/app_exceptions.dart';
import '../models/user_model.dart';
import '../services/auth_service.dart';

/// Reposit√≥rio respons√°vel por gerenciar dados de autentica√ß√£o
/// Combina Firebase Auth com Firestore para persistir dados do usu√°rio
class AuthRepository {
  final AuthService _authService = AuthService();
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// Refer√™ncia para a cole√ß√£o de usu√°rios no Firestore
  CollectionReference get _usersCollection =>
      _firestore.collection(AppConstants.usersCollection);

  /// Stream que monitora mudan√ßas no estado de autentica√ß√£o
  Stream<UserModel?> get authStateChanges {
    return _authService.authStateChanges.asyncMap((firebaseUser) async {
      if (firebaseUser == null) return null;

      try {
        // Busca os dados completos do usu√°rio no Firestore
        final userDoc = await _usersCollection.doc(firebaseUser.uid).get();

        if (userDoc.exists) {
          return UserModel.fromFirestore(userDoc);
        } else {
          // Se n√£o existe no Firestore, cria um novo registro
          final userModel = UserModel.fromGoogleSignIn(
            uid: firebaseUser.uid,
            name: firebaseUser.displayName ?? '',
            email: firebaseUser.email ?? '',
            photoUrl: firebaseUser.photoURL,
          );

          await _saveUserToFirestore(userModel);
          return userModel;
        }
      } catch (e) {
        // Em caso de erro, retorna dados b√°sicos do Firebase Auth
        return _authService.firebaseUserToUserModel(firebaseUser);
      }
    });
  }

  /// Retorna o usu√°rio atual
  Future<UserModel?> getCurrentUser() async {
    try {
      final firebaseUser = _authService.currentUser;
      if (firebaseUser == null) return null;

      final userDoc = await _usersCollection.doc(firebaseUser.uid).get();

      if (userDoc.exists) {
        return UserModel.fromFirestore(userDoc);
      }

      return null;
    } catch (e) {
      throw FirestoreException('Erro ao buscar usu√°rio atual', originalException: e);
    }
  }

  /// Faz login com email e senha
  Future<UserModel> signInWithEmailAndPassword({
    required String email,
    required String password,
  }) async {
    try {
      final credential = await _authService.signInWithEmailAndPassword(
        email: email,
        password: password,
      );

      final firebaseUser = credential.user;
      if (firebaseUser == null) {
        throw const AuthException('Erro ao obter dados do usu√°rio ap√≥s login');
      }

      // Busca ou cria o usu√°rio no Firestore
      return await _getOrCreateUser(firebaseUser);
    } catch (e) {
      if (e is AuthException) rethrow;
      throw AuthException('Erro durante login', originalException: e);
    }
  }

  /// Cria uma nova conta com email e senha
  Future<UserModel> createUserWithEmailAndPassword({
    required String name,
    required String email,
    required String password,
  }) async {
    try {
      final credential = await _authService.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );

      final firebaseUser = credential.user;
      if (firebaseUser == null) {
        throw const AuthException('Erro ao obter dados do usu√°rio ap√≥s cadastro');
      }

      // Atualiza o nome no Firebase Auth
      await _authService.updateProfile(displayName: name);

      // Cria o modelo do usu√°rio
      final userModel = UserModel.fromRegistration(
        uid: firebaseUser.uid,
        name: name,
        email: email,
      );

      // Salva no Firestore
      await _saveUserToFirestore(userModel);

      return userModel;
    } catch (e) {
      if (e is AuthException) rethrow;
      throw AuthException('Erro durante cadastro', originalException: e);
    }
  }

  /// Faz login com Google
  Future<UserModel> signInWithGoogle() async {
    try {
      final credential = await _authService.signInWithGoogle();

      final firebaseUser = credential.user;
      if (firebaseUser == null) {
        throw const AuthException('Erro ao obter dados do usu√°rio ap√≥s login com Google');
      }

      // Busca ou cria o usu√°rio no Firestore
      return await _getOrCreateUser(firebaseUser);
    } catch (e) {
      if (e is AuthException) rethrow;
      throw AuthException('Erro durante login com Google', originalException: e);
    }
  }

  /// Faz logout
  Future<void> signOut() async {
    try {
      await _authService.signOut();
    } catch (e) {
      throw AuthException('Erro durante logout', originalException: e);
    }
  }

  /// Envia email de redefini√ß√£o de senha
  Future<void> sendPasswordResetEmail(String email) async {
    try {
      await _authService.sendPasswordResetEmail(email);
    } catch (e) {
      if (e is AuthException) rethrow;
      throw AuthException('Erro ao enviar email de redefini√ß√£o', originalException: e);
    }
  }

  /// Atualiza os dados do usu√°rio
  Future<UserModel> updateUser(UserModel user) async {
    try {
      final updatedUser = user.withUpdatedTimestamp();

      // Atualiza no Firestore
      await _usersCollection.doc(user.id).update(updatedUser.toFirestore());

      // Atualiza no Firebase Auth se necess√°rio
      final currentFirebaseUser = _authService.currentUser;
      if (currentFirebaseUser != null) {
        if (currentFirebaseUser.displayName != user.name) {
          await _authService.updateProfile(
            displayName: user.name,
            photoURL: user.photoUrl,
          );
        }
      }

      return updatedUser;
    } catch (e) {
      throw FirestoreException('Erro ao atualizar usu√°rio', originalException: e);
    }
  }

  /// Deleta a conta do usu√°rio
  Future<void> deleteAccount() async {
    try {
      final currentUser = _authService.currentUser;
      if (currentUser == null) {
        throw const AuthException('Usu√°rio n√£o est√° logado');
      }

      // Remove do Firestore
      await _usersCollection.doc(currentUser.uid).delete();

      // Remove do Firebase Auth
      await _authService.deleteAccount();
    } catch (e) {
      if (e is AuthException) rethrow;
      throw AuthException('Erro ao deletar conta', originalException: e);
    }
  }

  /// Busca um usu√°rio por ID
  Future<UserModel?> getUserById(String userId) async {
    try {
      final userDoc = await _usersCollection.doc(userId).get();

      if (userDoc.exists) {
        return UserModel.fromFirestore(userDoc);
      }

      return null;
    } catch (e) {
      throw FirestoreException('Erro ao buscar usu√°rio por ID', originalException: e);
    }
  }

  /// Busca um usu√°rio por email
  Future<UserModel?> getUserByEmail(String email) async {
    try {
      final querySnapshot = await _usersCollection
          .where('email', isEqualTo: email.trim().toLowerCase())
          .limit(1)
          .get();

      if (querySnapshot.docs.isNotEmpty) {
        return UserModel.fromFirestore(querySnapshot.docs.first);
      }

      return null;
    } catch (e) {
      throw FirestoreException('Erro ao buscar usu√°rio por email', originalException: e);
    }
  }

  /// Verifica se um email j√° est√° em uso
  Future<bool> isEmailInUse(String email) async {
    try {
      final user = await getUserByEmail(email);
      return user != null;
    } catch (e) {
      throw FirestoreException('Erro ao verificar email', originalException: e);
    }
  }

  /// Busca ou cria um usu√°rio no Firestore baseado no Firebase User
  Future<UserModel> _getOrCreateUser(User firebaseUser) async {
    try {
      final userDoc = await _usersCollection.doc(firebaseUser.uid).get();

      if (userDoc.exists) {
        return UserModel.fromFirestore(userDoc);
      } else {
        // Cria um novo usu√°rio no Firestore
        final userModel = UserModel.fromGoogleSignIn(
          uid: firebaseUser.uid,
          name: firebaseUser.displayName ?? '',
          email: firebaseUser.email ?? '',
          photoUrl: firebaseUser.photoURL,
        );

        await _saveUserToFirestore(userModel);
        return userModel;
      }
    } catch (e) {
      throw FirestoreException('Erro ao buscar ou criar usu√°rio', originalException: e);
    }
  }

  /// Salva um usu√°rio no Firestore
  Future<void> _saveUserToFirestore(UserModel user) async {
    try {
      await _usersCollection.doc(user.id).set(user.toFirestore());
    } catch (e) {
      throw FirestoreException('Erro ao salvar usu√°rio no Firestore', originalException: e);
    }
  }

  /// Verifica se h√° um usu√°rio logado
  bool get isLoggedIn => _authService.isLoggedIn;

  /// Retorna o ID do usu√°rio atual
  String? get currentUserId => _authService.currentUserId;

  /// Envia email de verifica√ß√£o
  Future<void> sendEmailVerification() async {
    try {
      await _authService.sendEmailVerification();
    } catch (e) {
      if (e is AuthException) rethrow;
      throw AuthException('Erro ao enviar verifica√ß√£o de email', originalException: e);
    }
  }

  /// Verifica se o email est√° verificado
  bool get isEmailVerified => _authService.isEmailVerified;
}

## lib\data\services\auth_service.dart <a id="auth_service_dart"></a>

### Dependencies

- `package:firebase_auth/firebase_auth.dart`
- `../../core/exceptions/app_exceptions.dart`
- `../models/user_model.dart`

import 'package:firebase_auth/firebase_auth.dart';
import '../../core/exceptions/app_exceptions.dart';
import '../models/user_model.dart';

/// Servi√ßo respons√°vel pela autentica√ß√£o com Firebase Auth
/// Implementa login com email/senha e Google Sign-In
class AuthService {
  final FirebaseAuth _firebaseAuth = FirebaseAuth.instance;
  /*caso implemente para ANDROID E IOS */
  //final GoogleSignIn _googleSignIn; = GoogleSignIn();

  /// Retorna o usu√°rio atualmente logado
  User? get currentUser => _firebaseAuth.currentUser;

  /// Stream que monitora mudan√ßas no estado de autentica√ß√£o
  Stream<User?> get authStateChanges => _firebaseAuth.authStateChanges();

  /// Verifica se h√° um usu√°rio logado
  bool get isLoggedIn => currentUser != null;

  /// Retorna o UID do usu√°rio atual
  String? get currentUserId => currentUser?.uid;

  /// Faz login com email e senha
  Future<UserCredential> signInWithEmailAndPassword({
    required String email,
    required String password,
  }) async {
    try {
      final credential = await _firebaseAuth.signInWithEmailAndPassword(
        email: email.trim(),
        password: password,
      );
      return credential;
    } on FirebaseAuthException catch (e) {
      throw ExceptionHandler.handleAuthException(e);
    } catch (e) {
      throw AuthException(
        'Erro inesperado durante o login',
        originalException: e,
      );
    }
  }

  /// Cria uma nova conta com email e senha
  Future<UserCredential> createUserWithEmailAndPassword({
    required String email,
    required String password,
  }) async {
    try {
      final credential = await _firebaseAuth.createUserWithEmailAndPassword(
        email: email.trim(),
        password: password,
      );
      return credential;
    } on FirebaseAuthException catch (e) {
      throw ExceptionHandler.handleAuthException(e);
    } catch (e) {
      throw AuthException(
        'Erro inesperado durante o cadastro',
        originalException: e,
      );
    }
  }

  /// Faz login com Google (compat√≠vel com Web e Mobile)
  Future<UserCredential> signInWithGoogle() async {
    try {
      /* ANDROID E AIOS
      if (kIsWeb) {
     */
      // Fluxo para Web
      final GoogleAuthProvider googleProvider = GoogleAuthProvider();

      // Adiciona escopos se necess√°rio
      googleProvider.addScope('email');
      googleProvider.addScope('profile');

      // Faz login diretamente com popup no web
      final userCredential = await _firebaseAuth.signInWithPopup(
        googleProvider,
      );

      return userCredential;
      /* ANDROID E AIOS
      }
      else {
        // Fluxo para Mobile (Android/iOS)
        final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();

        if (googleUser == null) {
          throw const AuthException('Login com Google cancelado pelo usu√°rio');
        }

        // Obt√©m os detalhes de autentica√ß√£o
        final GoogleSignInAuthentication googleAuth =
            await googleUser.authentication;

        // Cria uma credencial do Firebase
        final credential = GoogleAuthProvider.credential(
          accessToken: googleAuth.accessToken,
          idToken: googleAuth.idToken,
        );

        // Faz login no Firebase com a credencial do Google
        final userCredential = await _firebaseAuth.signInWithCredential(
          credential,
        );

        return userCredential;
      }*/
    } on FirebaseAuthException catch (e) {
      throw ExceptionHandler.handleAuthException(e);
    } catch (e) {
      if (e is AuthException) rethrow;
      throw AuthException(
        'Erro durante login com Google',
        originalException: e,
      );
    }
  }

  /// Faz logout
  Future<void> signOut() async {
    try {
      // Faz logout do Google se estiver logado
      /*ANDROID E AIOS
      if (await _googleSignIn.isSignedIn()) {
        await _googleSignIn.signOut();
      }
      */

      // Faz logout do Firebase
      await _firebaseAuth.signOut();
    } catch (e) {
      throw AuthException('Erro durante logout', originalException: e);
    }
  }

  /// Envia email de redefini√ß√£o de senha
  Future<void> sendPasswordResetEmail(String email) async {
    try {
      await _firebaseAuth.sendPasswordResetEmail(email: email.trim());
    } on FirebaseAuthException catch (e) {
      throw ExceptionHandler.handleAuthException(e);
    } catch (e) {
      throw AuthException(
        'Erro ao enviar email de redefini√ß√£o',
        originalException: e,
      );
    }
  }

  /// Atualiza o perfil do usu√°rio (nome e foto)
  Future<void> updateProfile({String? displayName, String? photoURL}) async {
    try {
      final user = currentUser;
      if (user == null) {
        throw const AuthException('Usu√°rio n√£o est√° logado');
      }

      await user.updateDisplayName(displayName);
      if (photoURL != null) {
        await user.updatePhotoURL(photoURL);
      }

      // Recarrega o usu√°rio para obter as informa√ß√µes atualizadas
      await user.reload();
    } on FirebaseAuthException catch (e) {
      throw ExceptionHandler.handleAuthException(e);
    } catch (e) {
      throw AuthException('Erro ao atualizar perfil', originalException: e);
    }
  }

  /// Atualiza o email do usu√°rio
  Future<void> updateEmail(String newEmail) async {
    try {
      final user = currentUser;
      if (user == null) {
        throw const AuthException('Usu√°rio n√£o est√° logado');
      }

      await user.verifyBeforeUpdateEmail(newEmail.trim());
    } on FirebaseAuthException catch (e) {
      throw ExceptionHandler.handleAuthException(e);
    } catch (e) {
      throw AuthException('Erro ao atualizar email', originalException: e);
    }
  }

  /// Atualiza a senha do usu√°rio
  Future<void> updatePassword(String newPassword) async {
    try {
      final user = currentUser;
      if (user == null) {
        throw const AuthException('Usu√°rio n√£o est√° logado');
      }

      await user.updatePassword(newPassword);
    } on FirebaseAuthException catch (e) {
      throw ExceptionHandler.handleAuthException(e);
    } catch (e) {
      throw AuthException('Erro ao atualizar senha', originalException: e);
    }
  }

  /// Reautentica o usu√°rio com email e senha
  Future<void> reauthenticateWithEmailAndPassword({
    required String email,
    required String password,
  }) async {
    try {
      final user = currentUser;
      if (user == null) {
        throw const AuthException('Usu√°rio n√£o est√° logado');
      }

      final credential = EmailAuthProvider.credential(
        email: email.trim(),
        password: password,
      );

      await user.reauthenticateWithCredential(credential);
    } on FirebaseAuthException catch (e) {
      throw ExceptionHandler.handleAuthException(e);
    } catch (e) {
      throw AuthException('Erro durante reautentica√ß√£o', originalException: e);
    }
  }

  /// Deleta a conta do usu√°rio
  Future<void> deleteAccount() async {
    try {
      final user = currentUser;
      if (user == null) {
        throw const AuthException('Usu√°rio n√£o est√° logado');
      }

      await user.delete();
    } on FirebaseAuthException catch (e) {
      throw ExceptionHandler.handleAuthException(e);
    } catch (e) {
      throw AuthException('Erro ao deletar conta', originalException: e);
    }
  }

  /// Envia email de verifica√ß√£o
  Future<void> sendEmailVerification() async {
    try {
      final user = currentUser;
      if (user == null) {
        throw const AuthException('Usu√°rio n√£o est√° logado');
      }

      if (user.emailVerified) {
        throw const AuthException('Email j√° est√° verificado');
      }

      await user.sendEmailVerification();
    } on FirebaseAuthException catch (e) {
      throw ExceptionHandler.handleAuthException(e);
    } catch (e) {
      throw AuthException(
        'Erro ao enviar verifica√ß√£o de email',
        originalException: e,
      );
    }
  }

  /// Recarrega as informa√ß√µes do usu√°rio atual
  Future<void> reloadUser() async {
    try {
      final user = currentUser;
      if (user == null) {
        throw const AuthException('Usu√°rio n√£o est√° logado');
      }

      await user.reload();
    } catch (e) {
      throw AuthException('Erro ao recarregar usu√°rio', originalException: e);
    }
  }

  /// Converte User do Firebase para UserModel
  UserModel? firebaseUserToUserModel(User? firebaseUser) {
    if (firebaseUser == null) return null;

    return UserModel.fromGoogleSignIn(
      uid: firebaseUser.uid,
      name: firebaseUser.displayName ?? '',
      email: firebaseUser.email ?? '',
      photoUrl: firebaseUser.photoURL,
    );
  }

  /// Verifica se o email est√° verificado
  bool get isEmailVerified => currentUser?.emailVerified ?? false;

  /// Retorna informa√ß√µes b√°sicas do usu√°rio atual
  Map<String, dynamic>? get currentUserInfo {
    final user = currentUser;
    if (user == null) return null;

    return {
      'uid': user.uid,
      'email': user.email,
      'displayName': user.displayName,
      'photoURL': user.photoURL,
      'emailVerified': user.emailVerified,
      'creationTime': user.metadata.creationTime?.toIso8601String(),
      'lastSignInTime': user.metadata.lastSignInTime?.toIso8601String(),
    };
  }
}

## lib\presentation\controllers\auth_controller.dart <a id="auth_controller_dart"></a>

### Dependencies

- `package:flutter/foundation.dart`
- `../../core/exceptions/app_exceptions.dart`
- `../../data/models/user_model.dart`
- `../../data/repositories/auth_repository.dart`

import 'package:flutter/foundation.dart';
import '../../core/exceptions/app_exceptions.dart';
import '../../data/models/user_model.dart';
import '../../data/repositories/auth_repository.dart';

/// Estados poss√≠veis da autentica√ß√£o
enum AuthState { initial, loading, authenticated, unauthenticated, error }

/// Controller respons√°vel por gerenciar o estado de autentica√ß√£o
/// Usa Provider para notificar mudan√ßas na UI
class AuthController extends ChangeNotifier {
  final AuthRepository _authRepository = AuthRepository();

  // Estado atual
  AuthState _state = AuthState.initial;
  UserModel? _currentUser;
  String? _errorMessage;
  bool _isLoading = false;

  // Getters
  AuthState get state => _state;
  UserModel? get currentUser => _currentUser;
  String? get errorMessage => _errorMessage;
  bool get isLoading => _isLoading;
  bool get isAuthenticated =>
      _state == AuthState.authenticated && _currentUser != null;
  bool get isUnauthenticated => _state == AuthState.unauthenticated;

  /// Inicializa o controller e monitora mudan√ßas de autentica√ß√£o
  void initialize() {
    _authRepository.authStateChanges.listen(
      (user) {
        _currentUser = user;
        if (user != null) {
          _setState(AuthState.authenticated);
        } else {
          _setState(AuthState.unauthenticated);
        }
      },
      onError: (error) {
        _setError('Erro ao monitorar autentica√ß√£o: ${error.toString()}');
      },
    );
  }

  /// Faz login com email e senha
  Future<bool> signInWithEmailAndPassword({
    required String email,
    required String password,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      final user = await _authRepository.signInWithEmailAndPassword(
        email: email,
        password: password,
      );

      _currentUser = user;
      _setState(AuthState.authenticated);
      return true;
    } on AuthException catch (e) {
      _setError(e.message);
      return false;
    } catch (e) {
      _setError('Erro inesperado durante o login');
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Cria uma nova conta com email e senha
  Future<bool> createUserWithEmailAndPassword({
    required String name,
    required String email,
    required String password,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      final user = await _authRepository.createUserWithEmailAndPassword(
        name: name,
        email: email,
        password: password,
      );

      _currentUser = user;
      _setState(AuthState.authenticated);
      return true;
    } on AuthException catch (e) {
      _setError(e.message);
      return false;
    } catch (e) {
      _setError('Erro inesperado durante o cadastro');
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Faz login com Google
  Future<bool> signInWithGoogle() async {
    try {
      _setLoading(true);
      _clearError();

      final user = await _authRepository.signInWithGoogle();

      _currentUser = user;
      _setState(AuthState.authenticated);
      return true;
    } on AuthException catch (e) {
      _setError(e.message);
      return false;
    } catch (e) {
      _setError('Erro inesperado durante o login com Google');
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Faz logout
  Future<void> signOut() async {
    try {
      _setLoading(true);
      _clearError();

      await _authRepository.signOut();

      _currentUser = null;
      _setState(AuthState.unauthenticated);
    } on AuthException catch (e) {
      _setError(e.message);
    } catch (e) {
      _setError('Erro inesperado durante o logout');
    } finally {
      _setLoading(false);
    }
  }

  /// Envia email de redefini√ß√£o de senha
  Future<bool> sendPasswordResetEmail(String email) async {
    try {
      _setLoading(true);
      _clearError();

      await _authRepository.sendPasswordResetEmail(email);
      return true;
    } on AuthException catch (e) {
      _setError(e.message);
      return false;
    } catch (e) {
      _setError('Erro inesperado ao enviar email de redefini√ß√£o');
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Atualiza os dados do usu√°rio
  Future<bool> updateUser(UserModel updatedUser) async {
    try {
      _setLoading(true);
      _clearError();

      final user = await _authRepository.updateUser(updatedUser);
      _currentUser = user;
      notifyListeners();
      return true;
    } on FirestoreException catch (e) {
      _setError(e.message);
      return false;
    } catch (e) {
      _setError('Erro inesperado ao atualizar usu√°rio');
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Deleta a conta do usu√°rio
  Future<bool> deleteAccount() async {
    try {
      _setLoading(true);
      _clearError();

      await _authRepository.deleteAccount();

      _currentUser = null;
      _setState(AuthState.unauthenticated);
      return true;
    } on AuthException catch (e) {
      _setError(e.message);
      return false;
    } catch (e) {
      _setError('Erro inesperado ao deletar conta');
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Envia email de verifica√ß√£o
  Future<bool> sendEmailVerification() async {
    try {
      _setLoading(true);
      _clearError();

      await _authRepository.sendEmailVerification();
      return true;
    } on AuthException catch (e) {
      _setError(e.message);
      return false;
    } catch (e) {
      _setError('Erro inesperado ao enviar verifica√ß√£o de email');
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Recarrega os dados do usu√°rio atual
  Future<void> refreshUser() async {
    try {
      if (_currentUser == null) return;

      final user = await _authRepository.getCurrentUser();
      if (user != null) {
        _currentUser = user;
        notifyListeners();
      }
    } catch (e) {
      debugPrint('Erro ao recarregar usu√°rio: $e');
    }
  }

  /// Verifica se um email j√° est√° em uso
  Future<bool> isEmailInUse(String email) async {
    try {
      return await _authRepository.isEmailInUse(email);
    } catch (e) {
      debugPrint('Erro ao verificar email: $e');
      return false;
    }
  }

  /// Define o estado de loading
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }

  /// Define um erro
  void _setError(String error) {
    _errorMessage = error;
    _state = AuthState.error;
    notifyListeners();
  }

  /// Limpa o erro atual
  void _clearError() {
    _errorMessage = null;
    if (_state == AuthState.error) {
      _state = _currentUser != null
          ? AuthState.authenticated
          : AuthState.unauthenticated;
    }
    notifyListeners();
  }

  /// Define o estado atual
  void _setState(AuthState newState) {
    _state = newState;
    notifyListeners();
  }

  /// Limpa o erro manualmente (para ser chamado da UI)
  void clearError() {
    _clearError();
  }

  /// Verifica se o email est√° verificado
  bool get isEmailVerified => _authRepository.isEmailVerified;

  /// Retorna informa√ß√µes b√°sicas do usu√°rio para debug
  Map<String, dynamic>? get userInfo {
    if (_currentUser == null) return null;

    return {
      'id': _currentUser!.id,
      'name': _currentUser!.name,
      'email': _currentUser!.email,
      'hasPhoto': _currentUser!.hasPhoto,
      'isNewUser': _currentUser!.isNewUser,
    };
  }

  /// M√©todo para validar dados antes de opera√ß√µes
  bool _validateUserData({String? name, String? email, String? password}) {
    if (name != null && name.trim().isEmpty) {
      _setError('Nome √© obrigat√≥rio');
      return false;
    }

    if (email != null && email.trim().isEmpty) {
      _setError('E-mail √© obrigat√≥rio');
      return false;
    }

    if (email != null && !RegExp(r'^[^@]+@[^@]+\.[^@]+').hasMatch(email)) {
      _setError('E-mail inv√°lido');
      return false;
    }

    if (password != null && password.length < 6) {
      _setError('Senha deve ter pelo menos 6 caracteres');
      return false;
    }

    return true;
  }

  /// M√©todo de conveni√™ncia para login com valida√ß√£o
  Future<bool> signInWithValidation({
    required String email,
    required String password,
  }) async {
    if (!_validateUserData(email: email, password: password)) {
      return false;
    }

    return await signInWithEmailAndPassword(email: email, password: password);
  }

  /// M√©todo de conveni√™ncia para cadastro com valida√ß√£o
  Future<bool> createUserWithValidation({
    required String name,
    required String email,
    required String password,
  }) async {
    if (!_validateUserData(name: name, email: email, password: password)) {
      return false;
    }

    return await createUserWithEmailAndPassword(
      name: name,
      email: email,
      password: password,
    );
  }
}

## lib\presentation\widgets\common\confirmation_dialog.dart <a id="confirmation_dialog_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';

/// Dialog de confirma√ß√£o customiz√°vel
class ConfirmationDialog extends StatelessWidget {
  final String title;
  final String message;
  final String? confirmText;
  final String? cancelText;
  final VoidCallback? onConfirm;
  final VoidCallback? onCancel;
  final IconData? icon;
  final Color? iconColor;
  final Color? confirmButtonColor;
  final Color? cancelButtonColor;
  final bool isDangerous;

  const ConfirmationDialog({
    super.key,
    required this.title,
    required this.message,
    this.confirmText,
    this.cancelText,
    this.onConfirm,
    this.onCancel,
    this.icon,
    this.iconColor,
    this.confirmButtonColor,
    this.cancelButtonColor,
    this.isDangerous = false,
  });

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      title: Row(
        children: [
          if (icon != null) ...[
            Icon(
              icon,
              color: iconColor ?? (isDangerous ? AppColors.error : AppColors.primary),
              size: 24,
            ),
            const SizedBox(width: AppDimensions.spacingSm),
          ],
          Expanded(
            child: Text(
              title,
              style: const TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
                color: AppColors.textPrimary,
              ),
            ),
          ),
        ],
      ),
      content: Text(
        message,
        style: const TextStyle(
          fontSize: 16,
          color: AppColors.textSecondary,
          height: 1.4,
        ),
      ),
      actions: [
        // Bot√£o Cancelar
        TextButton(
          onPressed: onCancel ?? () => Navigator.of(context).pop(false),
          style: TextButton.styleFrom(
            foregroundColor: cancelButtonColor ?? AppColors.textSecondary,
          ),
          child: Text(cancelText ?? 'Cancelar'),
        ),

        // Bot√£o Confirmar
        ElevatedButton(
          onPressed: () {
            Navigator.of(context).pop(true);
            onConfirm?.call();
          },
          style: ElevatedButton.styleFrom(
            backgroundColor: confirmButtonColor ??
                (isDangerous ? AppColors.error : AppColors.primary),
            foregroundColor: AppColors.textOnPrimary,
          ),
          child: Text(confirmText ?? 'Confirmar'),
        ),
      ],
    );
  }

  /// M√©todo est√°tico para mostrar o dialog
  static Future<bool?> show({
    required BuildContext context,
    required String title,
    required String message,
    String? confirmText,
    String? cancelText,
    VoidCallback? onConfirm,
    VoidCallback? onCancel,
    IconData? icon,
    Color? iconColor,
    Color? confirmButtonColor,
    Color? cancelButtonColor,
    bool isDangerous = false,
  }) {
    return showDialog<bool>(
      context: context,
      builder: (context) => ConfirmationDialog(
        title: title,
        message: message,
        confirmText: confirmText,
        cancelText: cancelText,
        onConfirm: onConfirm,
        onCancel: onCancel,
        icon: icon,
        iconColor: iconColor,
        confirmButtonColor: confirmButtonColor,
        cancelButtonColor: cancelButtonColor,
        isDangerous: isDangerous,
      ),
    );
  }
}

/// Dialog de confirma√ß√£o para a√ß√µes perigosas
class DangerConfirmationDialog extends StatelessWidget {
  final String title;
  final String message;
  final String? confirmText;
  final VoidCallback? onConfirm;

  const DangerConfirmationDialog({
    super.key,
    required this.title,
    required this.message,
    this.confirmText,
    this.onConfirm,
  });

  @override
  Widget build(BuildContext context) {
    return ConfirmationDialog(
      title: title,
      message: message,
      confirmText: confirmText ?? 'Excluir',
      icon: Icons.warning,
      isDangerous: true,
      onConfirm: onConfirm,
    );
  }

  static Future<bool?> show({
    required BuildContext context,
    required String title,
    required String message,
    String? confirmText,
    VoidCallback? onConfirm,
  }) {
    return showDialog<bool>(
      context: context,
      builder: (context) => DangerConfirmationDialog(
        title: title,
        message: message,
        confirmText: confirmText,
        onConfirm: onConfirm,
      ),
    );
  }
}

/// Dialog de confirma√ß√£o simples
class SimpleConfirmationDialog extends StatelessWidget {
  final String message;
  final VoidCallback? onConfirm;

  const SimpleConfirmationDialog({
    super.key,
    required this.message,
    this.onConfirm,
  });

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      content: Text(
        message,
        style: const TextStyle(
          fontSize: 16,
          color: AppColors.textPrimary,
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(false),
          child: const Text('N√£o'),
        ),
        ElevatedButton(
          onPressed: () {
            Navigator.of(context).pop(true);
            onConfirm?.call();
          },
          style: ElevatedButton.styleFrom(
            backgroundColor: AppColors.primary,
            foregroundColor: AppColors.textOnPrimary,
          ),
          child: const Text('Sim'),
        ),
      ],
    );
  }

  static Future<bool?> show({
    required BuildContext context,
    required String message,
    VoidCallback? onConfirm,
  }) {
    return showDialog<bool>(
      context: context,
      builder: (context) => SimpleConfirmationDialog(
        message: message,
        onConfirm: onConfirm,
      ),
    );
  }
}

/// Dialog de confirma√ß√£o com input
class InputConfirmationDialog extends StatefulWidget {
  final String title;
  final String message;
  final String? hintText;
  final String? confirmText;
  final Function(String)? onConfirm;
  final bool isRequired;
  final String? Function(String?)? validator;

  const InputConfirmationDialog({
    super.key,
    required this.title,
    required this.message,
    this.hintText,
    this.confirmText,
    this.onConfirm,
    this.isRequired = true,
    this.validator,
  });

  @override
  State<InputConfirmationDialog> createState() => _InputConfirmationDialogState();

  static Future<String?> show({
    required BuildContext context,
    required String title,
    required String message,
    String? hintText,
    String? confirmText,
    Function(String)? onConfirm,
    bool isRequired = true,
    String? Function(String?)? validator,
  }) {
    return showDialog<String>(
      context: context,
      builder: (context) => InputConfirmationDialog(
        title: title,
        message: message,
        hintText: hintText,
        confirmText: confirmText,
        onConfirm: onConfirm,
        isRequired: isRequired,
        validator: validator,
      ),
    );
  }
}

class _InputConfirmationDialogState extends State<InputConfirmationDialog> {
  final TextEditingController _controller = TextEditingController();
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      title: Text(
        widget.title,
        style: const TextStyle(
          fontSize: 18,
          fontWeight: FontWeight.bold,
          color: AppColors.textPrimary,
        ),
      ),
      content: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              widget.message,
              style: const TextStyle(
                fontSize: 16,
                color: AppColors.textSecondary,
              ),
            ),
            const SizedBox(height: AppDimensions.spacingMd),
            TextFormField(
              controller: _controller,
              decoration: InputDecoration(
                hintText: widget.hintText,
                border: const OutlineInputBorder(),
              ),
              validator: widget.validator ?? (widget.isRequired
                  ? (value) => value?.isEmpty == true ? 'Campo obrigat√≥rio' : null
                  : null),
              autofocus: true,
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancelar'),
        ),
        ElevatedButton(
          onPressed: () {
            if (_formKey.currentState?.validate() == true) {
              final value = _controller.text;
              Navigator.of(context).pop(value);
              widget.onConfirm?.call(value);
            }
          },
          style: ElevatedButton.styleFrom(
            backgroundColor: AppColors.primary,
            foregroundColor: AppColors.textOnPrimary,
          ),
          child: Text(widget.confirmText ?? 'Confirmar'),
        ),
      ],
    );
  }
}

## android\app\build.gradle.kts <a id="build_gradle_kts"></a>

plugins {
    id("com.android.application")
    // START: FlutterFire Configuration
    id("com.google.gms.google-services")
    // END: FlutterFire Configuration
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.contask"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.contask"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}

## lib\presentation\widgets\dialogs\confirmation_dialog.dart <a id="confirmation_dialog_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';

/// Dialog gen√©rico de confirma√ß√£o reutiliz√°vel
class ConfirmationDialog extends StatelessWidget {
  final String title;
  final String content;
  final String confirmText;
  final String cancelText;
  final VoidCallback? onConfirm;
  final VoidCallback? onCancel;
  final Color? confirmButtonColor;
  final Color? confirmTextColor;
  final IconData? icon;
  final Color? iconColor;
  final bool isDestructive;

  const ConfirmationDialog({
    super.key,
    required this.title,
    required this.content,
    this.confirmText = 'Confirmar',
    this.cancelText = 'Cancelar',
    this.onConfirm,
    this.onCancel,
    this.confirmButtonColor,
    this.confirmTextColor,
    this.icon,
    this.iconColor,
    this.isDestructive = false,
  });

  /// Factory para criar um dialog de promo√ß√£o de volunt√°rio
  factory ConfirmationDialog.promoteVolunteer({
    required String volunteerName,
    required VoidCallback onConfirm,
    VoidCallback? onCancel,
  }) {
    return ConfirmationDialog(
      title: 'Promover Volunt√°rio',
      content: 'Tem certeza de que deseja promover "$volunteerName" a gerente?\n\n'
          'Esta a√ß√£o conceder√° permiss√µes de gerenciamento do evento ao usu√°rio. '
          'O volunt√°rio poder√° criar tasks, gerenciar outros volunt√°rios e '
          'modificar configura√ß√µes do evento.\n\n'
          'Esta a√ß√£o n√£o pode ser desfeita facilmente.',
      confirmText: 'Confirmar Promo√ß√£o',
      cancelText: 'Cancelar',
      onConfirm: onConfirm,
      onCancel: onCancel,
      confirmButtonColor: AppColors.warning,
      confirmTextColor: Colors.white,
      icon: Icons.admin_panel_settings,
      iconColor: AppColors.warning,
      isDestructive: false,
    );
  }

  /// Factory para criar um dialog de remo√ß√£o/exclus√£o
  factory ConfirmationDialog.delete({
    required String title,
    required String itemName,
    required VoidCallback onConfirm,
    VoidCallback? onCancel,
  }) {
    return ConfirmationDialog(
      title: title,
      content: 'Tem certeza de que deseja excluir "$itemName"?\n\n'
          'Esta a√ß√£o n√£o pode ser desfeita.',
      confirmText: 'Excluir',
      cancelText: 'Cancelar',
      onConfirm: onConfirm,
      onCancel: onCancel,
      confirmButtonColor: AppColors.error,
      confirmTextColor: Colors.white,
      icon: Icons.delete_forever,
      iconColor: AppColors.error,
      isDestructive: true,
    );
  }

  /// Factory para criar um dialog de sa√≠da/logout
  factory ConfirmationDialog.logout({
    required VoidCallback onConfirm,
    VoidCallback? onCancel,
  }) {
    return ConfirmationDialog(
      title: 'Sair da Conta',
      content: 'Tem certeza de que deseja sair da sua conta?',
      confirmText: 'Sair',
      cancelText: 'Cancelar',
      onConfirm: onConfirm,
      onCancel: onCancel,
      confirmButtonColor: AppColors.error,
      confirmTextColor: Colors.white,
      icon: Icons.logout,
      iconColor: AppColors.error,
      isDestructive: false,
    );
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      title: Row(
        children: [
          if (icon != null) ...[
            Icon(
              icon,
              color: iconColor ?? AppColors.primary,
              size: 24,
            ),
            const SizedBox(width: AppDimensions.spacingMd),
          ],
          Expanded(
            child: Text(
              title,
              style: const TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      content: ConstrainedBox(
        constraints: const BoxConstraints(
          maxWidth: 400,
          maxHeight: 300,
        ),
        child: SingleChildScrollView(
          child: Text(
            content,
            style: const TextStyle(
              fontSize: 14,
              color: AppColors.textSecondary,
              height: 1.4,
            ),
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: onCancel ?? () => Navigator.of(context).pop(false),
          child: Text(
            cancelText,
            style: const TextStyle(
              color: AppColors.textSecondary,
            ),
          ),
        ),
        ElevatedButton(
          onPressed: onConfirm != null
              ? () {
                  onConfirm!();
                  Navigator.of(context).pop(true);
                }
              : null,
          style: ElevatedButton.styleFrom(
            backgroundColor: confirmButtonColor ?? AppColors.primary,
            foregroundColor: confirmTextColor ?? Colors.white,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8),
            ),
          ),
          child: Text(confirmText),
        ),
      ],
    );
  }

  /// M√©todo est√°tico para mostrar o dialog e retornar o resultado
  static Future<bool?> show({
    required BuildContext context,
    required String title,
    required String content,
    String confirmText = 'Confirmar',
    String cancelText = 'Cancelar',
    Color? confirmButtonColor,
    Color? confirmTextColor,
    IconData? icon,
    Color? iconColor,
    bool isDestructive = false,
  }) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => ConfirmationDialog(
        title: title,
        content: content,
        confirmText: confirmText,
        cancelText: cancelText,
        confirmButtonColor: confirmButtonColor,
        confirmTextColor: confirmTextColor,
        icon: icon,
        iconColor: iconColor,
        isDestructive: isDestructive,
        onConfirm: () {}, // O callback ser√° tratado pelo retorno do showDialog
      ),
    );
  }

  /// M√©todo est√°tico para mostrar dialog de promo√ß√£o
  static Future<bool?> showPromoteVolunteer({
    required BuildContext context,
    required String volunteerName,
  }) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => ConfirmationDialog.promoteVolunteer(
        volunteerName: volunteerName,
        onConfirm: () {}, // O callback ser√° tratado pelo retorno do showDialog
      ),
    );
  }

  /// M√©todo est√°tico para mostrar dialog de exclus√£o
  static Future<bool?> showDelete({
    required BuildContext context,
    required String title,
    required String itemName,
  }) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => ConfirmationDialog.delete(
        title: title,
        itemName: itemName,
        onConfirm: () {}, // O callback ser√° tratado pelo retorno do showDialog
      ),
    );
  }

  /// M√©todo est√°tico para mostrar dialog de logout
  static Future<bool?> showLogout({
    required BuildContext context,
  }) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => ConfirmationDialog.logout(
        onConfirm: () {}, // O callback ser√° tratado pelo retorno do showDialog
      ),
    );
  }
}

## android\build.gradle.kts <a id="build_gradle_kts"></a>

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory = rootProject.layout.buildDirectory.dir("../../build").get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}

## ios\Runner\Assets.xcassets\LaunchImage.imageset\Contents.json <a id="Contents_json"></a>

{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

## ios\Runner\Assets.xcassets\AppIcon.appiconset\Contents.json <a id="Contents_json"></a>

{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

## lib\presentation\screens\event\create_event_screen.dart <a id="create_event_screen_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `package:provider/provider.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../controllers/auth_controller.dart`
- `../../controllers/event_controller.dart`
- `../../widgets/common/custom_button.dart`
- `../../widgets/common/custom_text_field.dart`
- `../../widgets/event/skill_chip.dart`

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../controllers/auth_controller.dart';
import '../../controllers/event_controller.dart';
import '../../widgets/common/custom_button.dart';
import '../../widgets/common/custom_text_field.dart';
import '../../widgets/event/skill_chip.dart';

/// Tela para cria√ß√£o de novos eventos
class CreateEventScreen extends StatefulWidget {
  const CreateEventScreen({super.key});

  @override
  State<CreateEventScreen> createState() => _CreateEventScreenState();
}

class _CreateEventScreenState extends State<CreateEventScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _locationController = TextEditingController();
  final _skillController = TextEditingController();
  final _resourceController = TextEditingController();

  final List<String> _selectedSkills = [];
  final List<String> _selectedResources = [];

  // Lista de habilidades pr√©-definidas
  final List<String> _predefinedSkills = [
    'Organiza√ß√£o',
    'Comunica√ß√£o',
    'Lideran√ßa',
    'Tecnologia',
    'Design',
    'Marketing',
    'Vendas',
    'Atendimento',
    'Log√≠stica',
    'Culin√°ria',
    'Fotografia',
    'M√∫sica',
    'Arte',
    'Esportes',
    'Educa√ß√£o',
  ];

  // Lista de recursos pr√©-definidos
  final List<String> _predefinedResources = [
    'Carro',
    'Caminh√£o',
    'Equipamento de Som',
    'Projetor',
    'Notebook',
    'C√¢mera',
    'Microfone',
    'Mesa',
    'Cadeira',
    'Tenda',
    'Gerador',
    'Ferramentas',
    'Material de Limpeza',
    'Cozinha',
    'Refrigerador',
  ];

  @override
  void dispose() {
    _nameController.dispose();
    _descriptionController.dispose();
    _locationController.dispose();
    _skillController.dispose();
    _resourceController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.background,
      appBar: AppBar(
        title: const Text('Criar Evento'),
        backgroundColor: AppColors.primary,
        foregroundColor: AppColors.textOnPrimary,
      ),
      body: Consumer2<AuthController, EventController>(
        builder: (context, authController, eventController, child) {
          return Form(
            key: _formKey,
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(AppDimensions.paddingLg),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Informa√ß√µes b√°sicas
                  _buildBasicInfoSection(),

                  const SizedBox(height: AppDimensions.spacingLg),

                  // Habilidades necess√°rias
                  _buildSkillsSection(),

                  const SizedBox(height: AppDimensions.spacingLg),

                  // Recursos necess√°rios
                  _buildResourcesSection(),

                  const SizedBox(height: AppDimensions.spacingXl),

                  // Bot√£o de criar
                  SizedBox(
                    width: double.infinity,
                    child: CustomButton(
                      text: 'Criar Evento',
                      onPressed: () =>
                          _handleCreateEvent(authController, eventController),
                      isLoading: eventController.isCreatingEvent,
                    ),
                  ),

                  // Mensagem de erro
                  if (eventController.hasError) ...[
                    const SizedBox(height: AppDimensions.spacingMd),
                    Container(
                      width: double.infinity,
                      padding: const EdgeInsets.all(AppDimensions.paddingMd),
                      decoration: BoxDecoration(
                        color: AppColors.error.withValues(alpha: 0.1),
                        borderRadius: BorderRadius.circular(
                          AppDimensions.radiusMd,
                        ),
                        border: Border.all(
                          color: AppColors.error.withValues(alpha: 0.3),
                        ),
                      ),
                      child: Row(
                        children: [
                          const Icon(
                            Icons.error_outline,
                            color: AppColors.error,
                            size: 20,
                          ),
                          const SizedBox(width: AppDimensions.spacingSm),
                          Expanded(
                            child: Text(
                              eventController.errorMessage ??
                                  'Erro desconhecido',
                              style: const TextStyle(
                                color: AppColors.error,
                                fontSize: AppDimensions.fontSizeMd,
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildBasicInfoSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Informa√ß√µes B√°sicas',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeLg,
            fontWeight: FontWeight.bold,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingMd),

        // Nome do evento
        CustomTextField(
          controller: _nameController,
          label: 'Nome do Evento',
          hint: 'Digite o nome do evento',
          validator: (value) {
            if (value == null || value.trim().isEmpty) {
              return 'Nome do evento √© obrigat√≥rio';
            }
            if (value.trim().length < 3) {
              return 'Nome deve ter pelo menos 3 caracteres';
            }
            if (value.trim().length > 100) {
              return 'Nome deve ter no m√°ximo 100 caracteres';
            }
            return null;
          },
        ),

        const SizedBox(height: AppDimensions.spacingMd),

        // Descri√ß√£o
        CustomTextField(
          controller: _descriptionController,
          label: 'Descri√ß√£o',
          hint: 'Descreva o evento (opcional)',
          maxLines: 3,
          validator: (value) {
            if (value != null && value.length > 500) {
              return 'Descri√ß√£o deve ter no m√°ximo 500 caracteres';
            }
            return null;
          },
        ),

        const SizedBox(height: AppDimensions.spacingMd),

        // Localiza√ß√£o
        CustomTextField(
          controller: _locationController,
          label: 'Localiza√ß√£o',
          hint: 'Onde ser√° realizado o evento',
          validator: (value) {
            if (value == null || value.trim().isEmpty) {
              return 'Localiza√ß√£o √© obrigat√≥ria';
            }
            if (value.trim().length > 200) {
              return 'Localiza√ß√£o deve ter no m√°ximo 200 caracteres';
            }
            return null;
          },
        ),
      ],
    );
  }

  Widget _buildSkillsSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Habilidades Necess√°rias',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeLg,
            fontWeight: FontWeight.bold,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),
        const Text(
          'Selecione as habilidades que os volunt√°rios devem ter',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeMd,
            color: AppColors.textSecondary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingMd),

        // Campo para adicionar nova habilidade
        Row(
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Expanded(
              child: CustomTextField(
                controller: _skillController,
                label: 'Nova Habilidade',
                hint: 'Digite uma habilidade',
              ),
            ),
            const SizedBox(width: AppDimensions.spacingSm),
            Padding(
              padding: const EdgeInsets.only(bottom: 2.0),
              child: CustomButton(
                text: 'Adicionar',
                onPressed: _addSkill,
                isFullWidth: false,
              ),
            ),
          ],
        ),

        const SizedBox(height: AppDimensions.spacingMd),

        // Habilidades pr√©-definidas
        const Text(
          'Ou selecione das op√ß√µes abaixo:',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeMd,
            color: AppColors.textSecondary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),

        Wrap(
          spacing: AppDimensions.spacingSm,
          runSpacing: AppDimensions.spacingSm,
          children: _predefinedSkills.map((skill) {
            final isSelected = _selectedSkills.contains(skill);
            return SkillChip(
              label: skill,
              isSelected: isSelected,
              onTap: () => _toggleSkill(skill),
            );
          }).toList(),
        ),

        // Habilidades selecionadas
        if (_selectedSkills.isNotEmpty) ...[
          const SizedBox(height: AppDimensions.spacingMd),
          const Text(
            'Habilidades selecionadas:',
            style: TextStyle(
              fontSize: AppDimensions.fontSizeMd,
              fontWeight: FontWeight.w600,
              color: AppColors.textPrimary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingSm),
          Wrap(
            spacing: AppDimensions.spacingSm,
            runSpacing: AppDimensions.spacingSm,
            children: _selectedSkills.map((skill) {
              return SkillChip(
                label: skill,
                isSelected: true,
                onTap: () => _removeSkill(skill),
                showRemove: true,
              );
            }).toList(),
          ),
        ],
      ],
    );
  }

  Widget _buildResourcesSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Recursos Necess√°rios',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeLg,
            fontWeight: FontWeight.bold,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),
        const Text(
          'Selecione os recursos que os volunt√°rios devem ter',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeMd,
            color: AppColors.textSecondary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingMd),

        // Campo para adicionar novo recurso
        Row(
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Expanded(
              child: CustomTextField(
                controller: _resourceController,
                label: 'Novo Recurso',
                hint: 'Digite um recurso',
              ),
            ),
            const SizedBox(width: AppDimensions.spacingSm),
            Padding(
              padding: const EdgeInsets.only(bottom: 2.0),
              child: CustomButton(
                text: 'Adicionar',
                onPressed: _addResource,
                isFullWidth: false,
              ),
            ),
          ],
        ),

        const SizedBox(height: AppDimensions.spacingMd),

        // Recursos pr√©-definidos
        const Text(
          'Ou selecione das op√ß√µes abaixo:',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeMd,
            color: AppColors.textSecondary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),

        Wrap(
          spacing: AppDimensions.spacingSm,
          runSpacing: AppDimensions.spacingSm,
          children: _predefinedResources.map((resource) {
            final isSelected = _selectedResources.contains(resource);
            return SkillChip(
              label: resource,
              isSelected: isSelected,
              onTap: () => _toggleResource(resource),
            );
          }).toList(),
        ),

        // Recursos selecionados
        if (_selectedResources.isNotEmpty) ...[
          const SizedBox(height: AppDimensions.spacingMd),
          const Text(
            'Recursos selecionados:',
            style: TextStyle(
              fontSize: AppDimensions.fontSizeMd,
              fontWeight: FontWeight.w600,
              color: AppColors.textPrimary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingSm),
          Wrap(
            spacing: AppDimensions.spacingSm,
            runSpacing: AppDimensions.spacingSm,
            children: _selectedResources.map((resource) {
              return SkillChip(
                label: resource,
                isSelected: true,
                onTap: () => _removeResource(resource),
                showRemove: true,
              );
            }).toList(),
          ),
        ],
      ],
    );
  }

  void _addSkill() {
    final skill = _skillController.text.trim();
    if (skill.isNotEmpty && !_selectedSkills.contains(skill)) {
      setState(() {
        _selectedSkills.add(skill);
        _skillController.clear();
      });
    }
  }

  void _toggleSkill(String skill) {
    setState(() {
      if (_selectedSkills.contains(skill)) {
        _selectedSkills.remove(skill);
      } else {
        _selectedSkills.add(skill);
      }
    });
  }

  void _removeSkill(String skill) {
    setState(() {
      _selectedSkills.remove(skill);
    });
  }

  void _addResource() {
    final resource = _resourceController.text.trim();
    if (resource.isNotEmpty && !_selectedResources.contains(resource)) {
      setState(() {
        _selectedResources.add(resource);
        _resourceController.clear();
      });
    }
  }

  void _toggleResource(String resource) {
    setState(() {
      if (_selectedResources.contains(resource)) {
        _selectedResources.remove(resource);
      } else {
        _selectedResources.add(resource);
      }
    });
  }

  void _removeResource(String resource) {
    setState(() {
      _selectedResources.remove(resource);
    });
  }

  Future<void> _handleCreateEvent(
    AuthController authController,
    EventController eventController,
  ) async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    final user = authController.currentUser;
    if (user == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Usu√°rio n√£o encontrado'),
          backgroundColor: AppColors.error,
        ),
      );
      return;
    }

    // Limpa erros anteriores
    eventController.clearError();

    final event = await eventController.createEvent(
      name: _nameController.text.trim(),
      description: _descriptionController.text.trim(),
      location: _locationController.text.trim(),
      createdBy: user.id,
      requiredSkills: _selectedSkills,
      requiredResources: _selectedResources,
    );

    if (event != null && mounted) {
      // Mostra dialog de sucesso com o c√≥digo do evento
      _showSuccessDialog(event.tag);
    }
  }

  void _showSuccessDialog(String eventTag) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        ),
        title: const Row(
          children: [
            Icon(Icons.check_circle, color: AppColors.success, size: 28),
            SizedBox(width: AppDimensions.spacingSm),
            Text('Evento Criado!'),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Seu evento foi criado com sucesso!',
              style: TextStyle(fontSize: AppDimensions.fontSizeMd),
            ),
            const SizedBox(height: AppDimensions.spacingMd),
            const Text(
              'C√≥digo do evento:',
              style: TextStyle(
                fontSize: AppDimensions.fontSizeMd,
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: AppDimensions.spacingSm),
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(AppDimensions.paddingMd),
              decoration: BoxDecoration(
                color: AppColors.primary.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(AppDimensions.radiusSm),
                border: Border.all(
                  color: AppColors.primary.withValues(alpha: 0.3),
                ),
              ),
              child: Text(
                eventTag,
                style: const TextStyle(
                  fontSize: AppDimensions.fontSizeXl,
                  fontWeight: FontWeight.bold,
                  color: AppColors.primary,
                  letterSpacing: 2,
                ),
                textAlign: TextAlign.center,
              ),
            ),
            const SizedBox(height: AppDimensions.spacingMd),
            const Text(
              'Compartilhe este c√≥digo com os volunt√°rios para que eles possam participar do evento.',
              style: TextStyle(
                fontSize: AppDimensions.fontSizeSm,
                color: AppColors.textSecondary,
              ),
            ),
          ],
        ),
        actions: [
          CustomButton.outline(
            text: 'Copiar C√≥digo',
            onPressed: () => _copyEventTag(eventTag),
          ),
          const SizedBox(height: AppDimensions.spacingMd),
          CustomButton(
            text: 'Continuar',
            onPressed: () {
              Navigator.of(context).pop(); // Fecha o dialog
              Navigator.of(context).pop(); // Volta para a tela anterior
            },
          ),
        ],
      ),
    );
  }

  void _copyEventTag(String tag) {
    // TODO: Implementar c√≥pia para clipboard
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('C√≥digo copiado para a √°rea de transfer√™ncia'),
        backgroundColor: AppColors.success,
      ),
    );
  }
}

## lib\presentation\screens\task\create_microtask_screen.dart <a id="create_microtask_screen_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `package:provider/provider.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/task_model.dart`
- `../../../data/models/event_model.dart`
- `../../controllers/auth_controller.dart`
- `../../controllers/task_controller.dart`
- `../../controllers/event_controller.dart`
- `../../widgets/common/custom_button.dart`
- `../../widgets/common/custom_text_field.dart`
- `../../widgets/common/custom_app_bar.dart`
- `../../widgets/common/loading_widget.dart`

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/task_model.dart';
import '../../../data/models/event_model.dart';
import '../../controllers/auth_controller.dart';
import '../../controllers/task_controller.dart';
import '../../controllers/event_controller.dart';
import '../../widgets/common/custom_button.dart';
import '../../widgets/common/custom_text_field.dart';
import '../../widgets/common/custom_app_bar.dart';
import '../../widgets/common/loading_widget.dart';

/// Tela para cria√ß√£o de microtasks
class CreateMicrotaskScreen extends StatefulWidget {
  final String eventId;

  const CreateMicrotaskScreen({super.key, required this.eventId});

  @override
  State<CreateMicrotaskScreen> createState() => _CreateMicrotaskScreenState();
}

class _CreateMicrotaskScreenState extends State<CreateMicrotaskScreen> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _maxVolunteersController = TextEditingController();
  final _notesController = TextEditingController();

  // Data e hora da microtask
  DateTime? _startDateTime;
  DateTime? _endDateTime;

  String? _selectedTaskId;
  TaskPriority _priority = TaskPriority.medium;
  final List<String> _selectedSkills = [];
  final List<String> _selectedResources = [];

  EventModel? _event;
  bool _isLoadingEvent = true;

  @override
  void initState() {
    super.initState();
    _loadEventDetails();
  }

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    _maxVolunteersController.dispose();
    _notesController.dispose();
    super.dispose();
  }

  Future<void> _loadEventDetails() async {
    try {
      final eventController = Provider.of<EventController>(
        context,
        listen: false,
      );
      final event = await eventController.loadEvent(widget.eventId);

      if (mounted) {
        setState(() {
          _event = event;
          _isLoadingEvent = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoadingEvent = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoadingEvent) {
      return const Scaffold(
        backgroundColor: AppColors.background,
        body: LoadingWidget(message: 'Carregando evento...'),
      );
    }

    if (_event == null) {
      return const Scaffold(
        backgroundColor: AppColors.background,
        appBar: CustomAppBar(title: 'Criar Microtask'),
        body: Center(child: Text('Erro ao carregar evento')),
      );
    }

    return Scaffold(
      backgroundColor: AppColors.background,
      appBar: const CustomAppBar(title: 'Criar Microtask'),
      body: Consumer2<AuthController, TaskController>(
        builder: (context, authController, taskController, child) {
          if (taskController.isLoading) {
            return const LoadingWidget(message: 'Criando microtask...');
          }

          final tasks = taskController.tasks;

          return SingleChildScrollView(
            padding: const EdgeInsets.all(AppDimensions.paddingLg),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Card(
                    elevation: 2,
                    child: Padding(
                      padding: const EdgeInsets.all(AppDimensions.paddingLg),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            children: [
                              const Icon(
                                Icons.checklist,
                                color: AppColors.secondary,
                              ),
                              const SizedBox(width: AppDimensions.spacingSm),
                              const Text(
                                'Nova Microtask',
                                style: TextStyle(
                                  fontSize: 18,
                                  fontWeight: FontWeight.bold,
                                  color: AppColors.textPrimary,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: AppDimensions.spacingLg),

                          // Sele√ß√£o da task pai
                          _buildTaskSelector(tasks),

                          const SizedBox(height: AppDimensions.spacingMd),

                          CustomTextField(
                            controller: _titleController,
                            label: 'Nome da Microtask',
                            hint: 'Ex: Montagem de Palco',
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Nome da microtask √© obrigat√≥rio';
                              }
                              if (value.trim().length < 3) {
                                return 'Nome deve ter pelo menos 3 caracteres';
                              }
                              if (value.trim().length > 100) {
                                return 'Nome deve ter no m√°ximo 100 caracteres';
                              }
                              return null;
                            },
                          ),

                          const SizedBox(height: AppDimensions.spacingMd),

                          CustomTextField(
                            controller: _descriptionController,
                            label: 'Descri√ß√£o Detalhada',
                            hint: 'Descreva exatamente o que deve ser feito...',
                            maxLines: 4,
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Descri√ß√£o √© obrigat√≥ria';
                              }
                              if (value.trim().length > 1000) {
                                return 'Descri√ß√£o deve ter no m√°ximo 1000 caracteres';
                              }
                              return null;
                            },
                          ),

                          const SizedBox(height: AppDimensions.spacingMd),

                          // Data e hora inicial
                          const Text(
                            'Data e Hora Inicial:',
                            style: TextStyle(
                              fontSize: AppDimensions.fontSizeMd,
                              fontWeight: FontWeight.w600,
                              color: AppColors.textPrimary,
                            ),
                          ),
                          const SizedBox(height: AppDimensions.spacingSm),

                          GestureDetector(
                            onTap: () => _selectStartDateTime(context),
                            child: Container(
                              width: double.infinity,
                              padding: const EdgeInsets.all(
                                AppDimensions.paddingMd,
                              ),
                              decoration: BoxDecoration(
                                border: Border.all(color: AppColors.border),
                                borderRadius: BorderRadius.circular(
                                  AppDimensions.radiusMd,
                                ),
                              ),
                              child: Text(
                                _startDateTime != null
                                    ? '${_startDateTime!.day.toString().padLeft(2, '0')}/${_startDateTime!.month.toString().padLeft(2, '0')}/${_startDateTime!.year} ${_startDateTime!.hour.toString().padLeft(2, '0')}:${_startDateTime!.minute.toString().padLeft(2, '0')}'
                                    : 'Selecionar data e hora inicial',
                                style: TextStyle(
                                  fontSize: AppDimensions.fontSizeMd,
                                  color: _startDateTime != null
                                      ? AppColors.textPrimary
                                      : AppColors.textSecondary,
                                ),
                              ),
                            ),
                          ),

                          const SizedBox(height: AppDimensions.spacingMd),

                          // Data e hora final
                          const Text(
                            'Data e Hora Final:',
                            style: TextStyle(
                              fontSize: AppDimensions.fontSizeMd,
                              fontWeight: FontWeight.w600,
                              color: AppColors.textPrimary,
                            ),
                          ),
                          const SizedBox(height: AppDimensions.spacingSm),

                          GestureDetector(
                            onTap: () => _selectEndDateTime(context),
                            child: Container(
                              width: double.infinity,
                              padding: const EdgeInsets.all(
                                AppDimensions.paddingMd,
                              ),
                              decoration: BoxDecoration(
                                border: Border.all(color: AppColors.border),
                                borderRadius: BorderRadius.circular(
                                  AppDimensions.radiusMd,
                                ),
                              ),
                              child: Text(
                                _endDateTime != null
                                    ? '${_endDateTime!.day.toString().padLeft(2, '0')}/${_endDateTime!.month.toString().padLeft(2, '0')}/${_endDateTime!.year} ${_endDateTime!.hour.toString().padLeft(2, '0')}:${_endDateTime!.minute.toString().padLeft(2, '0')}'
                                    : 'Selecionar data e hora final',
                                style: TextStyle(
                                  fontSize: AppDimensions.fontSizeMd,
                                  color: _endDateTime != null
                                      ? AppColors.textPrimary
                                      : AppColors.textSecondary,
                                ),
                              ),
                            ),
                          ),

                          const SizedBox(height: AppDimensions.spacingMd),

                          Row(
                            children: [
                              const SizedBox(width: AppDimensions.spacingMd),
                              Expanded(
                                child: CustomTextField(
                                  controller: _maxVolunteersController,
                                  label: 'M√°x. Volunt√°rios',
                                  hint: '3',
                                  keyboardType: TextInputType.number,
                                  validator: (value) {
                                    if (value == null || value.trim().isEmpty) {
                                      return 'N√∫mero m√°ximo √© obrigat√≥rio';
                                    }
                                    final max = int.tryParse(value.trim());
                                    if (max == null || max <= 0) {
                                      return 'Digite um n√∫mero v√°lido maior que 0';
                                    }
                                    return null;
                                  },
                                ),
                              ),
                            ],
                          ),

                          const SizedBox(height: AppDimensions.spacingMd),

                          _buildPrioritySelector(),

                          const SizedBox(height: AppDimensions.spacingMd),

                          _buildSkillsSelector(),

                          const SizedBox(height: AppDimensions.spacingMd),

                          _buildResourcesSelector(),

                          const SizedBox(height: AppDimensions.spacingMd),

                          CustomTextField(
                            controller: _notesController,
                            label: 'Observa√ß√µes (Opcional)',
                            hint: 'Informa√ß√µes adicionais...',
                            maxLines: 2,
                          ),

                          const SizedBox(height: AppDimensions.spacingLg),

                          SizedBox(
                            width: double.infinity,
                            child: CustomButton(
                              text: 'Criar Microtask',
                              onPressed: _selectedTaskId != null
                                  ? () => _handleCreateMicrotask(
                                      authController,
                                      taskController,
                                    )
                                  : null,
                              isLoading: taskController.isLoading,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildTaskSelector(List<TaskModel> tasks) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Task Pai',
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w500,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),

        if (tasks.isEmpty)
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(AppDimensions.paddingMd),
            decoration: BoxDecoration(
              color: AppColors.error.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: AppColors.error.withOpacity(0.3)),
            ),
            child: const Text(
              'Nenhuma task dispon√≠vel. Crie uma task primeiro.',
              style: TextStyle(color: AppColors.error),
            ),
          )
        else
          DropdownButtonFormField<String>(
            value: _selectedTaskId,
            decoration: const InputDecoration(
              hintText: 'Selecione uma task',
              border: OutlineInputBorder(),
            ),
            items: tasks.map((task) {
              return DropdownMenuItem<String>(
                value: task.id,
                child: Text(task.title, overflow: TextOverflow.ellipsis),
              );
            }).toList(),
            onChanged: (value) {
              setState(() {
                _selectedTaskId = value;
              });
            },
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Selecione uma task pai';
              }
              return null;
            },
          ),
      ],
    );
  }

  Widget _buildPrioritySelector() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Prioridade',
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w500,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),
        Row(
          children: TaskPriority.values.map((priority) {
            final isSelected = _priority == priority;
            return Expanded(
              child: Padding(
                padding: const EdgeInsets.only(right: AppDimensions.spacingSm),
                child: GestureDetector(
                  onTap: () => setState(() => _priority = priority),
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      vertical: AppDimensions.paddingSm,
                    ),
                    decoration: BoxDecoration(
                      color: isSelected
                          ? AppColors.primary
                          : Colors.transparent,
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(
                        color: isSelected
                            ? AppColors.primary
                            : AppColors.border,
                      ),
                    ),
                    child: Text(
                      _getPriorityText(priority),
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: isSelected
                            ? AppColors.textOnPrimary
                            : AppColors.textPrimary,
                        fontWeight: isSelected
                            ? FontWeight.bold
                            : FontWeight.normal,
                      ),
                    ),
                  ),
                ),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  Widget _buildSkillsSelector() {
    final eventSkills = _event?.requiredSkills ?? [];

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Habilidades Necess√°rias',
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w500,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),

        if (eventSkills.isEmpty)
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(AppDimensions.paddingMd),
            decoration: BoxDecoration(
              color: AppColors.warning.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: AppColors.warning.withOpacity(0.3)),
            ),
            child: const Text(
              'Nenhuma habilidade definida no evento.',
              style: TextStyle(color: AppColors.warning),
            ),
          )
        else
          Wrap(
            spacing: AppDimensions.spacingSm,
            runSpacing: AppDimensions.spacingSm,
            children: eventSkills.map((skill) {
              final isSelected = _selectedSkills.contains(skill);
              return GestureDetector(
                onTap: () => _toggleSkill(skill),
                child: Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: AppDimensions.paddingMd,
                    vertical: AppDimensions.paddingSm,
                  ),
                  decoration: BoxDecoration(
                    color: isSelected ? AppColors.primary : Colors.transparent,
                    borderRadius: BorderRadius.circular(20),
                    border: Border.all(
                      color: isSelected ? AppColors.primary : AppColors.border,
                    ),
                  ),
                  child: Text(
                    skill,
                    style: TextStyle(
                      color: isSelected
                          ? AppColors.textOnPrimary
                          : AppColors.textPrimary,
                      fontSize: 12,
                    ),
                  ),
                ),
              );
            }).toList(),
          ),
      ],
    );
  }

  Widget _buildResourcesSelector() {
    final eventResources = _event?.requiredResources ?? [];

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Recursos Necess√°rios',
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w500,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),

        if (eventResources.isEmpty)
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(AppDimensions.paddingMd),
            decoration: BoxDecoration(
              color: AppColors.warning.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: AppColors.warning.withOpacity(0.3)),
            ),
            child: const Text(
              'Nenhum recurso definido no evento.',
              style: TextStyle(color: AppColors.warning),
            ),
          )
        else
          Wrap(
            spacing: AppDimensions.spacingSm,
            runSpacing: AppDimensions.spacingSm,
            children: eventResources.map((resource) {
              final isSelected = _selectedResources.contains(resource);
              return GestureDetector(
                onTap: () => _toggleResource(resource),
                child: Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: AppDimensions.paddingMd,
                    vertical: AppDimensions.paddingSm,
                  ),
                  decoration: BoxDecoration(
                    color: isSelected
                        ? AppColors.secondary
                        : Colors.transparent,
                    borderRadius: BorderRadius.circular(20),
                    border: Border.all(
                      color: isSelected
                          ? AppColors.secondary
                          : AppColors.border,
                    ),
                  ),
                  child: Text(
                    resource,
                    style: TextStyle(
                      color: isSelected
                          ? AppColors.textOnPrimary
                          : AppColors.textPrimary,
                      fontSize: 12,
                    ),
                  ),
                ),
              );
            }).toList(),
          ),
      ],
    );
  }

  String _getPriorityText(TaskPriority priority) {
    switch (priority) {
      case TaskPriority.high:
        return 'Alta';
      case TaskPriority.medium:
        return 'M√©dia';
      case TaskPriority.low:
        return 'Baixa';
    }
  }

  void _toggleSkill(String skill) {
    setState(() {
      if (_selectedSkills.contains(skill)) {
        _selectedSkills.remove(skill);
      } else {
        _selectedSkills.add(skill);
      }
    });
  }

  void _toggleResource(String resource) {
    setState(() {
      if (_selectedResources.contains(resource)) {
        _selectedResources.remove(resource);
      } else {
        _selectedResources.add(resource);
      }
    });
  }

  Future<void> _selectStartDateTime(BuildContext context) async {
    final DateTime? pickedDate = await showDatePicker(
      context: context,
      initialDate: _startDateTime ?? DateTime.now(),
      firstDate: DateTime.now(),
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );

    if (pickedDate != null) {
      final TimeOfDay? pickedTime = await showTimePicker(
        context: context,
        initialTime: TimeOfDay.fromDateTime(_startDateTime ?? DateTime.now()),
      );

      if (pickedTime != null) {
        setState(() {
          _startDateTime = DateTime(
            pickedDate.year,
            pickedDate.month,
            pickedDate.day,
            pickedTime.hour,
            pickedTime.minute,
          );
        });
      }
    }
  }

  Future<void> _selectEndDateTime(BuildContext context) async {
    final DateTime? pickedDate = await showDatePicker(
      context: context,
      initialDate: _endDateTime ?? _startDateTime ?? DateTime.now(),
      firstDate: _startDateTime ?? DateTime.now(),
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );

    if (pickedDate != null) {
      final TimeOfDay? pickedTime = await showTimePicker(
        context: context,
        initialTime: TimeOfDay.fromDateTime(_endDateTime ?? DateTime.now()),
      );

      if (pickedTime != null) {
        setState(() {
          _endDateTime = DateTime(
            pickedDate.year,
            pickedDate.month,
            pickedDate.day,
            pickedTime.hour,
            pickedTime.minute,
          );
        });
      }
    }
  }

  Future<void> _handleCreateMicrotask(
    AuthController authController,
    TaskController taskController,
  ) async {
    if (!_formKey.currentState!.validate()) return;

    // Valida√ß√£o de data/hora
    if (_startDateTime == null || _endDateTime == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Selecione a data e hora inicial e final'),
          backgroundColor: AppColors.error,
        ),
      );
      return;
    }

    if (_startDateTime!.isAfter(_endDateTime!)) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Data/hora inicial deve ser anterior √† final'),
          backgroundColor: AppColors.error,
        ),
      );
      return;
    }

    final success = await taskController.createMicrotask(
      taskId: _selectedTaskId!,
      eventId: widget.eventId,
      title: _titleController.text.trim(),
      description: _descriptionController.text.trim(),
      requiredSkills: _selectedSkills,
      requiredResources: _selectedResources,
      startDateTime: _startDateTime,
      endDateTime: _endDateTime,
      priority: _priority.value,
      maxVolunteers: int.parse(_maxVolunteersController.text.trim()),
      createdBy: authController.currentUser!.id,
      notes: _notesController.text.trim().isNotEmpty
          ? _notesController.text.trim()
          : null,
    );

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Microtask criada com sucesso!'),
          backgroundColor: AppColors.success,
        ),
      );

      // Volta para a tela anterior
      Navigator.of(context).pop();
    } else if (mounted && taskController.errorMessage != null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(taskController.errorMessage!),
          backgroundColor: AppColors.error,
        ),
      );
    }
  }
}

## macos\Runner\Assets.xcassets\AppIcon.appiconset\Contents.json <a id="Contents_json"></a>

{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

## lib\presentation\screens\task\create_task_screen.dart <a id="create_task_screen_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `package:provider/provider.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/task_model.dart`
- `../../controllers/auth_controller.dart`
- `../../controllers/task_controller.dart`
- `../../widgets/common/custom_button.dart`
- `../../widgets/common/custom_text_field.dart`
- `../../widgets/common/custom_app_bar.dart`
- `../../widgets/common/loading_widget.dart`

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/task_model.dart';
import '../../controllers/auth_controller.dart';
import '../../controllers/task_controller.dart';
import '../../widgets/common/custom_button.dart';
import '../../widgets/common/custom_text_field.dart';
import '../../widgets/common/custom_app_bar.dart';
import '../../widgets/common/loading_widget.dart';

/// Tela para cria√ß√£o de tasks
class CreateTaskScreen extends StatefulWidget {
  final String eventId;

  const CreateTaskScreen({super.key, required this.eventId});

  @override
  State<CreateTaskScreen> createState() => _CreateTaskScreenState();
}

class _CreateTaskScreenState extends State<CreateTaskScreen> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  final _descriptionController = TextEditingController();
  TaskPriority _priority = TaskPriority.medium;

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.background,
      appBar: const CustomAppBar(title: 'Criar Task'),
      body: Consumer2<AuthController, TaskController>(
        builder: (context, authController, taskController, child) {
          if (taskController.isLoading) {
            return const LoadingWidget(message: 'Criando task...');
          }

          return SingleChildScrollView(
            padding: const EdgeInsets.all(AppDimensions.paddingLg),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Card(
                    elevation: 2,
                    child: Padding(
                      padding: const EdgeInsets.all(AppDimensions.paddingLg),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            children: [
                              const Icon(
                                Icons.task_alt,
                                color: AppColors.primary,
                              ),
                              const SizedBox(width: AppDimensions.spacingSm),
                              const Text(
                                'Nova Task',
                                style: TextStyle(
                                  fontSize: 18,
                                  fontWeight: FontWeight.bold,
                                  color: AppColors.textPrimary,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: AppDimensions.spacingLg),

                          CustomTextField(
                            controller: _titleController,
                            label: 'Nome da Task',
                            hint: 'Ex: Organiza√ß√£o do Local',
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Nome da task √© obrigat√≥rio';
                              }
                              if (value.trim().length < 3) {
                                return 'Nome deve ter pelo menos 3 caracteres';
                              }
                              if (value.trim().length > 100) {
                                return 'Nome deve ter no m√°ximo 100 caracteres';
                              }
                              return null;
                            },
                          ),

                          const SizedBox(height: AppDimensions.spacingMd),

                          CustomTextField(
                            controller: _descriptionController,
                            label: 'Descri√ß√£o',
                            hint: 'Descreva o objetivo desta task...',
                            maxLines: 4,
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Descri√ß√£o √© obrigat√≥ria';
                              }
                              if (value.trim().length > 500) {
                                return 'Descri√ß√£o deve ter no m√°ximo 500 caracteres';
                              }
                              return null;
                            },
                          ),

                          const SizedBox(height: AppDimensions.spacingMd),

                          _buildPrioritySelector(),

                          const SizedBox(height: AppDimensions.spacingLg),

                          SizedBox(
                            width: double.infinity,
                            child: CustomButton(
                              text: 'Criar Task',
                              onPressed: () => _handleCreateTask(
                                authController,
                                taskController,
                              ),
                              isLoading: taskController.isLoading,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),

                  const SizedBox(height: AppDimensions.spacingLg),

                  Card(
                    elevation: 1,
                    child: Padding(
                      padding: const EdgeInsets.all(AppDimensions.paddingMd),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            children: [
                              const Icon(
                                Icons.info_outline,
                                color: AppColors.secondary,
                              ),
                              const SizedBox(width: AppDimensions.spacingSm),
                              const Text(
                                'Sobre Tasks',
                                style: TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.w600,
                                  color: AppColors.textPrimary,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: AppDimensions.spacingSm),
                          const Text(
                            'Tasks s√£o organizadores de trabalho que agrupam microtasks relacionadas. '
                            'Ap√≥s criar uma task, voc√™ poder√° adicionar microtasks espec√≠ficas que '
                            'podem ser atribu√≠das a m√∫ltiplos volunt√°rios.',
                            style: TextStyle(
                              fontSize: 14,
                              color: AppColors.textSecondary,
                              height: 1.4,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildPrioritySelector() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Prioridade',
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w500,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),
        Row(
          children: TaskPriority.values.map((priority) {
            final isSelected = _priority == priority;
            return Expanded(
              child: Padding(
                padding: const EdgeInsets.only(right: AppDimensions.spacingSm),
                child: GestureDetector(
                  onTap: () => setState(() => _priority = priority),
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      vertical: AppDimensions.paddingSm,
                    ),
                    decoration: BoxDecoration(
                      color: isSelected
                          ? AppColors.primary
                          : Colors.transparent,
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(
                        color: isSelected
                            ? AppColors.primary
                            : AppColors.border,
                      ),
                    ),
                    child: Text(
                      _getPriorityText(priority),
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: isSelected
                            ? AppColors.textOnPrimary
                            : AppColors.textPrimary,
                        fontWeight: isSelected
                            ? FontWeight.bold
                            : FontWeight.normal,
                      ),
                    ),
                  ),
                ),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  String _getPriorityText(TaskPriority priority) {
    switch (priority) {
      case TaskPriority.high:
        return 'Alta';
      case TaskPriority.medium:
        return 'M√©dia';
      case TaskPriority.low:
        return 'Baixa';
    }
  }

  Future<void> _handleCreateTask(
    AuthController authController,
    TaskController taskController,
  ) async {
    if (!_formKey.currentState!.validate()) return;

    final success = await taskController.createTask(
      eventId: widget.eventId,
      title: _titleController.text.trim(),
      description: _descriptionController.text.trim(),
      priority: _priority,
      createdBy: authController.currentUser!.id,
    );

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Task criada com sucesso!'),
          backgroundColor: AppColors.success,
        ),
      );

      // Volta para a tela anterior
      Navigator.of(context).pop();
    } else if (mounted && taskController.errorMessage != null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(taskController.errorMessage!),
          backgroundColor: AppColors.error,
        ),
      );
    }
  }
}

## lib\presentation\screens\event\create_tasks_screen.dart <a id="create_tasks_screen_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `package:provider/provider.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/task_model.dart`
- `../../controllers/auth_controller.dart`
- `../../controllers/task_controller.dart`
- `../../widgets/common/custom_button.dart`
- `../../widgets/common/custom_text_field.dart`
- `../../widgets/common/loading_widget.dart`

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/task_model.dart';
import '../../controllers/auth_controller.dart';
import '../../controllers/task_controller.dart';
import '../../widgets/common/custom_button.dart';
import '../../widgets/common/custom_text_field.dart';
import '../../widgets/common/loading_widget.dart';

/// Tela para cria√ß√£o de tasks e microtasks
class CreateTasksScreen extends StatefulWidget {
  final String eventId;

  const CreateTasksScreen({super.key, required this.eventId});

  @override
  State<CreateTasksScreen> createState() => _CreateTasksScreenState();
}

class _CreateTasksScreenState extends State<CreateTasksScreen> {
  final _taskFormKey = GlobalKey<FormState>();
  final _microtaskFormKey = GlobalKey<FormState>();

  // Controllers para Task
  final _taskTitleController = TextEditingController();
  final _taskDescriptionController = TextEditingController();
  TaskPriority _taskPriority = TaskPriority.medium;

  // Controllers para Microtask
  final _microtaskTitleController = TextEditingController();
  final _microtaskDescriptionController = TextEditingController();
  final _maxVolunteersController = TextEditingController();
  final _notesController = TextEditingController();

  // Data e hora da microtask
  DateTime? _startDateTime;
  DateTime? _endDateTime;

  String? _selectedTaskId;
  TaskPriority _microtaskPriority = TaskPriority.medium;
  final List<String> _selectedSkills = [];
  final List<String> _selectedResources = [];

  // Lista de habilidades pr√©-definidas
  final List<String> _predefinedSkills = [
    'Organiza√ß√£o',
    'Comunica√ß√£o',
    'Lideran√ßa',
    'Trabalho em Equipe',
    'Criatividade',
    'Planejamento',
    'Montagem',
    'Limpeza',
    'Cozinha',
    'Atendimento',
    'Vendas',
    'Marketing',
    'Design',
    'Fotografia',
    'M√∫sica',
    'Dan√ßa',
    'Esportes',
    'Primeiros Socorros',
    'Seguran√ßa',
    'Transporte',
  ];

  // Lista de recursos pr√©-definidos
  final List<String> _predefinedResources = [
    'Carro',
    'Caminh√£o',
    'Equipamento de Som',
    'Projetor',
    'Notebook',
    'C√¢mera',
    'Microfone',
    'Mesa',
    'Cadeira',
    'Tenda',
    'Gerador',
    'Ferramentas',
    'Material de Limpeza',
    'Cozinha',
    'Refrigerador',
  ];

  @override
  void dispose() {
    _taskTitleController.dispose();
    _taskDescriptionController.dispose();
    _microtaskTitleController.dispose();
    _microtaskDescriptionController.dispose();
    _maxVolunteersController.dispose();
    _notesController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<AuthController, TaskController>(
      builder: (context, authController, taskController, child) {
        if (taskController.isLoading) {
          return const LoadingWidget(message: 'Processando...');
        }

        return SingleChildScrollView(
          padding: const EdgeInsets.all(AppDimensions.paddingLg),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildTaskSection(authController, taskController),
              const SizedBox(height: AppDimensions.spacingXl),
              _buildMicrotaskSection(authController, taskController),
            ],
          ),
        );
      },
    );
  }

  Widget _buildTaskSection(
    AuthController authController,
    TaskController taskController,
  ) {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(AppDimensions.paddingLg),
        child: Form(
          key: _taskFormKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  const Icon(Icons.task_alt, color: AppColors.primary),
                  const SizedBox(width: AppDimensions.spacingSm),
                  const Text(
                    'Criar Task',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      color: AppColors.textPrimary,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: AppDimensions.spacingMd),

              CustomTextField(
                controller: _taskTitleController,
                label: 'Nome da Task',
                hint: 'Ex: Organiza√ß√£o do Local',
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Nome da task √© obrigat√≥rio';
                  }
                  if (value.trim().length < 3) {
                    return 'Nome deve ter pelo menos 3 caracteres';
                  }
                  if (value.trim().length > 100) {
                    return 'Nome deve ter no m√°ximo 100 caracteres';
                  }
                  return null;
                },
              ),

              const SizedBox(height: AppDimensions.spacingMd),

              CustomTextField(
                controller: _taskDescriptionController,
                label: 'Descri√ß√£o',
                hint: 'Descreva o objetivo desta task...',
                maxLines: 3,
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Descri√ß√£o √© obrigat√≥ria';
                  }
                  if (value.trim().length > 500) {
                    return 'Descri√ß√£o deve ter no m√°ximo 500 caracteres';
                  }
                  return null;
                },
              ),

              const SizedBox(height: AppDimensions.spacingMd),

              _buildPrioritySelector(
                'Prioridade da Task',
                _taskPriority,
                (priority) => setState(() => _taskPriority = priority),
              ),

              const SizedBox(height: AppDimensions.spacingLg),

              SizedBox(
                width: double.infinity,
                child: CustomButton(
                  text: 'Criar Task',
                  onPressed: () =>
                      _handleCreateTask(authController, taskController),
                  isLoading: taskController.isLoading,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMicrotaskSection(
    AuthController authController,
    TaskController taskController,
  ) {
    final tasks = taskController.tasks;

    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(AppDimensions.paddingLg),
        child: Form(
          key: _microtaskFormKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  const Icon(Icons.checklist, color: AppColors.secondary),
                  const SizedBox(width: AppDimensions.spacingSm),
                  const Text(
                    'Criar Microtask',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      color: AppColors.textPrimary,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: AppDimensions.spacingMd),

              // Sele√ß√£o da task pai
              _buildTaskSelector(tasks),

              const SizedBox(height: AppDimensions.spacingMd),

              CustomTextField(
                controller: _microtaskTitleController,
                label: 'Nome da Microtask',
                hint: 'Ex: Montagem de Palco',
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Nome da microtask √© obrigat√≥rio';
                  }
                  if (value.trim().length < 3) {
                    return 'Nome deve ter pelo menos 3 caracteres';
                  }
                  if (value.trim().length > 100) {
                    return 'Nome deve ter no m√°ximo 100 caracteres';
                  }
                  return null;
                },
              ),

              const SizedBox(height: AppDimensions.spacingMd),

              CustomTextField(
                controller: _microtaskDescriptionController,
                label: 'Descri√ß√£o Detalhada',
                hint: 'Descreva exatamente o que deve ser feito...',
                maxLines: 4,
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Descri√ß√£o √© obrigat√≥ria';
                  }
                  if (value.trim().length > 1000) {
                    return 'Descri√ß√£o deve ter no m√°ximo 1000 caracteres';
                  }
                  return null;
                },
              ),

              const SizedBox(height: AppDimensions.spacingMd),

              // Data e hora inicial
              const Text(
                'Data e Hora Inicial:',
                style: TextStyle(
                  fontSize: AppDimensions.fontSizeMd,
                  fontWeight: FontWeight.w600,
                  color: AppColors.textPrimary,
                ),
              ),
              const SizedBox(height: AppDimensions.spacingSm),

              GestureDetector(
                onTap: () => _selectStartDateTime(context),
                child: Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(AppDimensions.paddingMd),
                  decoration: BoxDecoration(
                    border: Border.all(color: AppColors.border),
                    borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
                  ),
                  child: Text(
                    _startDateTime != null
                        ? '${_startDateTime!.day.toString().padLeft(2, '0')}/${_startDateTime!.month.toString().padLeft(2, '0')}/${_startDateTime!.year} ${_startDateTime!.hour.toString().padLeft(2, '0')}:${_startDateTime!.minute.toString().padLeft(2, '0')}'
                        : 'Selecionar data e hora inicial',
                    style: TextStyle(
                      fontSize: AppDimensions.fontSizeMd,
                      color: _startDateTime != null
                          ? AppColors.textPrimary
                          : AppColors.textSecondary,
                    ),
                  ),
                ),
              ),

              const SizedBox(height: AppDimensions.spacingMd),

              // Data e hora final
              const Text(
                'Data e Hora Final:',
                style: TextStyle(
                  fontSize: AppDimensions.fontSizeMd,
                  fontWeight: FontWeight.w600,
                  color: AppColors.textPrimary,
                ),
              ),
              const SizedBox(height: AppDimensions.spacingSm),

              GestureDetector(
                onTap: () => _selectEndDateTime(context),
                child: Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(AppDimensions.paddingMd),
                  decoration: BoxDecoration(
                    border: Border.all(color: AppColors.border),
                    borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
                  ),
                  child: Text(
                    _endDateTime != null
                        ? '${_endDateTime!.day.toString().padLeft(2, '0')}/${_endDateTime!.month.toString().padLeft(2, '0')}/${_endDateTime!.year} ${_endDateTime!.hour.toString().padLeft(2, '0')}:${_endDateTime!.minute.toString().padLeft(2, '0')}'
                        : 'Selecionar data e hora final',
                    style: TextStyle(
                      fontSize: AppDimensions.fontSizeMd,
                      color: _endDateTime != null
                          ? AppColors.textPrimary
                          : AppColors.textSecondary,
                    ),
                  ),
                ),
              ),

              const SizedBox(height: AppDimensions.spacingMd),

              Row(
                children: [
                  const SizedBox(width: AppDimensions.spacingMd),
                  Expanded(
                    child: CustomTextField(
                      controller: _maxVolunteersController,
                      label: 'M√°x. Volunt√°rios',
                      hint: '3',
                      keyboardType: TextInputType.number,
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return 'N√∫mero m√°ximo √© obrigat√≥rio';
                        }
                        final max = int.tryParse(value.trim());
                        if (max == null || max <= 0) {
                          return 'Digite um n√∫mero v√°lido maior que 0';
                        }
                        return null;
                      },
                    ),
                  ),
                ],
              ),

              const SizedBox(height: AppDimensions.spacingMd),

              _buildPrioritySelector(
                'Prioridade da Microtask',
                _microtaskPriority,
                (priority) => setState(() => _microtaskPriority = priority),
              ),

              const SizedBox(height: AppDimensions.spacingMd),

              _buildSkillsSelector(),

              const SizedBox(height: AppDimensions.spacingMd),

              _buildResourcesSelector(),

              const SizedBox(height: AppDimensions.spacingMd),

              CustomTextField(
                controller: _notesController,
                label: 'Observa√ß√µes (Opcional)',
                hint: 'Informa√ß√µes adicionais...',
                maxLines: 2,
              ),

              const SizedBox(height: AppDimensions.spacingLg),

              SizedBox(
                width: double.infinity,
                child: CustomButton(
                  text: 'Criar Microtask',
                  onPressed: _selectedTaskId != null
                      ? () => _handleCreateMicrotask(
                          authController,
                          taskController,
                        )
                      : null,
                  isLoading: taskController.isLoading,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTaskSelector(List<TaskModel> tasks) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Task Pai',
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w500,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),

        if (tasks.isEmpty)
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(AppDimensions.paddingMd),
            decoration: BoxDecoration(
              color: AppColors.error.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: AppColors.error.withOpacity(0.3)),
            ),
            child: const Text(
              'Nenhuma task dispon√≠vel. Crie uma task primeiro.',
              style: TextStyle(color: AppColors.error),
            ),
          )
        else
          DropdownButtonFormField<String>(
            value: _selectedTaskId,
            decoration: const InputDecoration(
              hintText: 'Selecione uma task',
              border: OutlineInputBorder(),
            ),
            items: tasks.map((task) {
              return DropdownMenuItem<String>(
                value: task.id,
                child: Text(task.title, overflow: TextOverflow.ellipsis),
              );
            }).toList(),
            onChanged: (value) {
              setState(() {
                _selectedTaskId = value;
              });
            },
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Selecione uma task pai';
              }
              return null;
            },
          ),
      ],
    );
  }

  Widget _buildPrioritySelector(
    String title,
    TaskPriority currentPriority,
    Function(TaskPriority) onChanged,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w500,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),
        Row(
          children: TaskPriority.values.map((priority) {
            final isSelected = currentPriority == priority;
            return Expanded(
              child: Padding(
                padding: const EdgeInsets.only(right: AppDimensions.spacingSm),
                child: GestureDetector(
                  onTap: () => onChanged(priority),
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      vertical: AppDimensions.paddingSm,
                    ),
                    decoration: BoxDecoration(
                      color: isSelected
                          ? AppColors.primary
                          : Colors.transparent,
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(
                        color: isSelected
                            ? AppColors.primary
                            : AppColors.border,
                      ),
                    ),
                    child: Text(
                      _getPriorityText(priority),
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: isSelected
                            ? AppColors.textOnPrimary
                            : AppColors.textPrimary,
                        fontWeight: isSelected
                            ? FontWeight.bold
                            : FontWeight.normal,
                      ),
                    ),
                  ),
                ),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  Widget _buildSkillsSelector() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Habilidades Necess√°rias',
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w500,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),
        Wrap(
          spacing: AppDimensions.spacingSm,
          runSpacing: AppDimensions.spacingSm,
          children: _predefinedSkills.map((skill) {
            final isSelected = _selectedSkills.contains(skill);
            return GestureDetector(
              onTap: () => _toggleSkill(skill),
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppDimensions.paddingMd,
                  vertical: AppDimensions.paddingSm,
                ),
                decoration: BoxDecoration(
                  color: isSelected ? AppColors.primary : Colors.transparent,
                  borderRadius: BorderRadius.circular(20),
                  border: Border.all(
                    color: isSelected ? AppColors.primary : AppColors.border,
                  ),
                ),
                child: Text(
                  skill,
                  style: TextStyle(
                    color: isSelected
                        ? AppColors.textOnPrimary
                        : AppColors.textPrimary,
                    fontSize: 12,
                  ),
                ),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  Widget _buildResourcesSelector() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Recursos Necess√°rios',
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w500,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),
        Wrap(
          spacing: AppDimensions.spacingSm,
          runSpacing: AppDimensions.spacingSm,
          children: _predefinedResources.map((resource) {
            final isSelected = _selectedResources.contains(resource);
            return GestureDetector(
              onTap: () => _toggleResource(resource),
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppDimensions.paddingMd,
                  vertical: AppDimensions.paddingSm,
                ),
                decoration: BoxDecoration(
                  color: isSelected ? AppColors.secondary : Colors.transparent,
                  borderRadius: BorderRadius.circular(20),
                  border: Border.all(
                    color: isSelected ? AppColors.secondary : AppColors.border,
                  ),
                ),
                child: Text(
                  resource,
                  style: TextStyle(
                    color: isSelected
                        ? AppColors.textOnPrimary
                        : AppColors.textPrimary,
                    fontSize: 12,
                  ),
                ),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  String _getPriorityText(TaskPriority priority) {
    switch (priority) {
      case TaskPriority.high:
        return 'Alta';
      case TaskPriority.medium:
        return 'M√©dia';
      case TaskPriority.low:
        return 'Baixa';
    }
  }

  void _toggleSkill(String skill) {
    setState(() {
      if (_selectedSkills.contains(skill)) {
        _selectedSkills.remove(skill);
      } else {
        _selectedSkills.add(skill);
      }
    });
  }

  void _toggleResource(String resource) {
    setState(() {
      if (_selectedResources.contains(resource)) {
        _selectedResources.remove(resource);
      } else {
        _selectedResources.add(resource);
      }
    });
  }

  Future<void> _handleCreateTask(
    AuthController authController,
    TaskController taskController,
  ) async {
    if (!_taskFormKey.currentState!.validate()) return;

    final success = await taskController.createTask(
      eventId: widget.eventId,
      title: _taskTitleController.text.trim(),
      description: _taskDescriptionController.text.trim(),
      priority: _taskPriority,
      createdBy: authController.currentUser!.id,
    );

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Task criada com sucesso!'),
          backgroundColor: AppColors.success,
        ),
      );

      // Limpa o formul√°rio
      _taskTitleController.clear();
      _taskDescriptionController.clear();
      setState(() {
        _taskPriority = TaskPriority.medium;
      });
    } else if (mounted && taskController.errorMessage != null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(taskController.errorMessage!),
          backgroundColor: AppColors.error,
        ),
      );
    }
  }

  Future<void> _selectStartDateTime(BuildContext context) async {
    final DateTime? pickedDate = await showDatePicker(
      context: context,
      initialDate: _startDateTime ?? DateTime.now(),
      firstDate: DateTime.now(),
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );

    if (pickedDate != null) {
      final TimeOfDay? pickedTime = await showTimePicker(
        context: context,
        initialTime: TimeOfDay.fromDateTime(_startDateTime ?? DateTime.now()),
      );

      if (pickedTime != null) {
        setState(() {
          _startDateTime = DateTime(
            pickedDate.year,
            pickedDate.month,
            pickedDate.day,
            pickedTime.hour,
            pickedTime.minute,
          );
        });
      }
    }
  }

  Future<void> _selectEndDateTime(BuildContext context) async {
    final DateTime? pickedDate = await showDatePicker(
      context: context,
      initialDate: _endDateTime ?? _startDateTime ?? DateTime.now(),
      firstDate: _startDateTime ?? DateTime.now(),
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );

    if (pickedDate != null) {
      final TimeOfDay? pickedTime = await showTimePicker(
        context: context,
        initialTime: TimeOfDay.fromDateTime(_endDateTime ?? DateTime.now()),
      );

      if (pickedTime != null) {
        setState(() {
          _endDateTime = DateTime(
            pickedDate.year,
            pickedDate.month,
            pickedDate.day,
            pickedTime.hour,
            pickedTime.minute,
          );
        });
      }
    }
  }

  Future<void> _handleCreateMicrotask(
    AuthController authController,
    TaskController taskController,
  ) async {
    if (!_microtaskFormKey.currentState!.validate()) return;

    // Valida√ß√£o de data/hora
    if (_startDateTime == null || _endDateTime == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Selecione a data e hora inicial e final'),
          backgroundColor: AppColors.error,
        ),
      );
      return;
    }

    if (_startDateTime!.isAfter(_endDateTime!)) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Data/hora inicial deve ser anterior √† final'),
          backgroundColor: AppColors.error,
        ),
      );
      return;
    }

    final success = await taskController.createMicrotask(
      taskId: _selectedTaskId!,
      eventId: widget.eventId,
      title: _microtaskTitleController.text.trim(),
      description: _microtaskDescriptionController.text.trim(),
      requiredSkills: _selectedSkills,
      requiredResources: _selectedResources,
      startDateTime: _startDateTime,
      endDateTime: _endDateTime,
      priority: _microtaskPriority.value,
      maxVolunteers: int.parse(_maxVolunteersController.text.trim()),
      createdBy: authController.currentUser!.id,
      notes: _notesController.text.trim().isNotEmpty
          ? _notesController.text.trim()
          : null,
    );

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Microtask criada com sucesso!'),
          backgroundColor: AppColors.success,
        ),
      );

      // Limpa o formul√°rio
      _microtaskTitleController.clear();
      _microtaskDescriptionController.clear();
      _maxVolunteersController.clear();
      _notesController.clear();
      setState(() {
        _selectedTaskId = null;
        _microtaskPriority = TaskPriority.medium;
        _selectedSkills.clear();
        _selectedResources.clear();
        _startDateTime = null;
        _endDateTime = null;
      });
    } else if (mounted && taskController.errorMessage != null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(taskController.errorMessage!),
          backgroundColor: AppColors.error,
        ),
      );
    }
  }
}

## lib\presentation\widgets\common\custom_app_bar.dart <a id="custom_app_bar_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';

/// AppBar customizada para o aplicativo
class CustomAppBar extends StatelessWidget implements PreferredSizeWidget {
  final String title;
  final List<Widget>? actions;
  final Widget? leading;
  final bool centerTitle;
  final Color? backgroundColor;
  final Color? foregroundColor;
  final double? elevation;
  final bool automaticallyImplyLeading;
  final PreferredSizeWidget? bottom;
  final VoidCallback? onBackPressed;
  final IconData? backIcon;

  const CustomAppBar({
    super.key,
    required this.title,
    this.actions,
    this.leading,
    this.centerTitle = true,
    this.backgroundColor,
    this.foregroundColor,
    this.elevation,
    this.automaticallyImplyLeading = true,
    this.bottom,
    this.onBackPressed,
    this.backIcon,
  });

  @override
  Widget build(BuildContext context) {
    return AppBar(
      title: Text(
        title,
        style: TextStyle(
          fontSize: 18,
          fontWeight: FontWeight.w600,
          color: foregroundColor ?? AppColors.textOnPrimary,
        ),
      ),
      centerTitle: centerTitle,
      backgroundColor: backgroundColor ?? AppColors.primary,
      foregroundColor: foregroundColor ?? AppColors.textOnPrimary,
      elevation: elevation ?? 2,
      automaticallyImplyLeading: automaticallyImplyLeading,
      leading: leading ?? (automaticallyImplyLeading && Navigator.canPop(context)
          ? IconButton(
              icon: Icon(backIcon ?? Icons.arrow_back),
              onPressed: onBackPressed ?? () => Navigator.pop(context),
            )
          : null),
      actions: actions,
      bottom: bottom,
    );
  }

  @override
  Size get preferredSize => Size.fromHeight(
        kToolbarHeight + (bottom?.preferredSize.height ?? 0),
      );
}

/// AppBar com gradiente
class GradientAppBar extends StatelessWidget implements PreferredSizeWidget {
  final String title;
  final List<Widget>? actions;
  final Widget? leading;
  final bool centerTitle;
  final List<Color>? gradientColors;
  final double? elevation;
  final bool automaticallyImplyLeading;
  final PreferredSizeWidget? bottom;
  final VoidCallback? onBackPressed;

  const GradientAppBar({
    super.key,
    required this.title,
    this.actions,
    this.leading,
    this.centerTitle = true,
    this.gradientColors,
    this.elevation,
    this.automaticallyImplyLeading = true,
    this.bottom,
    this.onBackPressed,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: gradientColors ?? [
            AppColors.primary,
            AppColors.secondary,
          ],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
      ),
      child: AppBar(
        title: Text(
          title,
          style: const TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.w600,
            color: AppColors.textOnPrimary,
          ),
        ),
        centerTitle: centerTitle,
        backgroundColor: Colors.transparent,
        foregroundColor: AppColors.textOnPrimary,
        elevation: elevation ?? 0,
        automaticallyImplyLeading: automaticallyImplyLeading,
        leading: leading ?? (automaticallyImplyLeading && Navigator.canPop(context)
            ? IconButton(
                icon: const Icon(Icons.arrow_back),
                onPressed: onBackPressed ?? () => Navigator.pop(context),
              )
            : null),
        actions: actions,
        bottom: bottom,
      ),
    );
  }

  @override
  Size get preferredSize => Size.fromHeight(
        kToolbarHeight + (bottom?.preferredSize.height ?? 0),
      );
}

/// AppBar com busca
class SearchAppBar extends StatefulWidget implements PreferredSizeWidget {
  final String title;
  final String hintText;
  final Function(String) onSearchChanged;
  final List<Widget>? actions;
  final Widget? leading;
  final bool centerTitle;
  final Color? backgroundColor;
  final VoidCallback? onBackPressed;

  const SearchAppBar({
    super.key,
    required this.title,
    required this.hintText,
    required this.onSearchChanged,
    this.actions,
    this.leading,
    this.centerTitle = true,
    this.backgroundColor,
    this.onBackPressed,
  });

  @override
  State<SearchAppBar> createState() => _SearchAppBarState();

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}

class _SearchAppBarState extends State<SearchAppBar> {
  bool _isSearching = false;
  final TextEditingController _searchController = TextEditingController();

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AppBar(
      title: _isSearching
          ? TextField(
              controller: _searchController,
              autofocus: true,
              decoration: InputDecoration(
                hintText: widget.hintText,
                border: InputBorder.none,
                hintStyle: TextStyle(
                  color: AppColors.textOnPrimary.withOpacity(0.7),
                ),
              ),
              style: const TextStyle(
                color: AppColors.textOnPrimary,
                fontSize: 16,
              ),
              onChanged: widget.onSearchChanged,
            )
          : Text(
              widget.title,
              style: const TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.w600,
                color: AppColors.textOnPrimary,
              ),
            ),
      centerTitle: widget.centerTitle,
      backgroundColor: widget.backgroundColor ?? AppColors.primary,
      foregroundColor: AppColors.textOnPrimary,
      leading: widget.leading ?? (Navigator.canPop(context)
          ? IconButton(
              icon: const Icon(Icons.arrow_back),
              onPressed: widget.onBackPressed ?? () => Navigator.pop(context),
            )
          : null),
      actions: [
        IconButton(
          icon: Icon(_isSearching ? Icons.close : Icons.search),
          onPressed: () {
            setState(() {
              _isSearching = !_isSearching;
              if (!_isSearching) {
                _searchController.clear();
                widget.onSearchChanged('');
              }
            });
          },
        ),
        ...?widget.actions,
      ],
    );
  }
}

/// AppBar com tabs
class TabAppBar extends StatelessWidget implements PreferredSizeWidget {
  final String title;
  final List<Tab> tabs;
  final TabController? controller;
  final List<Widget>? actions;
  final Widget? leading;
  final bool centerTitle;
  final Color? backgroundColor;
  final VoidCallback? onBackPressed;

  const TabAppBar({
    super.key,
    required this.title,
    required this.tabs,
    this.controller,
    this.actions,
    this.leading,
    this.centerTitle = true,
    this.backgroundColor,
    this.onBackPressed,
  });

  @override
  Widget build(BuildContext context) {
    return AppBar(
      title: Text(
        title,
        style: const TextStyle(
          fontSize: 18,
          fontWeight: FontWeight.w600,
          color: AppColors.textOnPrimary,
        ),
      ),
      centerTitle: centerTitle,
      backgroundColor: backgroundColor ?? AppColors.primary,
      foregroundColor: AppColors.textOnPrimary,
      leading: leading ?? (Navigator.canPop(context)
          ? IconButton(
              icon: const Icon(Icons.arrow_back),
              onPressed: onBackPressed ?? () => Navigator.pop(context),
            )
          : null),
      actions: actions,
      bottom: TabBar(
        controller: controller,
        tabs: tabs,
        indicatorColor: AppColors.textOnPrimary,
        labelColor: AppColors.textOnPrimary,
        unselectedLabelColor: AppColors.textOnPrimary.withOpacity(0.7),
      ),
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight + kTextTabBarHeight);
}

## lib\presentation\widgets\common\custom_button.dart <a id="custom_button_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';

/// Tipos de bot√£o dispon√≠veis
enum CustomButtonType {
  primary,
  secondary,
  outline,
  text,
  google,
}

/// Widget de bot√£o personalizado seguindo o design system
class CustomButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed;
  final CustomButtonType type;
  final bool isLoading;
  final bool isFullWidth;
  final IconData? icon;
  final double? width;
  final double? height;
  final EdgeInsetsGeometry? padding;

  const CustomButton({
    super.key,
    required this.text,
    this.onPressed,
    this.type = CustomButtonType.primary,
    this.isLoading = false,
    this.isFullWidth = true,
    this.icon,
    this.width,
    this.height,
    this.padding,
  });

  /// Construtor para bot√£o prim√°rio
  const CustomButton.primary({
    super.key,
    required this.text,
    this.onPressed,
    this.isLoading = false,
    this.isFullWidth = true,
    this.icon,
    this.width,
    this.height,
    this.padding,
  }) : type = CustomButtonType.primary;

  /// Construtor para bot√£o secund√°rio
  const CustomButton.secondary({
    super.key,
    required this.text,
    this.onPressed,
    this.isLoading = false,
    this.isFullWidth = true,
    this.icon,
    this.width,
    this.height,
    this.padding,
  }) : type = CustomButtonType.secondary;

  /// Construtor para bot√£o outline
  const CustomButton.outline({
    super.key,
    required this.text,
    this.onPressed,
    this.isLoading = false,
    this.isFullWidth = true,
    this.icon,
    this.width,
    this.height,
    this.padding,
  }) : type = CustomButtonType.outline;

  /// Construtor para bot√£o de texto
  const CustomButton.text({
    super.key,
    required this.text,
    this.onPressed,
    this.isLoading = false,
    this.isFullWidth = false,
    this.icon,
    this.width,
    this.height,
    this.padding,
  }) : type = CustomButtonType.text;

  /// Construtor para bot√£o do Google
  const CustomButton.google({
    super.key,
    required this.text,
    this.onPressed,
    this.isLoading = false,
    this.isFullWidth = true,
    this.width,
    this.height,
    this.padding,
  }) : type = CustomButtonType.google,
       icon = null;

  @override
  Widget build(BuildContext context) {
    final buttonWidth = isFullWidth ? double.infinity : width;
    final buttonHeight = height ?? AppDimensions.buttonHeightMd;

    Widget button = _buildButton(context);

    if (buttonWidth != null) {
      button = SizedBox(
        width: buttonWidth,
        height: buttonHeight,
        child: button,
      );
    }

    return button;
  }

  Widget _buildButton(BuildContext context) {
    switch (type) {
      case CustomButtonType.primary:
        return _buildElevatedButton(context);
      case CustomButtonType.secondary:
        return _buildSecondaryButton(context);
      case CustomButtonType.outline:
        return _buildOutlinedButton(context);
      case CustomButtonType.text:
        return _buildTextButton(context);
      case CustomButtonType.google:
        return _buildGoogleButton(context);
    }
  }

  Widget _buildElevatedButton(BuildContext context) {
    return ElevatedButton(
      onPressed: isLoading ? null : onPressed,
      style: ElevatedButton.styleFrom(
        backgroundColor: AppColors.primary,
        foregroundColor: AppColors.textOnPrimary,
        disabledBackgroundColor: AppColors.disabled,
        elevation: AppDimensions.elevationSm,
        padding: padding ?? const EdgeInsets.symmetric(
          horizontal: AppDimensions.paddingLg,
          vertical: AppDimensions.paddingMd,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        ),
      ),
      child: _buildButtonContent(),
    );
  }

  Widget _buildSecondaryButton(BuildContext context) {
    return ElevatedButton(
      onPressed: isLoading ? null : onPressed,
      style: ElevatedButton.styleFrom(
        backgroundColor: AppColors.secondary,
        foregroundColor: AppColors.textPrimary,
        disabledBackgroundColor: AppColors.disabled,
        elevation: AppDimensions.elevationSm,
        padding: padding ?? const EdgeInsets.symmetric(
          horizontal: AppDimensions.paddingLg,
          vertical: AppDimensions.paddingMd,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        ),
      ),
      child: _buildButtonContent(),
    );
  }

  Widget _buildOutlinedButton(BuildContext context) {
    return OutlinedButton(
      onPressed: isLoading ? null : onPressed,
      style: OutlinedButton.styleFrom(
        foregroundColor: AppColors.primary,
        disabledForegroundColor: AppColors.disabled,
        side: BorderSide(
          color: onPressed != null ? AppColors.primary : AppColors.disabled,
          width: AppDimensions.borderWidthThin,
        ),
        padding: padding ?? const EdgeInsets.symmetric(
          horizontal: AppDimensions.paddingLg,
          vertical: AppDimensions.paddingMd,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        ),
      ),
      child: _buildButtonContent(),
    );
  }

  Widget _buildTextButton(BuildContext context) {
    return TextButton(
      onPressed: isLoading ? null : onPressed,
      style: TextButton.styleFrom(
        foregroundColor: AppColors.primary,
        disabledForegroundColor: AppColors.disabled,
        padding: padding ?? const EdgeInsets.symmetric(
          horizontal: AppDimensions.paddingMd,
          vertical: AppDimensions.paddingSm,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        ),
      ),
      child: _buildButtonContent(),
    );
  }

  Widget _buildGoogleButton(BuildContext context) {
    return ElevatedButton(
      onPressed: isLoading ? null : onPressed,
      style: ElevatedButton.styleFrom(
        backgroundColor: Colors.white,
        foregroundColor: AppColors.textPrimary,
        disabledBackgroundColor: AppColors.disabled,
        elevation: AppDimensions.elevationSm,
        side: const BorderSide(
          color: AppColors.border,
          width: AppDimensions.borderWidthThin,
        ),
        padding: padding ?? const EdgeInsets.symmetric(
          horizontal: AppDimensions.paddingLg,
          vertical: AppDimensions.paddingMd,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        ),
      ),
      child: _buildGoogleButtonContent(),
    );
  }

  Widget _buildButtonContent() {
    if (isLoading) {
      return const SizedBox(
        width: AppDimensions.iconSm,
        height: AppDimensions.iconSm,
        child: CircularProgressIndicator(
          strokeWidth: 2,
          valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
        ),
      );
    }

    if (icon != null) {
      return Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: AppDimensions.iconSm,
          ),
          const SizedBox(width: AppDimensions.spacingSm),
          Text(
            text,
            style: const TextStyle(
              fontSize: AppDimensions.fontSizeLg,
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      );
    }

    return Text(
      text,
      style: const TextStyle(
        fontSize: AppDimensions.fontSizeLg,
        fontWeight: FontWeight.w600,
      ),
    );
  }

  Widget _buildGoogleButtonContent() {
    if (isLoading) {
      return const SizedBox(
        width: AppDimensions.iconSm,
        height: AppDimensions.iconSm,
        child: CircularProgressIndicator(
          strokeWidth: 2,
          valueColor: AlwaysStoppedAnimation<Color>(AppColors.primary),
        ),
      );
    }

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        // √çcone do Google (pode ser substitu√≠do por um asset)
        Container(
          width: AppDimensions.iconSm,
          height: AppDimensions.iconSm,
          decoration: const BoxDecoration(
            color: AppColors.primary,
            shape: BoxShape.circle,
          ),
          child: const Icon(
            Icons.g_mobiledata,
            color: Colors.white,
            size: AppDimensions.iconSm,
          ),
        ),
        const SizedBox(width: AppDimensions.spacingMd),
        Text(
          text,
          style: const TextStyle(
            fontSize: AppDimensions.fontSizeLg,
            fontWeight: FontWeight.w600,
            color: AppColors.textPrimary,
          ),
        ),
      ],
    );
  }
}

## lib\presentation\widgets\common\custom_text_field.dart <a id="custom_text_field_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `package:flutter/services.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';

/// Widget de campo de texto personalizado seguindo o design system
class CustomTextField extends StatefulWidget {
  final String? label;
  final String? hint;
  final String? initialValue;
  final TextEditingController? controller;
  final String? Function(String?)? validator;
  final void Function(String)? onChanged;
  final void Function(String)? onSubmitted;
  final void Function()? onTap;
  final TextInputType keyboardType;
  final TextInputAction textInputAction;
  final bool obscureText;
  final bool enabled;
  final bool readOnly;
  final bool autofocus;
  final int? maxLines;
  final int? maxLength;
  final IconData? prefixIcon;
  final IconData? suffixIcon;
  final VoidCallback? onSuffixIconPressed;
  final List<TextInputFormatter>? inputFormatters;
  final FocusNode? focusNode;
  final EdgeInsetsGeometry? contentPadding;

  const CustomTextField({
    super.key,
    this.label,
    this.hint,
    this.initialValue,
    this.controller,
    this.validator,
    this.onChanged,
    this.onSubmitted,
    this.onTap,
    this.keyboardType = TextInputType.text,
    this.textInputAction = TextInputAction.next,
    this.obscureText = false,
    this.enabled = true,
    this.readOnly = false,
    this.autofocus = false,
    this.maxLines = 1,
    this.maxLength,
    this.prefixIcon,
    this.suffixIcon,
    this.onSuffixIconPressed,
    this.inputFormatters,
    this.focusNode,
    this.contentPadding,
  });

  /// Construtor para campo de email
  const CustomTextField.email({
    super.key,
    this.label = 'E-mail',
    this.hint = 'Digite seu e-mail',
    this.initialValue,
    this.controller,
    this.validator,
    this.onChanged,
    this.onSubmitted,
    this.onTap,
    this.enabled = true,
    this.readOnly = false,
    this.autofocus = false,
    this.focusNode,
    this.contentPadding,
  }) : keyboardType = TextInputType.emailAddress,
       textInputAction = TextInputAction.next,
       obscureText = false,
       maxLines = 1,
       maxLength = null,
       prefixIcon = Icons.email_outlined,
       suffixIcon = null,
       onSuffixIconPressed = null,
       inputFormatters = null;

  /// Construtor para campo de senha
  const CustomTextField.password({
    super.key,
    this.label = 'Senha',
    this.hint = 'Digite sua senha',
    this.initialValue,
    this.controller,
    this.validator,
    this.onChanged,
    this.onSubmitted,
    this.onTap,
    this.enabled = true,
    this.readOnly = false,
    this.autofocus = false,
    this.focusNode,
    this.contentPadding,
  }) : keyboardType = TextInputType.visiblePassword,
       textInputAction = TextInputAction.done,
       obscureText = true,
       maxLines = 1,
       maxLength = null,
       prefixIcon = Icons.lock_outlined,
       suffixIcon = null,
       onSuffixIconPressed = null,
       inputFormatters = null;

  /// Construtor para campo de nome
  const CustomTextField.name({
    super.key,
    this.label = 'Nome',
    this.hint = 'Digite seu nome',
    this.initialValue,
    this.controller,
    this.validator,
    this.onChanged,
    this.onSubmitted,
    this.onTap,
    this.enabled = true,
    this.readOnly = false,
    this.autofocus = false,
    this.focusNode,
    this.contentPadding,
  }) : keyboardType = TextInputType.name,
       textInputAction = TextInputAction.next,
       obscureText = false,
       maxLines = 1,
       maxLength = 50,
       prefixIcon = Icons.person_outlined,
       suffixIcon = null,
       onSuffixIconPressed = null,
       inputFormatters = null;

  @override
  State<CustomTextField> createState() => _CustomTextFieldState();
}

class _CustomTextFieldState extends State<CustomTextField> {
  late bool _obscureText;
  late TextEditingController _controller;
  bool _controllerCreatedInternally = false;

  @override
  void initState() {
    super.initState();
    _obscureText = widget.obscureText;

    if (widget.controller != null) {
      _controller = widget.controller!;
    } else {
      _controller = TextEditingController(text: widget.initialValue);
      _controllerCreatedInternally = true;
    }
  }

  @override
  void dispose() {
    if (_controllerCreatedInternally) {
      _controller.dispose();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (widget.label != null) ...[
          Text(
            widget.label!,
            style: const TextStyle(
              fontSize: AppDimensions.fontSizeMd,
              fontWeight: FontWeight.w500,
              color: AppColors.textPrimary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingSm),
        ],
        TextFormField(
          controller: _controller,
          validator: widget.validator,
          onChanged: widget.onChanged,
          onFieldSubmitted: widget.onSubmitted,
          onTap: widget.onTap,
          keyboardType: widget.keyboardType,
          textInputAction: widget.textInputAction,
          obscureText: _obscureText,
          enabled: widget.enabled,
          readOnly: widget.readOnly,
          autofocus: widget.autofocus,
          maxLines: widget.maxLines,
          maxLength: widget.maxLength,
          inputFormatters: widget.inputFormatters,
          focusNode: widget.focusNode,
          style: const TextStyle(
            fontSize: AppDimensions.fontSizeMd,
            color: AppColors.textPrimary,
          ),
          decoration: InputDecoration(
            hintText: widget.hint,
            hintStyle: const TextStyle(
              color: AppColors.textLight,
              fontSize: AppDimensions.fontSizeMd,
            ),
            prefixIcon: widget.prefixIcon != null
                ? Icon(
                    widget.prefixIcon,
                    color: AppColors.textSecondary,
                    size: AppDimensions.iconSm,
                  )
                : null,
            suffixIcon: _buildSuffixIcon(),
            filled: true,
            fillColor: widget.enabled ? AppColors.surface : AppColors.disabled,
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
              borderSide: const BorderSide(
                color: AppColors.border,
                width: AppDimensions.borderWidthThin,
              ),
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
              borderSide: const BorderSide(
                color: AppColors.border,
                width: AppDimensions.borderWidthThin,
              ),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
              borderSide: const BorderSide(
                color: AppColors.primary,
                width: AppDimensions.borderWidthMedium,
              ),
            ),
            errorBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
              borderSide: const BorderSide(
                color: AppColors.error,
                width: AppDimensions.borderWidthThin,
              ),
            ),
            focusedErrorBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
              borderSide: const BorderSide(
                color: AppColors.error,
                width: AppDimensions.borderWidthMedium,
              ),
            ),
            disabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
              borderSide: const BorderSide(
                color: AppColors.disabled,
                width: AppDimensions.borderWidthThin,
              ),
            ),
            contentPadding: widget.contentPadding ?? const EdgeInsets.symmetric(
              horizontal: AppDimensions.paddingMd,
              vertical: AppDimensions.paddingMd,
            ),
            counterStyle: const TextStyle(
              color: AppColors.textLight,
              fontSize: AppDimensions.fontSizeSm,
            ),
            errorStyle: const TextStyle(
              color: AppColors.error,
              fontSize: AppDimensions.fontSizeSm,
            ),
          ),
        ),
      ],
    );
  }

  Widget? _buildSuffixIcon() {
    // Se √© um campo de senha, mostra o √≠cone de visibilidade
    if (widget.obscureText) {
      return IconButton(
        icon: Icon(
          _obscureText ? Icons.visibility_outlined : Icons.visibility_off_outlined,
          color: AppColors.textSecondary,
          size: AppDimensions.iconSm,
        ),
        onPressed: () {
          setState(() {
            _obscureText = !_obscureText;
          });
        },
      );
    }

    // Se tem um √≠cone de sufixo personalizado
    if (widget.suffixIcon != null) {
      return IconButton(
        icon: Icon(
          widget.suffixIcon,
          color: AppColors.textSecondary,
          size: AppDimensions.iconSm,
        ),
        onPressed: widget.onSuffixIconPressed,
      );
    }

    return null;
  }
}

## lib\core\utils\date_helpers.dart <a id="date_helpers_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `package:intl/intl.dart`

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

/// Classe utilit√°ria para manipula√ß√£o de datas
class DateHelpers {
  /// Formatador para data completa (dd/MM/yyyy)
  static final DateFormat _dateFormatter = DateFormat('dd/MM/yyyy');

  /// Formatador para data e hora (dd/MM/yyyy HH:mm)
  static final DateFormat _dateTimeFormatter = DateFormat('dd/MM/yyyy HH:mm');

  /// Formatador para hora (HH:mm)
  static final DateFormat _timeFormatter = DateFormat('HH:mm');

  /// Formatador para data abreviada (dd/MM)
  static final DateFormat _shortDateFormatter = DateFormat('dd/MM');

  /// Formatador para m√™s e ano (MMM yyyy)
  static final DateFormat _monthYearFormatter = DateFormat('MMM yyyy', 'pt_BR');

  /// Converte DateTime para string no formato dd/MM/yyyy
  static String formatDate(DateTime date) {
    return _dateFormatter.format(date);
  }

  /// Converte DateTime para string no formato dd/MM/yyyy HH:mm
  static String formatDateTime(DateTime dateTime) {
    return _dateTimeFormatter.format(dateTime);
  }

  /// Converte DateTime para string no formato HH:mm
  static String formatTime(DateTime time) {
    return _timeFormatter.format(time);
  }

  /// Converte DateTime para string no formato dd/MM
  static String formatShortDate(DateTime date) {
    return _shortDateFormatter.format(date);
  }

  /// Converte DateTime para string no formato MMM yyyy
  static String formatMonthYear(DateTime date) {
    return _monthYearFormatter.format(date);
  }

  /// Converte string no formato dd/MM/yyyy para DateTime
  static DateTime? parseDate(String dateString) {
    try {
      return _dateFormatter.parse(dateString);
    } catch (e) {
      return null;
    }
  }

  /// Converte string no formato dd/MM/yyyy HH:mm para DateTime
  static DateTime? parseDateTime(String dateTimeString) {
    try {
      return _dateTimeFormatter.parse(dateTimeString);
    } catch (e) {
      return null;
    }
  }

  /// Converte string no formato HH:mm para TimeOfDay
  static TimeOfDay? parseTime(String timeString) {
    try {
      final parts = timeString.split(':');
      if (parts.length == 2) {
        final hour = int.parse(parts[0]);
        final minute = int.parse(parts[1]);
        return TimeOfDay(hour: hour, minute: minute);
      }
    } catch (e) {
      // Ignora erro de parsing
    }
    return null;
  }

  /// Converte TimeOfDay para string no formato HH:mm
  static String timeOfDayToString(TimeOfDay time) {
    final hour = time.hour.toString().padLeft(2, '0');
    final minute = time.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }

  /// Retorna a diferen√ßa em dias entre duas datas
  static int daysBetween(DateTime from, DateTime to) {
    from = DateTime(from.year, from.month, from.day);
    to = DateTime(to.year, to.month, to.day);
    return (to.difference(from).inHours / 24).round();
  }

  /// Retorna a diferen√ßa em horas entre dois DateTimes
  static double hoursBetween(DateTime from, DateTime to) {
    return to.difference(from).inMinutes / 60.0;
  }

  /// Verifica se uma data √© hoje
  static bool isToday(DateTime date) {
    final now = DateTime.now();
    return date.year == now.year &&
        date.month == now.month &&
        date.day == now.day;
  }

  /// Verifica se uma data √© amanh√£
  static bool isTomorrow(DateTime date) {
    final tomorrow = DateTime.now().add(const Duration(days: 1));
    return date.year == tomorrow.year &&
        date.month == tomorrow.month &&
        date.day == tomorrow.day;
  }

  /// Verifica se uma data √© ontem
  static bool isYesterday(DateTime date) {
    final yesterday = DateTime.now().subtract(const Duration(days: 1));
    return date.year == yesterday.year &&
        date.month == yesterday.month &&
        date.day == yesterday.day;
  }

  /// Retorna uma string relativa para a data (hoje, ontem, amanh√£, ou data formatada)
  static String getRelativeDateString(DateTime date) {
    if (isToday(date)) {
      return 'Hoje';
    } else if (isTomorrow(date)) {
      return 'Amanh√£';
    } else if (isYesterday(date)) {
      return 'Ontem';
    } else {
      return formatDate(date);
    }
  }

  /// Retorna o in√≠cio do dia (00:00:00)
  static DateTime startOfDay(DateTime date) {
    return DateTime(date.year, date.month, date.day);
  }

  /// Retorna o fim do dia (23:59:59.999)
  static DateTime endOfDay(DateTime date) {
    return DateTime(date.year, date.month, date.day, 23, 59, 59, 999);
  }

  /// Retorna o in√≠cio da semana (segunda-feira)
  static DateTime startOfWeek(DateTime date) {
    final daysFromMonday = date.weekday - 1;
    return startOfDay(date.subtract(Duration(days: daysFromMonday)));
  }

  /// Retorna o fim da semana (domingo)
  static DateTime endOfWeek(DateTime date) {
    final daysToSunday = 7 - date.weekday;
    return endOfDay(date.add(Duration(days: daysToSunday)));
  }

  /// Retorna o in√≠cio do m√™s
  static DateTime startOfMonth(DateTime date) {
    return DateTime(date.year, date.month, 1);
  }

  /// Retorna o fim do m√™s
  static DateTime endOfMonth(DateTime date) {
    return DateTime(date.year, date.month + 1, 0, 23, 59, 59, 999);
  }

  /// Converte um dia da semana em string para n√∫mero (1 = segunda, 7 = domingo)
  static int weekdayFromString(String weekday) {
    switch (weekday.toLowerCase()) {
      case 'monday':
      case 'segunda':
        return 1;
      case 'tuesday':
      case 'ter√ßa':
        return 2;
      case 'wednesday':
      case 'quarta':
        return 3;
      case 'thursday':
      case 'quinta':
        return 4;
      case 'friday':
      case 'sexta':
        return 5;
      case 'saturday':
      case 's√°bado':
        return 6;
      case 'sunday':
      case 'domingo':
        return 7;
      default:
        return 1;
    }
  }

  /// Converte um n√∫mero do dia da semana para string em portugu√™s
  static String weekdayToString(int weekday) {
    switch (weekday) {
      case 1:
        return 'Segunda-feira';
      case 2:
        return 'Ter√ßa-feira';
      case 3:
        return 'Quarta-feira';
      case 4:
        return 'Quinta-feira';
      case 5:
        return 'Sexta-feira';
      case 6:
        return 'S√°bado';
      case 7:
        return 'Domingo';
      default:
        return 'Segunda-feira';
    }
  }

  /// Converte um n√∫mero do dia da semana para string abreviada
  static String weekdayToShortString(int weekday) {
    switch (weekday) {
      case 1:
        return 'Seg';
      case 2:
        return 'Ter';
      case 3:
        return 'Qua';
      case 4:
        return 'Qui';
      case 5:
        return 'Sex';
      case 6:
        return 'S√°b';
      case 7:
        return 'Dom';
      default:
        return 'Seg';
    }
  }
}

## lib\core\utils\error_handler.dart <a id="error_handler_dart"></a>

### Dependencies

- `package:firebase_auth/firebase_auth.dart`
- `../exceptions/app_exceptions.dart`

import 'package:firebase_auth/firebase_auth.dart';
import '../exceptions/app_exceptions.dart';

/// Classe utilit√°ria para tratamento de erros
class ErrorHandler {
  ErrorHandler._();

  /// Converte exce√ß√µes do Firebase Auth em mensagens amig√°veis
  static String handleFirebaseAuthError(FirebaseAuthException error) {
    switch (error.code) {
      case 'user-not-found':
        return 'Usu√°rio n√£o encontrado. Verifique o e-mail informado.';
      case 'wrong-password':
        return 'Senha incorreta. Tente novamente.';
      case 'email-already-in-use':
        return 'Este e-mail j√° est√° sendo usado por outra conta.';
      case 'weak-password':
        return 'A senha √© muito fraca. Use pelo menos 6 caracteres.';
      case 'invalid-email':
        return 'E-mail inv√°lido. Verifique o formato do e-mail.';
      case 'user-disabled':
        return 'Esta conta foi desabilitada. Entre em contato com o suporte.';
      case 'too-many-requests':
        return 'Muitas tentativas de login. Tente novamente mais tarde.';
      case 'operation-not-allowed':
        return 'Opera√ß√£o n√£o permitida. Entre em contato com o suporte.';
      case 'invalid-credential':
        return 'Credenciais inv√°lidas. Verifique e-mail e senha.';
      case 'account-exists-with-different-credential':
        return 'J√° existe uma conta com este e-mail usando outro m√©todo de login.';
      case 'requires-recent-login':
        return 'Esta opera√ß√£o requer login recente. Fa√ßa login novamente.';
      case 'network-request-failed':
        return 'Erro de conex√£o. Verifique sua internet e tente novamente.';
      default:
        return 'Erro de autentica√ß√£o: ${error.message ?? 'Erro desconhecido'}';
    }
  }

  /// Converte exce√ß√µes do Firestore em mensagens amig√°veis
  static String handleFirestoreError(FirebaseException error) {
    switch (error.code) {
      case 'permission-denied':
        return 'Voc√™ n√£o tem permiss√£o para realizar esta opera√ß√£o.';
      case 'not-found':
        return 'Documento n√£o encontrado.';
      case 'already-exists':
        return 'Este documento j√° existe.';
      case 'resource-exhausted':
        return 'Limite de opera√ß√µes excedido. Tente novamente mais tarde.';
      case 'failed-precondition':
        return 'Opera√ß√£o n√£o pode ser realizada no estado atual.';
      case 'aborted':
        return 'Opera√ß√£o foi cancelada devido a conflito.';
      case 'out-of-range':
        return 'Par√¢metros fora do intervalo v√°lido.';
      case 'unimplemented':
        return 'Opera√ß√£o n√£o implementada.';
      case 'internal':
        return 'Erro interno do servidor. Tente novamente.';
      case 'unavailable':
        return 'Servi√ßo temporariamente indispon√≠vel. Tente novamente.';
      case 'data-loss':
        return 'Perda de dados detectada. Entre em contato com o suporte.';
      case 'unauthenticated':
        return 'Voc√™ precisa estar logado para realizar esta opera√ß√£o.';
      case 'deadline-exceeded':
        return 'Opera√ß√£o demorou muito para ser conclu√≠da. Tente novamente.';
      case 'cancelled':
        return 'Opera√ß√£o foi cancelada.';
      case 'invalid-argument':
        return 'Par√¢metros inv√°lidos fornecidos.';
      default:
        return 'Erro do banco de dados: ${error.message ?? 'Erro desconhecido'}';
    }
  }

  /// Converte exce√ß√µes personalizadas da aplica√ß√£o em mensagens amig√°veis
  static String handleAppException(AppException error) {
    switch (error.runtimeType) {
      case ValidationException:
        return error.message;
      case NotFoundException:
        return error.message;
      case UnauthorizedException:
        return error.message;
      case DatabaseException:
        return 'Erro de banco de dados. Tente novamente.';
      case NetworkException:
        return 'Erro de conex√£o. Verifique sua internet e tente novamente.';
      case StorageException:
        return 'Erro de armazenamento. Tente novamente.';
      case RepositoryException:
        return 'Erro interno. Tente novamente.';
      default:
        return error.message;
    }
  }

  /// M√©todo principal para tratar qualquer tipo de erro
  static String handleError(dynamic error) {
    if (error is FirebaseAuthException) {
      return handleFirebaseAuthError(error);
    } else if (error is FirebaseException) {
      return handleFirestoreError(error);
    } else if (error is AppException) {
      return handleAppException(error);
    } else if (error is Exception) {
      return 'Erro inesperado: ${error.toString()}';
    } else {
      return 'Erro desconhecido. Tente novamente.';
    }
  }

  /// Verifica se o erro √© relacionado √† rede
  static bool isNetworkError(dynamic error) {
    if (error is FirebaseAuthException) {
      return error.code == 'network-request-failed';
    } else if (error is FirebaseException) {
      return error.code == 'unavailable' || error.code == 'deadline-exceeded';
    } else if (error is NetworkException) {
      return true;
    }
    return false;
  }

  /// Verifica se o erro √© relacionado √† autentica√ß√£o
  static bool isAuthError(dynamic error) {
    if (error is FirebaseAuthException) {
      return true;
    } else if (error is FirebaseException) {
      return error.code == 'unauthenticated';
    } else if (error is UnauthorizedException) {
      return true;
    }
    return false;
  }

  /// Verifica se o erro √© relacionado √† valida√ß√£o
  static bool isValidationError(dynamic error) {
    return error is ValidationException ||
        (error is FirebaseException && error.code == 'invalid-argument');
  }

  /// Verifica se o erro √© tempor√°rio (pode ser resolvido tentando novamente)
  static bool isTemporaryError(dynamic error) {
    if (error is FirebaseAuthException) {
      return error.code == 'too-many-requests' ||
          error.code == 'network-request-failed';
    } else if (error is FirebaseException) {
      return error.code == 'unavailable' ||
          error.code == 'deadline-exceeded' ||
          error.code == 'resource-exhausted' ||
          error.code == 'aborted';
    } else if (error is NetworkException) {
      return true;
    }
    return false;
  }

  /// Gera sugest√µes de a√ß√£o baseadas no tipo de erro
  static List<String> getErrorSuggestions(dynamic error) {
    final suggestions = <String>[];

    if (isNetworkError(error)) {
      suggestions.addAll([
        'Verifique sua conex√£o com a internet',
        'Tente novamente em alguns segundos',
        'Verifique se o Wi-Fi est√° funcionando',
      ]);
    } else if (isAuthError(error)) {
      suggestions.addAll([
        'Fa√ßa login novamente',
        'Verifique suas credenciais',
        'Entre em contato com o suporte se o problema persistir',
      ]);
    } else if (isValidationError(error)) {
      suggestions.addAll([
        'Verifique os dados informados',
        'Certifique-se de preencher todos os campos obrigat√≥rios',
        'Verifique o formato dos dados',
      ]);
    } else if (isTemporaryError(error)) {
      suggestions.addAll([
        'Tente novamente em alguns minutos',
        'Verifique sua conex√£o',
        'Entre em contato com o suporte se o problema persistir',
      ]);
    } else {
      suggestions.addAll([
        'Tente novamente',
        'Reinicie o aplicativo se necess√°rio',
        'Entre em contato com o suporte se o problema persistir',
      ]);
    }

    return suggestions;
  }

  /// Registra o erro para an√°lise (pode ser expandido para usar servi√ßos como Crashlytics)
  static void logError(
    dynamic error, {
    StackTrace? stackTrace,
    Map<String, dynamic>? context,
  }) {
    // Por enquanto, apenas imprime no console
    // Em produ√ß√£o, isso deveria enviar para um servi√ßo de monitoramento
    print('ERROR: $error');
    if (stackTrace != null) {
      print('STACK TRACE: $stackTrace');
    }
    if (context != null) {
      print('CONTEXT: $context');
    }
  }

  /// Cria uma mensagem de erro formatada para exibi√ß√£o
  static String formatErrorMessage(dynamic error, {String? context}) {
    final message = handleError(error);

    if (context != null) {
      return '$context: $message';
    }

    return message;
  }

  /// Verifica se deve mostrar detalhes t√©cnicos do erro (apenas em desenvolvimento)
  static bool shouldShowTechnicalDetails() {
    // Em produ√ß√£o, isso deveria retornar false
    // Por enquanto, sempre mostra detalhes para facilitar o desenvolvimento
    return true;
  }

  /// Cria uma mensagem de erro com detalhes t√©cnicos (se apropriado)
  static String createDetailedErrorMessage(
    dynamic error, {
    String? userMessage,
  }) {
    final baseMessage = userMessage ?? handleError(error);

    if (shouldShowTechnicalDetails()) {
      return '$baseMessage\n\nDetalhes t√©cnicos: ${error.toString()}';
    }

    return baseMessage;
  }
}

## lib\presentation\widgets\common\error_message_widget.dart <a id="error_message_widget_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';

/// Widget para exibir mensagens de erro de forma consistente
class ErrorMessageWidget extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;
  final bool showRetryButton;
  final IconData? icon;
  final Color? backgroundColor;
  final Color? textColor;
  final Color? borderColor;

  const ErrorMessageWidget({
    super.key,
    required this.message,
    this.onRetry,
    this.showRetryButton = true,
    this.icon,
    this.backgroundColor,
    this.textColor,
    this.borderColor,
  });

  /// Factory para erro de rede
  factory ErrorMessageWidget.network({
    required String message,
    VoidCallback? onRetry,
  }) {
    return ErrorMessageWidget(
      message: message,
      onRetry: onRetry,
      icon: Icons.wifi_off,
      showRetryButton: true,
    );
  }

  /// Factory para erro de valida√ß√£o
  factory ErrorMessageWidget.validation({required String message}) {
    return ErrorMessageWidget(
      message: message,
      icon: Icons.warning,
      showRetryButton: false,
      backgroundColor: AppColors.warning.withValues(alpha: 0.1),
      textColor: AppColors.warning,
      borderColor: AppColors.warning.withValues(alpha: 0.3),
    );
  }

  /// Factory para erro de permiss√£o
  factory ErrorMessageWidget.permission({
    required String message,
    VoidCallback? onRetry,
  }) {
    return ErrorMessageWidget(
      message: message,
      onRetry: onRetry,
      icon: Icons.lock,
      showRetryButton: false,
      backgroundColor: AppColors.error.withValues(alpha: 0.1),
      textColor: AppColors.error,
      borderColor: AppColors.error.withValues(alpha: 0.3),
    );
  }

  /// Factory para erro gen√©rico
  factory ErrorMessageWidget.generic({
    required String message,
    VoidCallback? onRetry,
  }) {
    return ErrorMessageWidget(
      message: message,
      onRetry: onRetry,
      icon: Icons.error_outline,
      showRetryButton: true,
    );
  }

  @override
  Widget build(BuildContext context) {
    final effectiveBackgroundColor =
        backgroundColor ?? AppColors.error.withValues(alpha: 0.1);
    final effectiveTextColor = textColor ?? AppColors.error;
    final effectiveBorderColor =
        borderColor ?? AppColors.error.withValues(alpha: 0.3);

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(AppDimensions.paddingMd),
      decoration: BoxDecoration(
        color: effectiveBackgroundColor,
        borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        border: Border.all(color: effectiveBorderColor),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Icon(
                icon ?? Icons.error_outline,
                color: effectiveTextColor,
                size: 20,
              ),
              const SizedBox(width: AppDimensions.spacingSm),
              Expanded(
                child: Text(
                  message,
                  style: TextStyle(
                    color: effectiveTextColor,
                    fontSize: AppDimensions.fontSizeMd,
                  ),
                ),
              ),
            ],
          ),

          if (showRetryButton && onRetry != null) ...[
            const SizedBox(height: AppDimensions.spacingMd),
            SizedBox(
              width: double.infinity,
              child: OutlinedButton.icon(
                onPressed: onRetry,
                icon: const Icon(Icons.refresh),
                label: const Text('Tentar Novamente'),
                style: OutlinedButton.styleFrom(
                  foregroundColor: effectiveTextColor,
                  side: BorderSide(color: effectiveTextColor),
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }
}

/// Widget para exibir estado vazio
class EmptyStateWidget extends StatelessWidget {
  final String title;
  final String? subtitle;
  final IconData? icon;
  final Widget? action;

  const EmptyStateWidget({
    super.key,
    required this.title,
    this.subtitle,
    this.icon,
    this.action,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(AppDimensions.paddingLg),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon ?? Icons.inbox, size: 64, color: AppColors.textSecondary),
            const SizedBox(height: AppDimensions.spacingMd),
            Text(
              title,
              style: const TextStyle(
                fontSize: AppDimensions.fontSizeLg,
                fontWeight: FontWeight.w600,
                color: AppColors.textPrimary,
              ),
              textAlign: TextAlign.center,
            ),
            if (subtitle != null) ...[
              const SizedBox(height: AppDimensions.spacingSm),
              Text(
                subtitle!,
                style: const TextStyle(
                  fontSize: AppDimensions.fontSizeMd,
                  color: AppColors.textSecondary,
                ),
                textAlign: TextAlign.center,
              ),
            ],
            if (action != null) ...[
              const SizedBox(height: AppDimensions.spacingLg),
              action!,
            ],
          ],
        ),
      ),
    );
  }
}

/// Widget para exibir feedback de sucesso
class SuccessMessageWidget extends StatelessWidget {
  final String message;
  final VoidCallback? onDismiss;
  final bool showDismissButton;

  const SuccessMessageWidget({
    super.key,
    required this.message,
    this.onDismiss,
    this.showDismissButton = false,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(AppDimensions.paddingMd),
      decoration: BoxDecoration(
        color: AppColors.success.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        border: Border.all(color: AppColors.success.withValues(alpha: 0.3)),
      ),
      child: Row(
        children: [
          const Icon(Icons.check_circle, color: AppColors.success, size: 20),
          const SizedBox(width: AppDimensions.spacingSm),
          Expanded(
            child: Text(
              message,
              style: const TextStyle(
                color: AppColors.success,
                fontSize: AppDimensions.fontSizeMd,
              ),
            ),
          ),
          if (showDismissButton && onDismiss != null) ...[
            const SizedBox(width: AppDimensions.spacingSm),
            IconButton(
              onPressed: onDismiss,
              icon: const Icon(Icons.close, color: AppColors.success, size: 18),
              constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
              padding: EdgeInsets.zero,
            ),
          ],
        ],
      ),
    );
  }
}

/// Widget para exibir informa√ß√µes importantes
class InfoMessageWidget extends StatelessWidget {
  final String message;
  final VoidCallback? onDismiss;
  final bool showDismissButton;

  const InfoMessageWidget({
    super.key,
    required this.message,
    this.onDismiss,
    this.showDismissButton = false,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(AppDimensions.paddingMd),
      decoration: BoxDecoration(
        color: AppColors.info.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        border: Border.all(color: AppColors.info.withValues(alpha: 0.3)),
      ),
      child: Row(
        children: [
          const Icon(Icons.info, color: AppColors.info, size: 20),
          const SizedBox(width: AppDimensions.spacingSm),
          Expanded(
            child: Text(
              message,
              style: const TextStyle(
                color: AppColors.info,
                fontSize: AppDimensions.fontSizeMd,
              ),
            ),
          ),
          if (showDismissButton && onDismiss != null) ...[
            const SizedBox(width: AppDimensions.spacingSm),
            IconButton(
              onPressed: onDismiss,
              icon: const Icon(Icons.close, color: AppColors.info, size: 18),
              constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
              padding: EdgeInsets.zero,
            ),
          ],
        ],
      ),
    );
  }
}

## lib\presentation\widgets\common\error_widget.dart <a id="error_widget_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';

/// Widget customizado para exibir erros
class CustomErrorWidget extends StatelessWidget {
  final String message;
  final String? title;
  final IconData? icon;
  final VoidCallback? onRetry;
  final String? retryText;
  final bool showIcon;
  final Color? iconColor;
  final Color? textColor;
  final double? iconSize;

  const CustomErrorWidget({
    super.key,
    required this.message,
    this.title,
    this.icon,
    this.onRetry,
    this.retryText,
    this.showIcon = true,
    this.iconColor,
    this.textColor,
    this.iconSize,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(AppDimensions.paddingLg),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // √çcone de erro
            if (showIcon) ...[
              Icon(
                icon ?? Icons.error_outline,
                size: iconSize ?? 64,
                color: iconColor ?? AppColors.error,
              ),
              const SizedBox(height: AppDimensions.spacingLg),
            ],

            // T√≠tulo (opcional)
            if (title != null) ...[
              Text(
                title!,
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                  color: textColor ?? AppColors.textPrimary,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: AppDimensions.spacingMd),
            ],

            // Mensagem de erro
            Text(
              message,
              style: TextStyle(
                fontSize: 16,
                color: textColor ?? AppColors.textSecondary,
                height: 1.5,
              ),
              textAlign: TextAlign.center,
            ),

            // Bot√£o de retry (opcional)
            if (onRetry != null) ...[
              const SizedBox(height: AppDimensions.spacingLg),
              ElevatedButton.icon(
                onPressed: onRetry,
                icon: const Icon(Icons.refresh),
                label: Text(retryText ?? 'Tentar Novamente'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: AppColors.primary,
                  foregroundColor: AppColors.textOnPrimary,
                  padding: const EdgeInsets.symmetric(
                    horizontal: AppDimensions.paddingLg,
                    vertical: AppDimensions.paddingMd,
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

/// Widget de erro compacto para usar em cards ou listas
class CompactErrorWidget extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;
  final IconData? icon;
  final Color? color;

  const CompactErrorWidget({
    super.key,
    required this.message,
    this.onRetry,
    this.icon,
    this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(AppDimensions.paddingMd),
      decoration: BoxDecoration(
        color: (color ?? AppColors.error).withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: (color ?? AppColors.error).withOpacity(0.3),
        ),
      ),
      child: Row(
        children: [
          Icon(
            icon ?? Icons.warning_amber,
            color: color ?? AppColors.error,
            size: 20,
          ),
          const SizedBox(width: AppDimensions.spacingSm),
          Expanded(
            child: Text(
              message,
              style: TextStyle(
                fontSize: 14,
                color: color ?? AppColors.error,
              ),
            ),
          ),
          if (onRetry != null) ...[
            const SizedBox(width: AppDimensions.spacingSm),
            IconButton(
              onPressed: onRetry,
              icon: const Icon(Icons.refresh),
              color: color ?? AppColors.error,
              iconSize: 20,
            ),
          ],
        ],
      ),
    );
  }
}

/// Widget de erro para conex√£o de rede
class NetworkErrorWidget extends StatelessWidget {
  final VoidCallback? onRetry;
  final String? customMessage;

  const NetworkErrorWidget({
    super.key,
    this.onRetry,
    this.customMessage,
  });

  @override
  Widget build(BuildContext context) {
    return CustomErrorWidget(
      title: 'Sem Conex√£o',
      message: customMessage ??
          'Verifique sua conex√£o com a internet e tente novamente.',
      icon: Icons.wifi_off,
      iconColor: AppColors.warning,
      onRetry: onRetry,
      retryText: 'Tentar Novamente',
    );
  }
}

/// Widget de erro para dados n√£o encontrados
class NotFoundErrorWidget extends StatelessWidget {
  final String? title;
  final String? message;
  final VoidCallback? onAction;
  final String? actionText;
  final IconData? icon;

  const NotFoundErrorWidget({
    super.key,
    this.title,
    this.message,
    this.onAction,
    this.actionText,
    this.icon,
  });

  @override
  Widget build(BuildContext context) {
    return CustomErrorWidget(
      title: title ?? 'Nada Encontrado',
      message: message ?? 'N√£o foram encontrados dados para exibir.',
      icon: icon ?? Icons.search_off,
      iconColor: AppColors.textSecondary,
      onRetry: onAction,
      retryText: actionText,
    );
  }
}

/// Widget de erro para permiss√µes
class PermissionErrorWidget extends StatelessWidget {
  final String? message;
  final VoidCallback? onRequestPermission;

  const PermissionErrorWidget({
    super.key,
    this.message,
    this.onRequestPermission,
  });

  @override
  Widget build(BuildContext context) {
    return CustomErrorWidget(
      title: 'Permiss√£o Necess√°ria',
      message: message ??
          'Esta funcionalidade requer permiss√µes espec√≠ficas para funcionar.',
      icon: Icons.lock_outline,
      iconColor: AppColors.warning,
      onRetry: onRequestPermission,
      retryText: 'Conceder Permiss√£o',
    );
  }
}

/// Widget de erro gen√©rico com diferentes tipos
class ErrorDisplayWidget extends StatelessWidget {
  final ErrorType type;
  final String? customMessage;
  final VoidCallback? onAction;
  final String? actionText;

  const ErrorDisplayWidget({
    super.key,
    required this.type,
    this.customMessage,
    this.onAction,
    this.actionText,
  });

  @override
  Widget build(BuildContext context) {
    switch (type) {
      case ErrorType.network:
        return NetworkErrorWidget(
          onRetry: onAction,
          customMessage: customMessage,
        );
      case ErrorType.notFound:
        return NotFoundErrorWidget(
          message: customMessage,
          onAction: onAction,
          actionText: actionText,
        );
      case ErrorType.permission:
        return PermissionErrorWidget(
          message: customMessage,
          onRequestPermission: onAction,
        );
      case ErrorType.server:
        return CustomErrorWidget(
          title: 'Erro do Servidor',
          message: customMessage ?? 'Ocorreu um erro no servidor. Tente novamente.',
          icon: Icons.cloud_off,
          iconColor: AppColors.error,
          onRetry: onAction,
          retryText: actionText ?? 'Tentar Novamente',
        );
      case ErrorType.validation:
        return CompactErrorWidget(
          message: customMessage ?? 'Dados inv√°lidos fornecidos.',
          color: AppColors.warning,
          icon: Icons.warning_amber,
        );
      case ErrorType.generic:
      default:
        return CustomErrorWidget(
          message: customMessage ?? 'Ocorreu um erro inesperado.',
          onRetry: onAction,
          retryText: actionText,
        );
    }
  }
}

/// Tipos de erro suportados
enum ErrorType {
  network,
  notFound,
  permission,
  server,
  validation,
  generic,
}

## lib\presentation\widgets\event\event_card.dart <a id="event_card_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/event_model.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/event_model.dart';

/// Widget de card para exibir informa√ß√µes de um evento na lista
class EventCard extends StatelessWidget {
  final EventModel event;
  final VoidCallback? onTap;
  final String? currentUserId;

  const EventCard({
    super.key,
    required this.event,
    this.onTap,
    this.currentUserId,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: AppDimensions.elevationSm,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        child: Padding(
          padding: const EdgeInsets.all(AppDimensions.paddingMd),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header com nome e status
              Row(
                children: [
                  Expanded(
                    child: Text(
                      event.name,
                      style: const TextStyle(
                        fontSize: AppDimensions.fontSizeLg,
                        fontWeight: FontWeight.bold,
                        color: AppColors.textPrimary,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  const SizedBox(width: AppDimensions.spacingSm),
                  _buildStatusChip(),
                ],
              ),

              const SizedBox(height: AppDimensions.spacingSm),

              // Descri√ß√£o
              if (event.description.isNotEmpty) ...[
                Text(
                  event.shortDescription,
                  style: const TextStyle(
                    fontSize: AppDimensions.fontSizeMd,
                    color: AppColors.textSecondary,
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: AppDimensions.spacingSm),
              ],

              // Localiza√ß√£o
              Row(
                children: [
                  const Icon(
                    Icons.location_on,
                    size: 16,
                    color: AppColors.textSecondary,
                  ),
                  const SizedBox(width: AppDimensions.spacingXs),
                  Expanded(
                    child: Text(
                      event.location,
                      style: const TextStyle(
                        fontSize: AppDimensions.fontSizeSm,
                        color: AppColors.textSecondary,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),

              const SizedBox(height: AppDimensions.spacingSm),

              // Papel do usu√°rio e participantes
              Row(
                children: [
                  _buildUserRoleChip(),
                  const Spacer(),
                  _buildParticipantsInfo(),
                ],
              ),

              const SizedBox(height: AppDimensions.spacingSm),

              // Tag do evento e data
              Row(
                children: [
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: AppDimensions.paddingSm,
                      vertical: AppDimensions.paddingXs,
                    ),
                    decoration: BoxDecoration(
                      color: AppColors.primary.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(AppDimensions.radiusSm),
                    ),
                    child: Text(
                      event.tag,
                      style: const TextStyle(
                        fontSize: AppDimensions.fontSizeSm,
                        fontWeight: FontWeight.bold,
                        color: AppColors.primary,
                      ),
                    ),
                  ),
                  const Spacer(),
                  Text(
                    event.createdTimeAgo,
                    style: const TextStyle(
                      fontSize: AppDimensions.fontSizeSm,
                      color: AppColors.textSecondary,
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildStatusChip() {
    Color backgroundColor;
    Color textColor;
    String text;

    switch (event.status) {
      case EventStatus.active:
        backgroundColor = AppColors.success.withValues(alpha: 0.1);
        textColor = AppColors.success;
        text = 'Ativo';
        break;
      case EventStatus.completed:
        backgroundColor = AppColors.textSecondary.withValues(alpha: 0.1);
        textColor = AppColors.textSecondary;
        text = 'Conclu√≠do';
        break;
      case EventStatus.cancelled:
        backgroundColor = AppColors.error.withValues(alpha: 0.1);
        textColor = AppColors.error;
        text = 'Cancelado';
        break;
    }

    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimensions.paddingSm,
        vertical: AppDimensions.paddingXs,
      ),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(AppDimensions.radiusSm),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontSize: AppDimensions.fontSizeSm,
          fontWeight: FontWeight.w600,
          color: textColor,
        ),
      ),
    );
  }

  Widget _buildUserRoleChip() {
    if (currentUserId == null) {
      return const SizedBox.shrink();
    }

    final role = event.getUserRole(currentUserId!);
    Color backgroundColor;
    Color textColor;
    IconData icon;
    String text;

    switch (role) {
      case UserRole.creator:
        backgroundColor = AppColors.primary.withValues(alpha: 0.1);
        textColor = AppColors.primary;
        icon = Icons.star;
        text = 'Criador';
        break;
      case UserRole.manager:
        backgroundColor = AppColors.secondary.withValues(alpha: 0.1);
        textColor = AppColors.secondary;
        icon = Icons.admin_panel_settings;
        text = 'Gerenciador';
        break;
      case UserRole.volunteer:
        backgroundColor = AppColors.success.withValues(alpha: 0.1);
        textColor = AppColors.success;
        icon = Icons.volunteer_activism;
        text = 'Volunt√°rio';
        break;
      case UserRole.none:
        return const SizedBox.shrink();
    }

    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimensions.paddingSm,
        vertical: AppDimensions.paddingXs,
      ),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(AppDimensions.radiusSm),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 14,
            color: textColor,
          ),
          const SizedBox(width: AppDimensions.spacingXs),
          Text(
            text,
            style: TextStyle(
              fontSize: AppDimensions.fontSizeSm,
              fontWeight: FontWeight.w600,
              color: textColor,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildParticipantsInfo() {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Icon(
          Icons.people,
          size: 16,
          color: AppColors.textSecondary,
        ),
        const SizedBox(width: AppDimensions.spacingXs),
        Text(
          '${event.totalParticipants}',
          style: const TextStyle(
            fontSize: AppDimensions.fontSizeSm,
            color: AppColors.textSecondary,
            fontWeight: FontWeight.w500,
          ),
        ),
      ],
    );
  }
}

## lib\presentation\controllers\event_controller.dart <a id="event_controller_dart"></a>

### Dependencies

- `package:flutter/foundation.dart`
- `package:flutter/widgets.dart`
- `../../data/models/event_model.dart`
- `../../data/models/user_model.dart`
- `../../data/models/volunteer_profile_model.dart`
- `../../data/repositories/event_repository.dart`
- `../../data/repositories/user_repository.dart`
- `../../core/exceptions/app_exceptions.dart`

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import '../../data/models/event_model.dart';
import '../../data/models/user_model.dart';
import '../../data/models/volunteer_profile_model.dart';
import '../../data/repositories/event_repository.dart';
import '../../data/repositories/user_repository.dart';
import '../../core/exceptions/app_exceptions.dart';

/// Controller respons√°vel por gerenciar o estado dos eventos
class EventController extends ChangeNotifier {
  final EventRepository _eventRepository;
  final UserRepository _userRepository;

  EventController({
    EventRepository? eventRepository,
    UserRepository? userRepository,
  }) : _eventRepository = eventRepository ?? EventRepository(),
       _userRepository = userRepository ?? UserRepository();

  // Estados de loading
  bool _isLoading = false;
  bool _isCreatingEvent = false;
  bool _isJoiningEvent = false;
  bool _isLoadingUserEvents = false;

  // Dados
  List<EventModel> _userEvents = [];
  EventModel? _currentEvent;
  EventModel? _searchedEvent;
  List<VolunteerProfileModel> _eventVolunteers = [];
  final List<UserModel> _eventVolunteerUsers = [];
  String? _errorMessage;

  // Cache para perfis de volunt√°rios por evento
  final Map<String, List<VolunteerProfileModel>> _volunteersCache = {};
  final Map<String, DateTime> _cacheTimestamps = {};
  static const Duration _cacheExpiration = Duration(minutes: 5);

  // Getters
  bool get isLoading => _isLoading;
  bool get isCreatingEvent => _isCreatingEvent;
  bool get isJoiningEvent => _isJoiningEvent;
  bool get isLoadingUserEvents => _isLoadingUserEvents;
  List<EventModel> get userEvents => List.unmodifiable(_userEvents);
  EventModel? get currentEvent => _currentEvent;
  EventModel? get searchedEvent => _searchedEvent;
  List<VolunteerProfileModel> get eventVolunteers =>
      List.unmodifiable(_eventVolunteers);
  List<UserModel> get eventVolunteerUsers =>
      List.unmodifiable(_eventVolunteerUsers);
  String? get errorMessage => _errorMessage;
  bool get hasError => _errorMessage != null;

  /// Limpa mensagens de erro
  void clearError() {
    _errorMessage = null;
    notifyListeners();
  }

  /// Define uma mensagem de erro
  void _setError(String message) {
    _errorMessage = message;
    notifyListeners();
  }

  /// Cria um novo evento
  Future<EventModel?> createEvent({
    required String name,
    required String description,
    required String location,
    required String createdBy,
    required List<String> requiredSkills,
    required List<String> requiredResources,
  }) async {
    _isCreatingEvent = true;
    _errorMessage = null;
    notifyListeners();

    try {
      // Valida√ß√µes b√°sicas
      if (name.trim().isEmpty) {
        throw ValidationException('Nome do evento √© obrigat√≥rio');
      }
      if (location.trim().isEmpty) {
        throw ValidationException('Localiza√ß√£o √© obrigat√≥ria');
      }
      if (createdBy.isEmpty) {
        throw ValidationException('Usu√°rio criador √© obrigat√≥rio');
      }

      final event = await _eventRepository.createEvent(
        name: name,
        description: description,
        location: location,
        createdBy: createdBy,
        requiredSkills: requiredSkills,
        requiredResources: requiredResources,
      );

      // Adiciona o evento √† lista de eventos do usu√°rio
      _userEvents.insert(0, event);
      _currentEvent = event;

      return event;
    } catch (e) {
      _setError(_getErrorMessage(e));
      return null;
    } finally {
      _isCreatingEvent = false;
      notifyListeners();
    }
  }

  /// Busca um evento por tag
  Future<EventModel?> searchEventByTag(String tag) async {
    _isLoading = true;
    _errorMessage = null;
    _searchedEvent = null;
    notifyListeners();

    try {
      if (tag.trim().isEmpty) {
        throw ValidationException('C√≥digo do evento √© obrigat√≥rio');
      }

      if (!_eventRepository.isValidTag(tag)) {
        throw ValidationException(
          'C√≥digo deve ter exatamente 6 caracteres (letras e n√∫meros)',
        );
      }

      final event = await _eventRepository.getEventByTag(tag);

      if (event == null) {
        throw NotFoundException('Evento n√£o encontrado com o c√≥digo informado');
      }

      _searchedEvent = event;
      return event;
    } catch (e) {
      _setError(_getErrorMessage(e));
      return null;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Participa de um evento
  Future<bool> joinEvent({
    required String eventId,
    required String userId,
    required List<String> availableDays,
    required TimeRange availableHours,
    bool isFullTimeAvailable = false,
    required List<String> skills,
    required List<String> resources,
  }) async {
    _isJoiningEvent = true;
    _errorMessage = null;
    notifyListeners();

    try {
      // Valida√ß√µes b√°sicas
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }
      if (userId.isEmpty) {
        throw ValidationException('Usu√°rio √© obrigat√≥rio');
      }
      if (!isFullTimeAvailable && availableDays.isEmpty) {
        throw ValidationException(
          'Selecione pelo menos um dia de disponibilidade',
        );
      }
      if (!availableHours.isValid()) {
        throw ValidationException('Hor√°rio de disponibilidade inv√°lido');
      }

      final updatedEvent = await _eventRepository.joinEvent(
        eventId: eventId,
        userId: userId,
        availableDays: availableDays,
        availableHours: availableHours,
        isFullTimeAvailable: isFullTimeAvailable,
        skills: skills,
        resources: resources,
      );

      // Atualiza a lista de eventos do usu√°rio
      final index = _userEvents.indexWhere((e) => e.id == eventId);
      if (index >= 0) {
        _userEvents[index] = updatedEvent;
      } else {
        _userEvents.insert(0, updatedEvent);
      }

      // Atualiza o evento atual se for o mesmo
      if (_currentEvent?.id == eventId) {
        _currentEvent = updatedEvent;
      }

      // Atualiza o evento pesquisado se for o mesmo
      if (_searchedEvent?.id == eventId) {
        _searchedEvent = updatedEvent;
      }

      return true;
    } catch (e) {
      _setError(_getErrorMessage(e));
      return false;
    } finally {
      _isJoiningEvent = false;
      notifyListeners();
    }
  }

  /// Carrega os eventos do usu√°rio
  Future<void> loadUserEvents(String userId) async {
    _isLoadingUserEvents = true;
    _errorMessage = null;
    notifyListeners();

    try {
      if (userId.isEmpty) {
        throw ValidationException('ID do usu√°rio √© obrigat√≥rio');
      }

      final events = await _eventRepository.getUserEvents(userId);
      _userEvents = events;
    } catch (e) {
      _setError(_getErrorMessage(e));
      _userEvents = [];
    } finally {
      _isLoadingUserEvents = false;
      notifyListeners();
    }
  }

  /// Carrega um evento espec√≠fico
  Future<EventModel?> loadEvent(String eventId) async {
    if (_isLoading) {
      return _currentEvent; // Evita m√∫ltiplas chamadas simult√¢neas
    }

    _isLoading = true;
    _errorMessage = null;

    // Usar WidgetsBinding para evitar setState durante build
    WidgetsBinding.instance.addPostFrameCallback((_) {
      notifyListeners();
    });

    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      final event = await _eventRepository.getEventById(eventId);

      if (event == null) {
        throw NotFoundException('Evento n√£o encontrado');
      }

      _currentEvent = event;
      return event;
    } catch (e) {
      _setError(_getErrorMessage(e));
      return null;
    } finally {
      _isLoading = false;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
    }
  }

  /// Carrega os volunt√°rios de um evento
  Future<void> loadEventVolunteers(String eventId) async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      // Carrega os perfis dos volunt√°rios
      final volunteers = await _eventRepository.getEventVolunteers(eventId);
      _eventVolunteers = volunteers;

      // Carrega os dados dos usu√°rios
      final userIds = volunteers.map((v) => v.userId).toList();
      if (userIds.isNotEmpty) {
        final users = await _userRepository.getUsersByIds(userIds);
        _eventVolunteerUsers.clear();
        _eventVolunteerUsers.addAll(users);
      } else {
        _eventVolunteerUsers.clear();
      }
    } catch (e) {
      _setError(_getErrorMessage(e));
      _eventVolunteers = [];
      _eventVolunteerUsers.clear();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Busca um volunt√°rio espec√≠fico com seus dados completos
  Future<UserModel?> getVolunteerUser(String userId) async {
    try {
      if (userId.isEmpty) {
        return null;
      }

      return await _userRepository.getUserById(userId);
    } catch (e) {
      _setError(_getErrorMessage(e));
      return null;
    }
  }

  /// Busca o perfil de um volunt√°rio espec√≠fico
  Future<VolunteerProfileModel?> getVolunteerProfile(
    String userId,
    String eventId,
  ) async {
    try {
      if (userId.isEmpty || eventId.isEmpty) {
        return null;
      }

      return await _eventRepository.getVolunteerProfile(userId, eventId);
    } catch (e) {
      _setError(_getErrorMessage(e));
      return null;
    }
  }

  /// Busca dados completos de volunt√°rios (usu√°rios + perfis) para um evento
  Future<Map<String, dynamic>> getEventVolunteersWithUsers(
    String eventId,
  ) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      // Carrega os perfis dos volunt√°rios
      final profiles = await _eventRepository.getEventVolunteers(eventId);

      // Carrega os dados dos usu√°rios
      final userIds = profiles.map((p) => p.userId).toList();
      final users = userIds.isNotEmpty
          ? await _userRepository.getUsersByIds(userIds)
          : <UserModel>[];

      return {'profiles': profiles, 'users': users};
    } catch (e) {
      _setError(_getErrorMessage(e));
      return {'profiles': <VolunteerProfileModel>[], 'users': <UserModel>[]};
    }
  }

  /// Busca dados de volunt√°rios otimizado (com cache e dados denormalizados)
  Future<List<VolunteerProfileModel>> getEventVolunteersOptimized(
    String eventId,
  ) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      // Verifica se tem dados v√°lidos no cache
      if (_isCacheValid(eventId)) {
        return List.from(_volunteersCache[eventId]!);
      }

      // Busca os perfis de volunt√°rios (com dados denormalizados)
      final profiles = await _eventRepository.getEventVolunteers(eventId);

      // Atualiza o cache
      _volunteersCache[eventId] = List.from(profiles);
      _cacheTimestamps[eventId] = DateTime.now();

      return profiles;
    } catch (e) {
      _setError(_getErrorMessage(e));
      return <VolunteerProfileModel>[];
    }
  }

  /// Verifica se o cache √© v√°lido para um evento
  bool _isCacheValid(String eventId) {
    if (!_volunteersCache.containsKey(eventId) ||
        !_cacheTimestamps.containsKey(eventId)) {
      return false;
    }

    final cacheTime = _cacheTimestamps[eventId]!;
    final now = DateTime.now();
    return now.difference(cacheTime) < _cacheExpiration;
  }

  /// Limpa o cache de volunt√°rios para um evento espec√≠fico
  void clearVolunteersCache(String eventId) {
    _volunteersCache.remove(eventId);
    _cacheTimestamps.remove(eventId);
  }

  /// Limpa todo o cache de volunt√°rios
  void clearAllVolunteersCache() {
    _volunteersCache.clear();
    _cacheTimestamps.clear();
  }

  /// Promove um volunt√°rio a gerenciador
  Future<bool> promoteVolunteer(
    String eventId,
    String userId,
    String managerId,
  ) async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      final updatedEvent = await _eventRepository.promoteVolunteer(
        eventId,
        userId,
        managerId,
      );

      // Atualiza o evento na lista
      final index = _userEvents.indexWhere((e) => e.id == eventId);
      if (index >= 0) {
        _userEvents[index] = updatedEvent;
      }

      // Atualiza o evento atual se for o mesmo
      if (_currentEvent?.id == eventId) {
        _currentEvent = updatedEvent;
      }

      return true;
    } catch (e) {
      _setError(_getErrorMessage(e));
      return false;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Verifica se um usu√°rio pode gerenciar um evento
  Future<bool> canManageEvent(String eventId, String userId) async {
    try {
      return await _eventRepository.canManageEvent(eventId, userId);
    } catch (e) {
      return false;
    }
  }

  /// Verifica se um usu√°rio √© participante de um evento
  Future<bool> isParticipant(String eventId, String userId) async {
    try {
      return await _eventRepository.isParticipant(eventId, userId);
    } catch (e) {
      return false;
    }
  }

  /// Limpa o evento pesquisado
  void clearSearchedEvent() {
    _searchedEvent = null;
    notifyListeners();
  }

  /// Define o evento atual
  void setCurrentEvent(EventModel? event) {
    _currentEvent = event;
    notifyListeners();
  }

  /// Atualiza um evento na lista
  void updateEventInList(EventModel updatedEvent) {
    final index = _userEvents.indexWhere((e) => e.id == updatedEvent.id);
    if (index >= 0) {
      _userEvents[index] = updatedEvent;
      notifyListeners();
    }
  }

  /// Remove um evento da lista
  void removeEventFromList(String eventId) {
    _userEvents.removeWhere((e) => e.id == eventId);

    if (_currentEvent?.id == eventId) {
      _currentEvent = null;
    }

    if (_searchedEvent?.id == eventId) {
      _searchedEvent = null;
    }

    notifyListeners();
  }

  /// Promove um volunt√°rio a gerente do evento
  Future<bool> promoteVolunteerToManager({
    required String eventId,
    required String volunteerId,
    required String managerId,
  }) async {
    try {
      _isLoading = true;
      _errorMessage = null;
      notifyListeners();

      // Promove o volunt√°rio
      final updatedEvent = await _eventRepository.promoteVolunteer(
        eventId,
        volunteerId,
        managerId,
      );

      // Atualiza o evento atual se for o mesmo
      if (_currentEvent?.id == eventId) {
        _currentEvent = updatedEvent;
      }

      // Atualiza a lista de eventos do usu√°rio
      final eventIndex = _userEvents.indexWhere((e) => e.id == eventId);
      if (eventIndex != -1) {
        _userEvents[eventIndex] = updatedEvent;
      }

      _isLoading = false;
      notifyListeners();
      return true;
    } catch (e) {
      _isLoading = false;
      _errorMessage = _getErrorMessage(e);
      notifyListeners();
      return false;
    }
  }

  /// Incrementa o contador de microtasks atribu√≠das para um volunt√°rio
  Future<bool> incrementVolunteerMicrotaskCount(
    String eventId,
    String userId,
  ) async {
    try {
      await _eventRepository.incrementVolunteerMicrotaskCount(eventId, userId);

      // Atualiza o perfil local se dispon√≠vel
      final profileIndex = _eventVolunteers.indexWhere(
        (p) => p.userId == userId,
      );
      if (profileIndex != -1) {
        _eventVolunteers[profileIndex] = _eventVolunteers[profileIndex]
            .incrementAssignedMicrotasks();
        notifyListeners();
      }

      return true;
    } catch (e) {
      _errorMessage = _getErrorMessage(e);
      notifyListeners();
      return false;
    }
  }

  /// Decrementa o contador de microtasks atribu√≠das para um volunt√°rio
  Future<bool> decrementVolunteerMicrotaskCount(
    String eventId,
    String userId,
  ) async {
    try {
      await _eventRepository.decrementVolunteerMicrotaskCount(eventId, userId);

      // Atualiza o perfil local se dispon√≠vel
      final profileIndex = _eventVolunteers.indexWhere(
        (p) => p.userId == userId,
      );
      if (profileIndex != -1) {
        _eventVolunteers[profileIndex] = _eventVolunteers[profileIndex]
            .decrementAssignedMicrotasks();
        notifyListeners();
      }

      return true;
    } catch (e) {
      _errorMessage = _getErrorMessage(e);
      notifyListeners();
      return false;
    }
  }

  /// Converte exce√ß√µes em mensagens de erro amig√°veis
  String _getErrorMessage(dynamic error) {
    if (error is ValidationException) {
      return error.message;
    } else if (error is NotFoundException) {
      return error.message;
    } else if (error is UnauthorizedException) {
      return error.message;
    } else if (error is DatabaseException) {
      return 'Erro de conex√£o. Tente novamente.';
    } else if (error is RepositoryException) {
      return 'Erro interno. Tente novamente.';
    } else {
      return 'Erro inesperado. Tente novamente.';
    }
  }

  /// Migra perfis de volunt√°rios existentes para incluir o campo assignedMicrotasksCount
  Future<bool> migrateVolunteerProfilesTaskCounts() async {
    try {
      _isLoading = true;
      notifyListeners();

      await _eventRepository.migrateVolunteerProfilesTaskCounts();

      _isLoading = false;
      notifyListeners();
      return true;
    } catch (e) {
      _isLoading = false;
      _errorMessage = _getErrorMessage(e);
      notifyListeners();
      return false;
    }
  }

  /// Recalcula e corrige o contador de microtasks para um volunt√°rio espec√≠fico
  Future<bool> recalculateVolunteerMicrotaskCount(
    String eventId,
    String userId,
  ) async {
    try {
      await _eventRepository.recalculateVolunteerMicrotaskCount(
        eventId,
        userId,
      );

      // Atualiza o perfil local se dispon√≠vel
      final profileIndex = _eventVolunteers.indexWhere(
        (p) => p.userId == userId,
      );
      if (profileIndex != -1) {
        // Recarrega o perfil atualizado
        final updatedProfile = await _eventRepository.getVolunteerProfile(
          userId,
          eventId,
        );
        if (updatedProfile != null) {
          _eventVolunteers[profileIndex] = updatedProfile;
          notifyListeners();
        }
      }

      return true;
    } catch (e) {
      _errorMessage = _getErrorMessage(e);
      notifyListeners();
      return false;
    }
  }

  /// Recalcula os contadores para todos os volunt√°rios de um evento
  Future<bool> recalculateEventVolunteerCounts(String eventId) async {
    try {
      _isLoading = true;
      notifyListeners();

      await _eventRepository.recalculateEventVolunteerCounts(eventId);

      // Recarrega os perfis de volunt√°rios do evento
      await loadEventVolunteers(eventId);

      _isLoading = false;
      notifyListeners();
      return true;
    } catch (e) {
      _isLoading = false;
      _errorMessage = _getErrorMessage(e);
      notifyListeners();
      return false;
    }
  }

  /// Limpa todos os dados
  void clear() {
    _userEvents.clear();
    _currentEvent = null;
    _searchedEvent = null;
    _eventVolunteers.clear();
    _errorMessage = null;
    _isLoading = false;
    _isCreatingEvent = false;
    _isJoiningEvent = false;
    _isLoadingUserEvents = false;
    clearAllVolunteersCache();
    notifyListeners();
  }
}

## lib\presentation\screens\event\event_details_screen.dart <a id="event_details_screen_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `package:provider/provider.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/event_model.dart`
- `../../../data/models/task_model.dart`
- `../../controllers/auth_controller.dart`
- `../../controllers/event_controller.dart`
- `../../controllers/task_controller.dart`
- `../../widgets/common/loading_widget.dart`
- `../../widgets/common/error_message_widget.dart`
- `../../widgets/common/custom_app_bar.dart`
- `../../widgets/common/error_widget.dart`
- `../../widgets/common/skill_chip.dart`
- `manage_volunteers_screen.dart`
- `track_tasks_screen.dart`

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/event_model.dart';
import '../../../data/models/task_model.dart';
import '../../controllers/auth_controller.dart';
import '../../controllers/event_controller.dart';
import '../../controllers/task_controller.dart';
import '../../widgets/common/loading_widget.dart';
import '../../widgets/common/error_message_widget.dart';
import '../../widgets/common/custom_app_bar.dart';
import '../../widgets/common/error_widget.dart';
import '../../widgets/common/skill_chip.dart';
import 'manage_volunteers_screen.dart';
import 'track_tasks_screen.dart';

/// Tela de detalhes do evento com sistema de tabs
class EventDetailsScreen extends StatefulWidget {
  final String eventId;

  const EventDetailsScreen({super.key, required this.eventId});

  @override
  State<EventDetailsScreen> createState() => _EventDetailsScreenState();
}

class _EventDetailsScreenState extends State<EventDetailsScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  EventModel? _event;
  bool _isLoading = true;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
    _loadEventDetails();
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  Future<void> _loadEventDetails() async {
    try {
      setState(() {
        _isLoading = true;
        _errorMessage = null;
      });

      final eventController = Provider.of<EventController>(
        context,
        listen: false,
      );
      final event = await eventController.loadEvent(widget.eventId);

      if (event != null) {
        setState(() {
          _event = event;
        });

        // Carrega tasks do evento
        if (mounted) {
          final taskController = Provider.of<TaskController>(
            context,
            listen: false,
          );
          await taskController.loadTasksByEventId(widget.eventId);
        }

        if (mounted) {
          setState(() {
            _isLoading = false;
          });
        }
      } else {
        setState(() {
          _errorMessage = 'Evento n√£o encontrado';
          _isLoading = false;
        });
      }
    } catch (e) {
      setState(() {
        _errorMessage = 'Erro ao carregar evento: ${e.toString()}';
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Scaffold(
        backgroundColor: AppColors.background,
        body: LoadingWidget(message: 'Carregando evento...'),
      );
    }

    if (_errorMessage != null) {
      return Scaffold(
        backgroundColor: AppColors.background,
        appBar: AppBar(
          title: const Text('Detalhes do Evento'),
          backgroundColor: AppColors.primary,
          foregroundColor: AppColors.textOnPrimary,
        ),
        body: ErrorMessageWidget(
          message: _errorMessage!,
          onRetry: _loadEventDetails,
        ),
      );
    }

    if (_event == null) {
      return Scaffold(
        backgroundColor: AppColors.background,
        appBar: AppBar(
          title: const Text('Detalhes do Evento'),
          backgroundColor: AppColors.primary,
          foregroundColor: AppColors.textOnPrimary,
        ),
        body: const Center(child: Text('Evento n√£o encontrado')),
      );
    }

    return Scaffold(
      backgroundColor: AppColors.background,
      appBar: _buildAppBar(),
      body: Column(
        children: [
          _buildTabBar(),
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildEventTab(),
                _buildManageVolunteersTab(),
                _buildTrackTasksTab(),
              ],
            ),
          ),
        ],
      ),
      floatingActionButton: _buildFloatingActionButton(),
    );
  }

  PreferredSizeWidget _buildAppBar() {
    return CustomAppBar(
      title: _event!.name,
      actions: [
        IconButton(
          icon: const Icon(Icons.refresh),
          onPressed: _loadEventDetails,
          tooltip: 'Atualizar',
        ),
        IconButton(
          icon: const Icon(Icons.share),
          onPressed: () => _shareEvent(),
          tooltip: 'Compartilhar',
        ),
      ],
    );
  }

  Widget _buildTabBar() {
    final authController = Provider.of<AuthController>(context, listen: false);
    final currentUserId = authController.currentUser?.id;
    final isManager = _event!.isManager(currentUserId ?? '');

    return Container(
      color: AppColors.primary,
      child: TabBar(
        controller: _tabController,
        indicatorColor: AppColors.textOnPrimary,
        labelColor: AppColors.textOnPrimary,
        unselectedLabelColor: AppColors.textOnPrimary.withOpacity(0.7),
        tabs: [
          const Tab(icon: Icon(Icons.info_outline), text: 'Evento'),
          if (isManager)
            const Tab(icon: Icon(Icons.people), text: 'Volunt√°rios'),
          const Tab(icon: Icon(Icons.track_changes), text: 'Acompanhar'),
        ],
      ),
    );
  }

  Widget _buildEventTab() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(AppDimensions.paddingLg),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildEventInfoCard(),
          const SizedBox(height: AppDimensions.spacingLg),
          _buildEventStatsCard(),
          const SizedBox(height: AppDimensions.spacingLg),
          _buildEventCodeCard(),
        ],
      ),
    );
  }

  Widget _buildManageVolunteersTab() {
    final authController = Provider.of<AuthController>(context, listen: false);
    final currentUserId = authController.currentUser?.id;
    final isManager = _event!.isManager(currentUserId ?? '');

    if (!isManager) {
      return const Center(
        child: Text(
          'Apenas gerenciadores podem gerenciar volunt√°rios',
          style: TextStyle(fontSize: 16, color: AppColors.textSecondary),
        ),
      );
    }

    return ManageVolunteersScreen(eventId: widget.eventId);
  }

  Widget _buildTrackTasksTab() {
    return TrackTasksScreen(eventId: widget.eventId);
  }

  Widget _buildEventInfoCard() {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(AppDimensions.paddingLg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Icon(Icons.info_outline, color: AppColors.primary),
                const SizedBox(width: AppDimensions.spacingSm),
                const Text(
                  'Informa√ß√µes do Evento',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: AppColors.textPrimary,
                  ),
                ),
              ],
            ),
            const SizedBox(height: AppDimensions.spacingMd),
            _buildInfoRow('Nome', _event!.name),
            _buildInfoRow('Descri√ß√£o', _event!.description),
            _buildInfoRow('Localiza√ß√£o', _event!.location),
            _buildInfoRow('Status', _getStatusText(_event!.status)),
            _buildInfoRow('Criado em', _formatDate(_event!.createdAt)),

            // Habilidades necess√°rias
            if (_event!.requiredSkills.isNotEmpty) ...[
              const SizedBox(height: AppDimensions.spacingMd),
              SkillChipList(
                title: 'Habilidades Necess√°rias',
                items: _event!.requiredSkills,
                itemIcon: Icons.star,
                chipColor: AppColors.primary,
                isSmall: true,
              ),
            ],

            // Recursos necess√°rios
            if (_event!.requiredResources.isNotEmpty) ...[
              const SizedBox(height: AppDimensions.spacingMd),
              SkillChipList(
                title: 'Recursos Necess√°rios',
                items: _event!.requiredResources,
                itemIcon: Icons.build,
                chipColor: AppColors.secondary,
                isSmall: true,
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildEventStatsCard() {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(AppDimensions.paddingLg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Icon(Icons.analytics_outlined, color: AppColors.primary),
                const SizedBox(width: AppDimensions.spacingSm),
                const Text(
                  'Estat√≠sticas',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: AppColors.textPrimary,
                  ),
                ),
              ],
            ),
            const SizedBox(height: AppDimensions.spacingMd),
            Row(
              children: [
                Expanded(
                  child: _buildStatItem(
                    'Gerenciadores',
                    _event!.managers.length.toString(),
                    Icons.admin_panel_settings,
                  ),
                ),
                const SizedBox(width: AppDimensions.spacingMd),
                Expanded(
                  child: _buildStatItem(
                    'Volunt√°rios',
                    _event!.volunteers.length.toString(),
                    Icons.people,
                  ),
                ),
              ],
            ),
            const SizedBox(height: AppDimensions.spacingMd),
            Consumer<TaskController>(
              builder: (context, taskController, child) {
                final tasks = taskController.tasks;
                final totalMicrotasks = tasks.fold<int>(
                  0,
                  (sum, task) => sum + task.microtaskCount,
                );
                final completedMicrotasks = tasks.fold<int>(
                  0,
                  (sum, task) => sum + task.completedMicrotasks,
                );

                return Row(
                  children: [
                    Expanded(
                      child: _buildStatItem(
                        'Tasks',
                        tasks.length.toString(),
                        Icons.task_alt,
                      ),
                    ),
                    const SizedBox(width: AppDimensions.spacingMd),
                    Expanded(
                      child: _buildStatItem(
                        'Microtasks',
                        '$completedMicrotasks/$totalMicrotasks',
                        Icons.checklist,
                      ),
                    ),
                  ],
                );
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildEventCodeCard() {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(AppDimensions.paddingLg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Icon(Icons.qr_code, color: AppColors.primary),
                const SizedBox(width: AppDimensions.spacingSm),
                const Text(
                  'C√≥digo do Evento',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: AppColors.textPrimary,
                  ),
                ),
              ],
            ),
            const SizedBox(height: AppDimensions.spacingMd),
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(AppDimensions.paddingMd),
              decoration: BoxDecoration(
                color: AppColors.secondary.withOpacity(0.1),
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: AppColors.secondary),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    _event!.tag,
                    style: const TextStyle(
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                      color: AppColors.primary,
                      letterSpacing: 2,
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.copy, color: AppColors.primary),
                    onPressed: () => _copyToClipboard(_event!.tag),
                    tooltip: 'Copiar c√≥digo',
                  ),
                ],
              ),
            ),
            const SizedBox(height: AppDimensions.spacingSm),
            const Text(
              'Compartilhe este c√≥digo para que outros possam participar do evento',
              style: TextStyle(fontSize: 12, color: AppColors.textSecondary),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.only(bottom: AppDimensions.spacingSm),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 100,
            child: Text(
              '$label:',
              style: const TextStyle(
                fontWeight: FontWeight.w500,
                color: AppColors.textSecondary,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: const TextStyle(color: AppColors.textPrimary),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatItem(String label, String value, IconData icon) {
    return Container(
      padding: const EdgeInsets.all(AppDimensions.paddingMd),
      decoration: BoxDecoration(
        color: AppColors.primary.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        children: [
          Icon(icon, color: AppColors.primary, size: 24),
          const SizedBox(height: AppDimensions.spacingSm),
          Text(
            value,
            style: const TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
              color: AppColors.primary,
            ),
          ),
          Text(
            label,
            style: const TextStyle(
              fontSize: 12,
              color: AppColors.textSecondary,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  String _getStatusText(EventStatus status) {
    switch (status) {
      case EventStatus.active:
        return 'Ativo';
      case EventStatus.completed:
        return 'Conclu√≠do';
      case EventStatus.cancelled:
        return 'Cancelado';
    }
  }

  String _formatDate(DateTime date) {
    return '${date.day.toString().padLeft(2, '0')}/${date.month.toString().padLeft(2, '0')}/${date.year}';
  }

  Widget? _buildFloatingActionButton() {
    final authController = Provider.of<AuthController>(context, listen: false);
    final currentUserId = authController.currentUser?.id;
    final isManager = _event?.isManager(currentUserId ?? '') ?? false;

    if (!isManager) return null;

    return Consumer<TaskController>(
      builder: (context, taskController, child) {
        final tasks = taskController.tasks;

        return FloatingActionButton(
          onPressed: () => _showCreateOptionsDialog(tasks),
          backgroundColor: AppColors.primary,
          child: const Icon(Icons.add, color: AppColors.textOnPrimary),
        );
      },
    );
  }

  void _showCreateOptionsDialog(List<TaskModel> tasks) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('O que deseja criar?'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.task_alt, color: AppColors.primary),
              title: const Text('Nova Task'),
              subtitle: const Text('Criar uma nova task organizadora'),
              onTap: () {
                Navigator.of(context).pop();
                _navigateToCreateTask();
              },
            ),
            if (tasks.isNotEmpty)
              ListTile(
                leading: const Icon(
                  Icons.checklist,
                  color: AppColors.secondary,
                ),
                title: const Text('Nova Microtask'),
                subtitle: const Text('Criar uma microtask dentro de uma task'),
                onTap: () {
                  Navigator.of(context).pop();
                  _navigateToCreateMicrotask();
                },
              )
            else
              ListTile(
                leading: Icon(Icons.checklist, color: Colors.grey[400]),
                title: Text(
                  'Nova Microtask',
                  style: TextStyle(color: Colors.grey[600]),
                ),
                subtitle: const Text('√â preciso criar uma task primeiro'),
                enabled: false,
              ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancelar'),
          ),
        ],
      ),
    );
  }

  void _navigateToCreateTask() {
    Navigator.of(context).pushNamed('/create-task', arguments: widget.eventId);
  }

  void _navigateToCreateMicrotask() {
    Navigator.of(
      context,
    ).pushNamed('/create-microtask', arguments: widget.eventId);
  }

  void _copyToClipboard(String text) {
    // TODO: Implementar c√≥pia para clipboard
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('C√≥digo copiado para a √°rea de transfer√™ncia'),
        backgroundColor: AppColors.success,
      ),
    );
  }

  void _shareEvent() {
    // TODO: Implementar compartilhamento do evento
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Compartilhar evento: ${_event!.name} (${_event!.tag})'),
        backgroundColor: AppColors.warning,
        action: SnackBarAction(
          label: 'Copiar C√≥digo',
          onPressed: () => _copyToClipboard(_event!.tag),
        ),
      ),
    );
  }
}

## lib\presentation\widgets\event\event_info_card.dart <a id="event_info_card_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/event_model.dart`
- `skill_chip.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/event_model.dart';
import 'skill_chip.dart';

/// Widget de card para exibir informa√ß√µes detalhadas de um evento
class EventInfoCard extends StatelessWidget {
  final EventModel event;
  final String? currentUserId;
  final VoidCallback? onTap;
  final bool showFullDescription;
  final bool showParticipants;
  final bool showRequirements;

  const EventInfoCard({
    super.key,
    required this.event,
    this.currentUserId,
    this.onTap,
    this.showFullDescription = false,
    this.showParticipants = true,
    this.showRequirements = true,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: AppDimensions.elevationSm,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        child: Padding(
          padding: const EdgeInsets.all(AppDimensions.paddingLg),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header com nome e status
              _buildHeader(),

              const SizedBox(height: AppDimensions.spacingMd),

              // Descri√ß√£o
              if (event.description.isNotEmpty) ...[
                _buildDescription(),
                const SizedBox(height: AppDimensions.spacingMd),
              ],

              // Localiza√ß√£o
              _buildLocation(),

              const SizedBox(height: AppDimensions.spacingMd),

              // Papel do usu√°rio e participantes
              if (showParticipants) ...[
                _buildParticipantsInfo(),
                const SizedBox(height: AppDimensions.spacingMd),
              ],

              // Habilidades necess√°rias
              if (showRequirements && event.requiredSkills.isNotEmpty) ...[
                _buildRequiredSkills(),
                const SizedBox(height: AppDimensions.spacingMd),
              ],

              // Recursos necess√°rios
              if (showRequirements && event.requiredResources.isNotEmpty) ...[
                _buildRequiredResources(),
                const SizedBox(height: AppDimensions.spacingMd),
              ],

              // Footer com tag e data
              _buildFooter(),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildHeader() {
    return Row(
      children: [
        Expanded(
          child: Text(
            event.name,
            style: const TextStyle(
              fontSize: AppDimensions.fontSizeXl,
              fontWeight: FontWeight.bold,
              color: AppColors.textPrimary,
            ),
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),
        ),
        const SizedBox(width: AppDimensions.spacingSm),
        _buildStatusChip(),
      ],
    );
  }

  Widget _buildDescription() {
    final description = showFullDescription ? event.description : event.shortDescription;

    return Text(
      description,
      style: const TextStyle(
        fontSize: AppDimensions.fontSizeMd,
        color: AppColors.textSecondary,
        height: 1.4,
      ),
      maxLines: showFullDescription ? null : 3,
      overflow: showFullDescription ? null : TextOverflow.ellipsis,
    );
  }

  Widget _buildLocation() {
    return Row(
      children: [
        const Icon(
          Icons.location_on,
          size: 18,
          color: AppColors.textSecondary,
        ),
        const SizedBox(width: AppDimensions.spacingXs),
        Expanded(
          child: Text(
            event.location,
            style: const TextStyle(
              fontSize: AppDimensions.fontSizeMd,
              color: AppColors.textSecondary,
            ),
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }

  Widget _buildParticipantsInfo() {
    return Row(
      children: [
        // Papel do usu√°rio
        if (currentUserId != null) ...[
          _buildUserRoleChip(),
          const Spacer(),
        ],

        // N√∫mero de participantes
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(
              Icons.people,
              size: 18,
              color: AppColors.textSecondary,
            ),
            const SizedBox(width: AppDimensions.spacingXs),
            Text(
              '${event.totalParticipants} participante${event.totalParticipants != 1 ? 's' : ''}',
              style: const TextStyle(
                fontSize: AppDimensions.fontSizeMd,
                color: AppColors.textSecondary,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildRequiredSkills() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Habilidades necess√°rias:',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeMd,
            fontWeight: FontWeight.w600,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),
        Wrap(
          spacing: AppDimensions.spacingSm,
          runSpacing: AppDimensions.spacingSm,
          children: event.requiredSkills.map((skill) {
            return SkillChip(
              label: skill,
              isSelected: false,
              backgroundColor: AppColors.primary.withValues(alpha: 0.1),
              textColor: AppColors.primary,
              borderColor: AppColors.primary.withValues(alpha: 0.3),
            );
          }).toList(),
        ),
      ],
    );
  }

  Widget _buildRequiredResources() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Recursos necess√°rios:',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeMd,
            fontWeight: FontWeight.w600,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),
        Wrap(
          spacing: AppDimensions.spacingSm,
          runSpacing: AppDimensions.spacingSm,
          children: event.requiredResources.map((resource) {
            return SkillChip(
              label: resource,
              isSelected: false,
              backgroundColor: AppColors.secondary.withValues(alpha: 0.1),
              textColor: AppColors.secondary,
              borderColor: AppColors.secondary.withValues(alpha: 0.3),
            );
          }).toList(),
        ),
      ],
    );
  }

  Widget _buildFooter() {
    return Row(
      children: [
        // Tag do evento
        Container(
          padding: const EdgeInsets.symmetric(
            horizontal: AppDimensions.paddingMd,
            vertical: AppDimensions.paddingSm,
          ),
          decoration: BoxDecoration(
            color: AppColors.primary.withValues(alpha: 0.1),
            borderRadius: BorderRadius.circular(AppDimensions.radiusLg),
            border: Border.all(color: AppColors.primary.withValues(alpha: 0.3)),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(
                Icons.tag,
                size: 16,
                color: AppColors.primary,
              ),
              const SizedBox(width: AppDimensions.spacingXs),
              Text(
                event.tag,
                style: const TextStyle(
                  fontSize: AppDimensions.fontSizeSm,
                  fontWeight: FontWeight.bold,
                  color: AppColors.primary,
                  letterSpacing: 1,
                ),
              ),
            ],
          ),
        ),

        const Spacer(),

        // Data de cria√ß√£o
        Column(
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Text(
              'Criado ${event.createdTimeAgo}',
              style: const TextStyle(
                fontSize: AppDimensions.fontSizeSm,
                color: AppColors.textSecondary,
              ),
            ),
            if (event.createdAt != event.updatedAt) ...[
              const SizedBox(height: AppDimensions.spacingXs),
              Text(
                'Atualizado ${event.updatedTimeAgo}',
                style: const TextStyle(
                  fontSize: AppDimensions.fontSizeXs,
                  color: AppColors.textSecondary,
                ),
              ),
            ],
          ],
        ),
      ],
    );
  }

  Widget _buildStatusChip() {
    Color backgroundColor;
    Color textColor;
    String text;
    IconData icon;

    switch (event.status) {
      case EventStatus.active:
        backgroundColor = AppColors.success.withValues(alpha: 0.1);
        textColor = AppColors.success;
        text = 'Ativo';
        icon = Icons.play_circle;
        break;
      case EventStatus.completed:
        backgroundColor = AppColors.statusCompleted.withValues(alpha: 0.1);
        textColor = AppColors.statusCompleted;
        text = 'Conclu√≠do';
        icon = Icons.check_circle;
        break;
      case EventStatus.cancelled:
        backgroundColor = AppColors.error.withValues(alpha: 0.1);
        textColor = AppColors.error;
        text = 'Cancelado';
        icon = Icons.cancel;
        break;
    }

    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimensions.paddingMd,
        vertical: AppDimensions.paddingSm,
      ),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(AppDimensions.radiusLg),
        border: Border.all(color: textColor.withValues(alpha: 0.3)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 16,
            color: textColor,
          ),
          const SizedBox(width: AppDimensions.spacingXs),
          Text(
            text,
            style: TextStyle(
              fontSize: AppDimensions.fontSizeSm,
              fontWeight: FontWeight.w600,
              color: textColor,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildUserRoleChip() {
    if (currentUserId == null) {
      return const SizedBox.shrink();
    }

    final role = event.getUserRole(currentUserId!);
    if (role == UserRole.none) {
      return const SizedBox.shrink();
    }

    Color backgroundColor;
    Color textColor;
    IconData icon;
    String text;

    switch (role) {
      case UserRole.creator:
        backgroundColor = AppColors.primary.withValues(alpha: 0.1);
        textColor = AppColors.primary;
        icon = Icons.star;
        text = 'Criador';
        break;
      case UserRole.manager:
        backgroundColor = AppColors.secondary.withValues(alpha: 0.1);
        textColor = AppColors.secondary;
        icon = Icons.admin_panel_settings;
        text = 'Gerenciador';
        break;
      case UserRole.volunteer:
        backgroundColor = AppColors.success.withValues(alpha: 0.1);
        textColor = AppColors.success;
        icon = Icons.volunteer_activism;
        text = 'Volunt√°rio';
        break;
      case UserRole.none:
        return const SizedBox.shrink();
    }

    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimensions.paddingMd,
        vertical: AppDimensions.paddingSm,
      ),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(AppDimensions.radiusLg),
        border: Border.all(color: textColor.withValues(alpha: 0.3)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 16,
            color: textColor,
          ),
          const SizedBox(width: AppDimensions.spacingXs),
          Text(
            text,
            style: TextStyle(
              fontSize: AppDimensions.fontSizeSm,
              fontWeight: FontWeight.w600,
              color: textColor,
            ),
          ),
        ],
      ),
    );
  }
}

## lib\data\repositories\event_repository.dart <a id="event_repository_dart"></a>

### Dependencies

- `../models/event_model.dart`
- `../models/volunteer_profile_model.dart`
- `../services/event_service.dart`
- `../repositories/user_repository.dart`
- `../../core/exceptions/app_exceptions.dart`

import '../models/event_model.dart';
import '../models/volunteer_profile_model.dart';
import '../services/event_service.dart';
import '../repositories/user_repository.dart';
import '../../core/exceptions/app_exceptions.dart';

/// Reposit√≥rio respons√°vel por gerenciar dados de eventos
/// Atua como uma camada de abstra√ß√£o entre os controllers e os services
class EventRepository {
  final EventService _eventService;
  final UserRepository _userRepository;

  EventRepository({EventService? eventService, UserRepository? userRepository})
    : _eventService = eventService ?? EventService(),
      _userRepository = userRepository ?? UserRepository();

  /// Cria um novo evento
  Future<EventModel> createEvent({
    required String name,
    required String description,
    required String location,
    required String createdBy,
    required List<String> requiredSkills,
    required List<String> requiredResources,
  }) async {
    try {
      // Create a temporary event for validation
      final tempEvent = EventModel.create(
        id: 'temp', // Temporary ID for validation
        name: name.trim(),
        description: description.trim(),
        tag: 'temp', // Temporary tag for validation
        location: location.trim(),
        createdBy: createdBy,
        requiredSkills: requiredSkills,
        requiredResources: requiredResources,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      // Validate before calling service
      final validationErrors = tempEvent.validate();
      if (validationErrors.isNotEmpty) {
        throw ValidationException(
          'Dados inv√°lidos: ${validationErrors.join(', ')}',
        );
      }

      // Repository delegates to service for creation with ID/tag generation
      return await _eventService.createEvent(
        name: name.trim(),
        description: description.trim(),
        location: location.trim(),
        createdBy: createdBy,
        requiredSkills: requiredSkills,
        requiredResources: requiredResources,
      );
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao criar evento: ${e.toString()}');
    }
  }

  /// Busca um evento por ID
  Future<EventModel?> getEventById(String eventId) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      return await _eventService.getEventById(eventId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao buscar evento: ${e.toString()}');
    }
  }

  /// Busca um evento por tag/c√≥digo
  Future<EventModel?> getEventByTag(String tag) async {
    try {
      if (tag.isEmpty) {
        throw ValidationException('Tag do evento √© obrigat√≥ria');
      }

      // Normaliza a tag (mai√∫scula, sem espa√ßos)
      final normalizedTag = tag.trim().toUpperCase();

      if (normalizedTag.length != 6) {
        throw ValidationException('Tag deve ter exatamente 6 caracteres');
      }

      return await _eventService.getEventByTag(normalizedTag);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar evento por tag: ${e.toString()}',
      );
    }
  }

  /// Busca todos os eventos do usu√°rio
  Future<List<EventModel>> getUserEvents(String userId) async {
    try {
      if (userId.isEmpty) {
        throw ValidationException('ID do usu√°rio √© obrigat√≥rio');
      }

      return await _eventService.getUserEvents(userId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar eventos do usu√°rio: ${e.toString()}',
      );
    }
  }

  /// Atualiza um evento
  Future<EventModel> updateEvent(EventModel event) async {
    try {
      return await _eventService.updateEvent(event);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao atualizar evento: ${e.toString()}');
    }
  }

  /// Adiciona um volunt√°rio ao evento
  Future<EventModel> joinEvent({
    required String eventId,
    required String userId,
    required List<String> availableDays,
    required TimeRange availableHours,
    bool isFullTimeAvailable = false,
    required List<String> skills,
    required List<String> resources,
  }) async {
    try {
      // Basic parameter validation (detailed validation should be in models/controllers)
      if (eventId.isEmpty || userId.isEmpty) {
        throw ValidationException('IDs do evento e usu√°rio s√£o obrigat√≥rios');
      }

      // Adiciona o volunt√°rio ao evento
      final updatedEvent = await _eventService.addVolunteerToEvent(
        eventId,
        userId,
      );

      // Busca dados do usu√°rio para denormaliza√ß√£o
      final userData = await _userRepository.getUserById(userId);
      if (userData == null) {
        throw NotFoundException('Usu√°rio n√£o encontrado');
      }

      // Cria o perfil do volunt√°rio delegando ao service
      await _eventService.createVolunteerProfile(
        userId: userId,
        eventId: eventId,
        availableDays: availableDays,
        availableHours: availableHours,
        isFullTimeAvailable: isFullTimeAvailable,
        skills: skills,
        resources: resources,
        userName: userData.name,
        userEmail: userData.email,
        userPhotoUrl: userData.photoUrl,
      );

      return updatedEvent;
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao participar do evento: ${e.toString()}',
      );
    }
  }

  /// Remove um volunt√°rio do evento
  Future<EventModel> leaveEvent(String eventId, String userId) async {
    try {
      if (eventId.isEmpty || userId.isEmpty) {
        throw ValidationException('IDs do evento e usu√°rio s√£o obrigat√≥rios');
      }

      // Remove o volunt√°rio do evento
      final updatedEvent = await _eventService.removeVolunteerFromEvent(
        eventId,
        userId,
      );

      // Remove o perfil do volunt√°rio (se existir)
      final profile = await _eventService.getVolunteerProfile(userId, eventId);
      if (profile != null) {
        // Aqui seria necess√°rio um m√©todo para deletar o perfil
        // Por enquanto, deixamos como est√°
      }

      return updatedEvent;
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao sair do evento: ${e.toString()}');
    }
  }

  /// Promove um volunt√°rio a gerenciador
  Future<EventModel> promoteVolunteer(
    String eventId,
    String userId,
    String managerId,
  ) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }
      if (userId.isEmpty) {
        throw ValidationException('ID do usu√°rio √© obrigat√≥rio');
      }
      if (managerId.isEmpty) {
        throw ValidationException('ID do gerenciador √© obrigat√≥rio');
      }

      // Verifica se quem est√° promovendo √© gerenciador
      final event = await getEventById(eventId);
      if (event == null) {
        throw NotFoundException('Evento n√£o encontrado');
      }

      if (!event.isManager(managerId)) {
        throw UnauthorizedException(
          'Apenas gerenciadores podem promover volunt√°rios',
        );
      }

      return await _eventService.promoteVolunteerToManager(eventId, userId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao promover volunt√°rio: ${e.toString()}');
    }
  }

  /// Busca o perfil de um volunt√°rio em um evento
  Future<VolunteerProfileModel?> getVolunteerProfile(
    String userId,
    String eventId,
  ) async {
    try {
      if (userId.isEmpty) {
        throw ValidationException('ID do usu√°rio √© obrigat√≥rio');
      }
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      return await _eventService.getVolunteerProfile(userId, eventId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar perfil de volunt√°rio: ${e.toString()}',
      );
    }
  }

  /// Busca todos os perfis de volunt√°rios de um evento
  Future<List<VolunteerProfileModel>> getEventVolunteers(String eventId) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      return await _eventService.getEventVolunteerProfiles(eventId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar volunt√°rios do evento: ${e.toString()}',
      );
    }
  }

  /// Incrementa o contador de microtasks atribu√≠das para um volunt√°rio
  Future<void> incrementVolunteerMicrotaskCount(
    String eventId,
    String userId,
  ) async {
    try {
      await _eventService.incrementVolunteerMicrotaskCount(eventId, userId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao incrementar contador de microtasks: ${e.toString()}',
      );
    }
  }

  /// Decrementa o contador de microtasks atribu√≠das para um volunt√°rio
  Future<void> decrementVolunteerMicrotaskCount(
    String eventId,
    String userId,
  ) async {
    try {
      await _eventService.decrementVolunteerMicrotaskCount(eventId, userId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao decrementar contador de microtasks: ${e.toString()}',
      );
    }
  }

  /// Atualiza o perfil de um volunt√°rio
  Future<VolunteerProfileModel> updateVolunteerProfile(
    VolunteerProfileModel profile,
  ) async {
    try {
      return await _eventService.updateVolunteerProfile(profile);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao atualizar perfil de volunt√°rio: ${e.toString()}',
      );
    }
  }

  /// Deleta um evento
  Future<void> deleteEvent(String eventId, String userId) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }
      if (userId.isEmpty) {
        throw ValidationException('ID do usu√°rio √© obrigat√≥rio');
      }

      await _eventService.deleteEvent(eventId, userId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao deletar evento: ${e.toString()}');
    }
  }

  /// Verifica se um usu√°rio pode gerenciar um evento
  Future<bool> canManageEvent(String eventId, String userId) async {
    try {
      final event = await getEventById(eventId);
      if (event == null) return false;

      return event.isManager(userId);
    } catch (e) {
      return false;
    }
  }

  /// Verifica se um usu√°rio √© participante de um evento
  Future<bool> isParticipant(String eventId, String userId) async {
    try {
      final event = await getEventById(eventId);
      if (event == null) return false;

      return event.isParticipant(userId);
    } catch (e) {
      return false;
    }
  }

  /// Stream para escutar mudan√ßas em um evento
  Stream<EventModel?> watchEvent(String eventId) {
    return _eventService.watchEvent(eventId);
  }

  /// Stream para escutar mudan√ßas nos eventos do usu√°rio
  Stream<List<EventModel>> watchUserEvents(String userId) {
    return _eventService.watchUserEvents(userId);
  }

  /// Busca eventos compat√≠veis com as habilidades de um volunt√°rio
  Future<List<EventModel>> getCompatibleEvents(String userId) async {
    try {
      // Por enquanto, retorna todos os eventos do usu√°rio
      // Pode ser expandido para incluir l√≥gica de compatibilidade
      return await getUserEvents(userId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar eventos compat√≠veis: ${e.toString()}',
      );
    }
  }

  /// Valida se uma tag de evento √© v√°lida
  bool isValidTag(String tag) {
    if (tag.isEmpty) return false;
    if (tag.length != 6) return false;

    // Verifica se cont√©m apenas letras e n√∫meros
    final regex = RegExp(r'^[A-Z0-9]+$');
    return regex.hasMatch(tag.toUpperCase());
  }

  /// Normaliza uma tag de evento
  String normalizeTag(String tag) {
    return tag.trim().toUpperCase();
  }

  /// Migra perfis de volunt√°rios existentes para incluir o campo assignedMicrotasksCount
  Future<void> migrateVolunteerProfilesTaskCounts() async {
    try {
      await _eventService.migrateVolunteerProfilesTaskCounts();
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao migrar perfis de volunt√°rios: ${e.toString()}',
      );
    }
  }

  /// Recalcula e corrige o contador de microtasks para um volunt√°rio espec√≠fico
  Future<void> recalculateVolunteerMicrotaskCount(
    String eventId,
    String userId,
  ) async {
    try {
      await _eventService.recalculateVolunteerMicrotaskCount(eventId, userId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao recalcular contador de microtasks: ${e.toString()}',
      );
    }
  }

  /// Recalcula os contadores para todos os volunt√°rios de um evento
  Future<void> recalculateEventVolunteerCounts(String eventId) async {
    try {
      await _eventService.recalculateEventVolunteerCounts(eventId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao recalcular contadores do evento: ${e.toString()}',
      );
    }
  }

  /// Atualiza dados do usu√°rio em todos os perfis de volunt√°rio
  Future<void> updateUserDataInVolunteerProfiles(
    String userId,
    String userName,
    String userEmail,
    String? userPhotoUrl,
  ) async {
    try {
      await _eventService.updateUserDataInVolunteerProfiles(
        userId,
        userName,
        userEmail,
        userPhotoUrl,
      );
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao atualizar dados do usu√°rio nos perfis: ${e.toString()}',
      );
    }
  }
}

## lib\data\services\event_service.dart <a id="event_service_dart"></a>

### Dependencies

- `package:cloud_firestore/cloud_firestore.dart`
- `package:uuid/uuid.dart`
- `../models/event_model.dart`
- `../models/volunteer_profile_model.dart`
- `../../core/exceptions/app_exceptions.dart`

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:uuid/uuid.dart';
import '../models/event_model.dart';
import '../models/volunteer_profile_model.dart';
import '../../core/exceptions/app_exceptions.dart';

/// Servi√ßo respons√°vel por opera√ß√µes relacionadas a eventos no Firebase
class EventService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final Uuid _uuid = const Uuid();

  // Refer√™ncias das cole√ß√µes
  CollectionReference get _eventsCollection => _firestore.collection('events');
  CollectionReference get _volunteerProfilesCollection =>
      _firestore.collection('volunteer_profiles');

  /// Cria um novo evento
  Future<EventModel> createEvent({
    required String name,
    required String description,
    required String location,
    required String createdBy,
    required List<String> requiredSkills,
    required List<String> requiredResources,
  }) async {
    try {
      // Gera um ID √∫nico para o evento
      final eventId = _uuid.v4();

      // Gera uma tag √∫nica
      String tag;
      do {
        tag = _generateUniqueTag();
      } while (await _isTagTaken(tag));

      // Gera timestamps
      final now = DateTime.now();

      // Cria o evento com dados gerados pelo service
      final event = EventModel.create(
        id: eventId,
        name: name,
        description: description,
        tag: tag,
        location: location,
        createdBy: createdBy,
        requiredSkills: requiredSkills,
        requiredResources: requiredResources,
        createdAt: now,
        updatedAt: now,
      );

      // Note: Validation should be done by repository/controller before calling service

      // Salva no Firestore
      await _eventsCollection.doc(eventId).set(event.toFirestore());

      return event;
    } catch (e) {
      if (e is ValidationException) rethrow;
      throw DatabaseException('Erro ao criar evento: ${e.toString()}');
    }
  }

  /// Busca um evento por ID
  Future<EventModel?> getEventById(String eventId) async {
    try {
      final doc = await _eventsCollection.doc(eventId).get();

      if (!doc.exists) return null;

      return EventModel.fromFirestore(doc);
    } catch (e) {
      throw DatabaseException('Erro ao buscar evento: ${e.toString()}');
    }
  }

  /// Busca um evento por tag
  Future<EventModel?> getEventByTag(String tag) async {
    try {
      final query = await _eventsCollection
          .where('tag', isEqualTo: tag.toUpperCase())
          .limit(1)
          .get();

      if (query.docs.isEmpty) return null;

      return EventModel.fromFirestore(query.docs.first);
    } catch (e) {
      throw DatabaseException('Erro ao buscar evento por tag: ${e.toString()}');
    }
  }

  /// Busca eventos onde o usu√°rio √© participante (gerenciador ou volunt√°rio)
  Future<List<EventModel>> getUserEvents(String userId) async {
    try {
      // Busca eventos onde o usu√°rio √© gerenciador
      final managerQuery = await _eventsCollection
          .where('managers', arrayContains: userId)
          .get();

      // Busca eventos onde o usu√°rio √© volunt√°rio
      final volunteerQuery = await _eventsCollection
          .where('volunteers', arrayContains: userId)
          .get();

      // Combina os resultados evitando duplicatas
      final eventIds = <String>{};
      final events = <EventModel>[];

      for (final doc in [...managerQuery.docs, ...volunteerQuery.docs]) {
        if (!eventIds.contains(doc.id)) {
          eventIds.add(doc.id);
          events.add(EventModel.fromFirestore(doc));
        }
      }

      // Ordena por data de cria√ß√£o (mais recentes primeiro)
      events.sort((a, b) => b.createdAt.compareTo(a.createdAt));

      return events;
    } catch (e) {
      throw DatabaseException(
        'Erro ao buscar eventos do usu√°rio: ${e.toString()}',
      );
    }
  }

  /// Atualiza um evento
  Future<EventModel> updateEvent(EventModel event) async {
    try {
      // Note: Validation should be done by repository/controller before calling service

      final updatedEvent = event.withUpdatedTimestamp();

      await _eventsCollection.doc(event.id).update(updatedEvent.toFirestore());

      return updatedEvent;
    } catch (e) {
      if (e is ValidationException) rethrow;
      throw DatabaseException('Erro ao atualizar evento: ${e.toString()}');
    }
  }

  /// Adiciona um volunt√°rio ao evento
  Future<EventModel> addVolunteerToEvent(String eventId, String userId) async {
    try {
      final event = await getEventById(eventId);
      if (event == null) {
        throw NotFoundException('Evento n√£o encontrado');
      }

      // Verifica se o usu√°rio j√° √© participante
      if (event.isParticipant(userId)) {
        throw ValidationException('Usu√°rio j√° √© participante do evento');
      }

      final updatedEvent = event.addVolunteer(userId);
      return await updateEvent(updatedEvent);
    } catch (e) {
      if (e is AppException) rethrow;
      throw DatabaseException('Erro ao adicionar volunt√°rio: ${e.toString()}');
    }
  }

  /// Remove um volunt√°rio do evento
  Future<EventModel> removeVolunteerFromEvent(
    String eventId,
    String userId,
  ) async {
    try {
      final event = await getEventById(eventId);
      if (event == null) {
        throw NotFoundException('Evento n√£o encontrado');
      }

      if (!event.isVolunteer(userId)) {
        throw ValidationException('Usu√°rio n√£o √© volunt√°rio do evento');
      }

      final updatedEvent = event.removeVolunteer(userId);
      return await updateEvent(updatedEvent);
    } catch (e) {
      if (e is AppException) rethrow;
      throw DatabaseException('Erro ao remover volunt√°rio: ${e.toString()}');
    }
  }

  /// Promove um volunt√°rio a gerenciador
  Future<EventModel> promoteVolunteerToManager(
    String eventId,
    String userId,
  ) async {
    try {
      final event = await getEventById(eventId);
      if (event == null) {
        throw NotFoundException('Evento n√£o encontrado');
      }

      if (!event.isVolunteer(userId)) {
        throw ValidationException('Usu√°rio n√£o √© volunt√°rio do evento');
      }

      final updatedEvent = event.promoteToManager(userId);
      return await updateEvent(updatedEvent);
    } catch (e) {
      if (e is AppException) rethrow;
      throw DatabaseException('Erro ao promover volunt√°rio: ${e.toString()}');
    }
  }

  /// Cria um perfil de volunt√°rio
  Future<VolunteerProfileModel> createVolunteerProfile({
    required String userId,
    required String eventId,
    required List<String> availableDays,
    required TimeRange availableHours,
    bool isFullTimeAvailable = false,
    required List<String> skills,
    required List<String> resources,
    required String userName,
    required String userEmail,
    String? userPhotoUrl,
  }) async {
    try {
      // Gera um ID √∫nico para o perfil
      final profileId = _uuid.v4();
      final now = DateTime.now();

      // Cria o perfil com dados gerados pelo service
      final profile = VolunteerProfileModel.create(
        id: profileId,
        userId: userId,
        eventId: eventId,
        availableDays: availableDays,
        availableHours: availableHours,
        isFullTimeAvailable: isFullTimeAvailable,
        skills: skills,
        resources: resources,
        assignedMicrotasksCount: 0,
        userName: userName,
        userEmail: userEmail,
        userPhotoUrl: userPhotoUrl,
        joinedAt: now,
      );

      // Note: Validation should be done by repository/controller before calling service

      // Salva no Firestore
      await _volunteerProfilesCollection
          .doc(profileId)
          .set(profile.toFirestore());

      return profile;
    } catch (e) {
      if (e is ValidationException) rethrow;
      throw DatabaseException(
        'Erro ao criar perfil de volunt√°rio: ${e.toString()}',
      );
    }
  }

  /// Busca o perfil de um volunt√°rio em um evento
  Future<VolunteerProfileModel?> getVolunteerProfile(
    String userId,
    String eventId,
  ) async {
    try {
      print('ABACAXI_B1:$userId $eventId');
      final query = await _volunteerProfilesCollection
          .where('userId', isEqualTo: userId)
          .where('eventId', isEqualTo: eventId)
          .limit(1)
          .get();

      if (query.docs.isEmpty) return null;

      return VolunteerProfileModel.fromFirestore(query.docs.first);
    } catch (e) {
      print('Erro ao buscar perfil de volunt√°rio: ${e.toString()}');
      throw DatabaseException(
        'Erro ao buscar perfil de volunt√°rio: ${e.toString()}',
      );
    }
  }

  /// Busca todos os perfis de volunt√°rios de um evento
  Future<List<VolunteerProfileModel>> getEventVolunteerProfiles(
    String eventId,
  ) async {
    try {
      final query = await _volunteerProfilesCollection
          .where('eventId', isEqualTo: eventId)
          .get();

      final profiles = <VolunteerProfileModel>[];

      for (final doc in query.docs) {
        var profile = VolunteerProfileModel.fromFirestore(doc);

        // Se o perfil n√£o tem dados do usu√°rio, busca e atualiza
        if (!profile.hasValidUserData) {
          final userData = await _getUserData(profile.userId);
          if (userData != null) {
            profile = profile.updateUserData(
              userName: userData['name'] as String? ?? '',
              userEmail: userData['email'] as String? ?? '',
              userPhotoUrl: userData['photoUrl'] as String?,
            );

            // Atualiza o perfil no banco com os dados do usu√°rio
            try {
              await _volunteerProfilesCollection.doc(profile.id).update({
                'userName': profile.userName,
                'userEmail': profile.userEmail,
                'userPhotoUrl': profile.userPhotoUrl,
              });
            } catch (e) {
              // Ignora erros de atualiza√ß√£o para n√£o quebrar o fluxo
            }
          }
        }

        profiles.add(profile);
      }

      return profiles;
    } catch (e) {
      print('Erro ao buscar perfil de volunt√°rio: ${e.toString()}');
      throw DatabaseException(
        'Erro ao buscar perfis de volunt√°rios: ${e.toString()}',
      );
    }
  }

  /// Atualiza um perfil de volunt√°rio
  Future<VolunteerProfileModel> updateVolunteerProfile(
    VolunteerProfileModel profile,
  ) async {
    try {
      // Valida os dados antes de salvar
      final validationErrors = profile.validate();
      if (validationErrors.isNotEmpty) {
        throw ValidationException(
          'Dados inv√°lidos: ${validationErrors.join(', ')}',
        );
      }

      await _volunteerProfilesCollection
          .doc(profile.id)
          .update(profile.toFirestore());

      return profile;
    } catch (e) {
      print('Erro ao buscar perfil de volunt√°rio: ${e.toString()}');
      if (e is ValidationException) rethrow;
      throw DatabaseException(
        'Erro ao atualizar perfil de volunt√°rio: ${e.toString()}',
      );
    }
  }

  /// Deleta um evento (apenas o criador pode fazer isso)
  Future<void> deleteEvent(String eventId, String userId) async {
    try {
      final event = await getEventById(eventId);
      if (event == null) {
        throw NotFoundException('Evento n√£o encontrado');
      }

      if (!event.isCreator(userId)) {
        throw UnauthorizedException('Apenas o criador pode deletar o evento');
      }

      // Deleta todos os perfis de volunt√°rios relacionados
      final profiles = await getEventVolunteerProfiles(eventId);
      for (final profile in profiles) {
        await _volunteerProfilesCollection.doc(profile.id).delete();
      }

      // Deleta o evento
      await _eventsCollection.doc(eventId).delete();
    } catch (e) {
      if (e is AppException) rethrow;
      throw DatabaseException('Erro ao deletar evento: ${e.toString()}');
    }
  }

  /// Verifica se uma tag j√° est√° sendo usada
  Future<bool> _isTagTaken(String tag) async {
    try {
      final query = await _eventsCollection
          .where('tag', isEqualTo: tag)
          .limit(1)
          .get();

      return query.docs.isNotEmpty;
    } catch (e) {
      return false; // Em caso de erro, assume que n√£o est√° sendo usada
    }
  }

  /// Gera uma tag √∫nica para o evento
  String _generateUniqueTag() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    final random = DateTime.now().millisecondsSinceEpoch;
    var result = '';

    for (int i = 0; i < 6; i++) {
      result += chars[(random + i * 7) % chars.length];
    }

    return result;
  }

  /// Incrementa o contador de microtasks atribu√≠das para um volunt√°rio
  Future<void> incrementVolunteerMicrotaskCount(
    String eventId,
    String userId,
  ) async {
    try {
      final profileQuery = await _volunteerProfilesCollection
          .where('eventId', isEqualTo: eventId)
          .where('userId', isEqualTo: userId)
          .limit(1)
          .get();

      if (profileQuery.docs.isNotEmpty) {
        final doc = profileQuery.docs.first;
        final currentData = doc.data() as Map<String, dynamic>;

        // Verifica se o campo existe, se n√£o, inicializa com contagem real
        int assignedCount;
        if (currentData.containsKey('assignedMicrotasksCount')) {
          assignedCount = currentData['assignedMicrotasksCount'] as int? ?? 0;
        } else {
          // Campo n√£o existe, calcula a contagem real e inicializa
          assignedCount = await _calculateActualMicrotaskCount(eventId, userId);
        }

        await doc.reference.update({
          'assignedMicrotasksCount': assignedCount + 1,
        });
      }
    } catch (e) {
      throw DatabaseException(
        'Erro ao incrementar contador de microtasks: ${e.toString()}',
      );
    }
  }

  /// Decrementa o contador de microtasks atribu√≠das para um volunt√°rio
  Future<void> decrementVolunteerMicrotaskCount(
    String eventId,
    String userId,
  ) async {
    try {
      final profileQuery = await _volunteerProfilesCollection
          .where('eventId', isEqualTo: eventId)
          .where('userId', isEqualTo: userId)
          .limit(1)
          .get();

      if (profileQuery.docs.isNotEmpty) {
        final doc = profileQuery.docs.first;
        final currentData = doc.data() as Map<String, dynamic>;

        // Verifica se o campo existe, se n√£o, inicializa com contagem real
        int assignedCount;
        if (currentData.containsKey('assignedMicrotasksCount')) {
          assignedCount = currentData['assignedMicrotasksCount'] as int? ?? 0;
        } else {
          // Campo n√£o existe, calcula a contagem real e inicializa
          assignedCount = await _calculateActualMicrotaskCount(eventId, userId);
        }

        await doc.reference.update({
          'assignedMicrotasksCount': assignedCount > 0 ? assignedCount - 1 : 0,
        });
      }
    } catch (e) {
      throw DatabaseException(
        'Erro ao decrementar contador de microtasks: ${e.toString()}',
      );
    }
  }

  /// Stream para escutar mudan√ßas em um evento
  Stream<EventModel?> watchEvent(String eventId) {
    return _eventsCollection.doc(eventId).snapshots().map((doc) {
      if (!doc.exists) return null;
      return EventModel.fromFirestore(doc);
    });
  }

  /// Stream para escutar mudan√ßas nos eventos do usu√°rio
  Stream<List<EventModel>> watchUserEvents(String userId) {
    // Implementa√ß√£o simplificada - pode ser otimizada
    return Stream.periodic(
      const Duration(seconds: 5),
    ).asyncMap((_) => getUserEvents(userId));
  }

  /// Calcula a contagem real de microtasks atribu√≠das a um volunt√°rio
  /// consultando diretamente as microtasks no banco de dados
  Future<int> _calculateActualMicrotaskCount(
    String eventId,
    String userId,
  ) async {
    try {
      final microtasksQuery = await _firestore
          .collection('microtasks')
          .where('eventId', isEqualTo: eventId)
          .where('assignedTo', arrayContains: userId)
          .get();

      return microtasksQuery.docs.length;
    } catch (e) {
      // Em caso de erro, retorna 0 para n√£o quebrar o fluxo
      print('Erro ao calcular contagem real de microtasks: $e');
      return 0;
    }
  }

  /// Migra perfis de volunt√°rios existentes para incluir o campo assignedMicrotasksCount
  /// Este m√©todo deve ser chamado uma vez para migrar dados existentes
  Future<void> migrateVolunteerProfilesTaskCounts() async {
    try {
      // Busca todos os perfis que n√£o t√™m o campo assignedMicrotasksCount
      final profilesQuery = await _volunteerProfilesCollection.get();

      final batch = _firestore.batch();
      int batchCount = 0;

      for (final doc in profilesQuery.docs) {
        final data = doc.data() as Map<String, dynamic>;

        // Verifica se o campo n√£o existe
        if (!data.containsKey('assignedMicrotasksCount')) {
          final eventId = data['eventId'] as String;
          final userId = data['userId'] as String;

          // Calcula a contagem real
          final actualCount = await _calculateActualMicrotaskCount(
            eventId,
            userId,
          );

          // Adiciona a atualiza√ß√£o ao batch
          batch.update(doc.reference, {'assignedMicrotasksCount': actualCount});

          batchCount++;

          // Executa o batch a cada 500 opera√ß√µes para evitar limites do Firestore
          if (batchCount >= 500) {
            await batch.commit();
            batchCount = 0;
          }
        }
      }

      // Executa o batch final se houver opera√ß√µes pendentes
      if (batchCount > 0) {
        await batch.commit();
      }

      print('Migra√ß√£o de perfis de volunt√°rios conclu√≠da com sucesso');
    } catch (e) {
      throw DatabaseException(
        'Erro ao migrar perfis de volunt√°rios: ${e.toString()}',
      );
    }
  }

  /// Recalcula e corrige o contador de microtasks para um volunt√°rio espec√≠fico
  Future<void> recalculateVolunteerMicrotaskCount(
    String eventId,
    String userId,
  ) async {
    try {
      final profileQuery = await _volunteerProfilesCollection
          .where('eventId', isEqualTo: eventId)
          .where('userId', isEqualTo: userId)
          .limit(1)
          .get();

      if (profileQuery.docs.isNotEmpty) {
        final doc = profileQuery.docs.first;
        final actualCount = await _calculateActualMicrotaskCount(
          eventId,
          userId,
        );

        await doc.reference.update({'assignedMicrotasksCount': actualCount});
      }
    } catch (e) {
      throw DatabaseException(
        'Erro ao recalcular contador de microtasks: ${e.toString()}',
      );
    }
  }

  /// Recalcula os contadores para todos os volunt√°rios de um evento
  Future<void> recalculateEventVolunteerCounts(String eventId) async {
    try {
      final profilesQuery = await _volunteerProfilesCollection
          .where('eventId', isEqualTo: eventId)
          .get();

      final batch = _firestore.batch();
      int batchCount = 0;

      for (final doc in profilesQuery.docs) {
        final data = doc.data() as Map<String, dynamic>;
        final userId = data['userId'] as String;

        final actualCount = await _calculateActualMicrotaskCount(
          eventId,
          userId,
        );

        batch.update(doc.reference, {'assignedMicrotasksCount': actualCount});

        batchCount++;

        // Executa o batch a cada 500 opera√ß√µes
        if (batchCount >= 500) {
          await batch.commit();
          batchCount = 0;
        }
      }

      // Executa o batch final se houver opera√ß√µes pendentes
      if (batchCount > 0) {
        await batch.commit();
      }
    } catch (e) {
      throw DatabaseException(
        'Erro ao recalcular contadores do evento: ${e.toString()}',
      );
    }
  }

  /// Busca dados do usu√°rio para denormaliza√ß√£o
  Future<Map<String, dynamic>?> _getUserData(String userId) async {
    try {
      final userDoc = await _firestore.collection('users').doc(userId).get();
      if (userDoc.exists) {
        return userDoc.data();
      }
      return null;
    } catch (e) {
      // Em caso de erro, retorna null para n√£o quebrar o fluxo
      print('Erro ao buscar dados do usu√°rio: $e');
      return null;
    }
  }

  /// Atualiza dados do usu√°rio em todos os perfis de volunt√°rio
  Future<void> updateUserDataInVolunteerProfiles(
    String userId,
    String userName,
    String userEmail,
    String? userPhotoUrl,
  ) async {
    try {
      final profilesQuery = await _volunteerProfilesCollection
          .where('userId', isEqualTo: userId)
          .get();

      final batch = _firestore.batch();
      int batchCount = 0;

      for (final doc in profilesQuery.docs) {
        batch.update(doc.reference, {
          'userName': userName,
          'userEmail': userEmail,
          'userPhotoUrl': userPhotoUrl,
        });

        batchCount++;

        // Executa o batch a cada 500 opera√ß√µes
        if (batchCount >= 500) {
          await batch.commit();
          batchCount = 0;
        }
      }

      // Executa o batch final se houver opera√ß√µes pendentes
      if (batchCount > 0) {
        await batch.commit();
      }
    } catch (e) {
      throw DatabaseException(
        'Erro ao atualizar dados do usu√°rio nos perfis: ${e.toString()}',
      );
    }
  }
}

## lib\data\models\event_model.dart <a id="event_model_dart"></a>

### Dependencies

- `package:cloud_firestore/cloud_firestore.dart`

import 'package:cloud_firestore/cloud_firestore.dart';

/// Modelo de dados para representar um evento no sistema
/// Baseado na estrutura definida no SPEC_GERAL.md
class EventModel {
  final String id;
  final String name;
  final String description;
  final String tag;
  final String location;
  final String createdBy;
  final List<String> managers;
  final List<String> volunteers;
  final List<String> requiredSkills;
  final List<String> requiredResources;
  final EventStatus status;
  final DateTime createdAt;
  final DateTime updatedAt;

  const EventModel({
    required this.id,
    required this.name,
    required this.description,
    required this.tag,
    required this.location,
    required this.createdBy,
    required this.managers,
    required this.volunteers,
    required this.requiredSkills,
    required this.requiredResources,
    required this.status,
    required this.createdAt,
    required this.updatedAt,
  });

  /// Cria uma inst√¢ncia de EventModel a partir de um Map (JSON)
  factory EventModel.fromMap(Map<String, dynamic> map) {
    return EventModel(
      id: map['id'] as String,
      name: map['name'] as String,
      description: map['description'] as String,
      tag: map['tag'] as String,
      location: map['location'] as String,
      createdBy: map['createdBy'] as String,
      managers: List<String>.from(map['managers'] as List),
      volunteers: List<String>.from(map['volunteers'] as List),
      requiredSkills: List<String>.from(map['requiredSkills'] as List),
      requiredResources: List<String>.from(map['requiredResources'] as List),
      status: EventStatus.fromString(map['status'] as String),
      createdAt: (map['createdAt'] as Timestamp).toDate(),
      updatedAt: (map['updatedAt'] as Timestamp).toDate(),
    );
  }

  /// Cria uma inst√¢ncia de EventModel a partir de um DocumentSnapshot do Firestore
  factory EventModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return EventModel.fromMap({'id': doc.id, ...data});
  }

  /// Converte a inst√¢ncia para um Map (JSON)
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'tag': tag,
      'location': location,
      'createdBy': createdBy,
      'managers': managers,
      'volunteers': volunteers,
      'requiredSkills': requiredSkills,
      'requiredResources': requiredResources,
      'status': status.value,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
    };
  }

  /// Converte para Map sem o ID (usado para criar documentos no Firestore)
  Map<String, dynamic> toFirestore() {
    final map = toMap();
    map.remove('id'); // Remove o ID pois ser√° gerado pelo Firestore
    return map;
  }

  /// Cria uma c√≥pia da inst√¢ncia com alguns campos alterados
  EventModel copyWith({
    String? id,
    String? name,
    String? description,
    String? tag,
    String? location,
    String? createdBy,
    List<String>? managers,
    List<String>? volunteers,
    List<String>? requiredSkills,
    List<String>? requiredResources,
    EventStatus? status,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return EventModel(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      tag: tag ?? this.tag,
      location: location ?? this.location,
      createdBy: createdBy ?? this.createdBy,
      managers: managers ?? List<String>.from(this.managers),
      volunteers: volunteers ?? List<String>.from(this.volunteers),
      requiredSkills: requiredSkills ?? List<String>.from(this.requiredSkills),
      requiredResources:
          requiredResources ?? List<String>.from(this.requiredResources),
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  /// Cria uma nova inst√¢ncia com updatedAt atualizado para agora
  EventModel withUpdatedTimestamp() {
    return copyWith(updatedAt: DateTime.now());
  }

  /// Verifica se o usu√°rio √© gerenciador do evento
  bool isManager(String userId) {
    return managers.contains(userId);
  }

  /// Verifica se o usu√°rio √© volunt√°rio do evento
  bool isVolunteer(String userId) {
    return volunteers.contains(userId);
  }

  /// Verifica se o usu√°rio √© participante (gerenciador ou volunt√°rio)
  bool isParticipant(String userId) {
    return isManager(userId) || isVolunteer(userId);
  }

  /// Verifica se o usu√°rio √© o criador do evento
  bool isCreator(String userId) {
    return createdBy == userId;
  }

  /// Adiciona um volunt√°rio ao evento
  EventModel addVolunteer(String userId) {
    if (volunteers.contains(userId)) return this;

    final newVolunteers = List<String>.from(volunteers)..add(userId);
    return copyWith(volunteers: newVolunteers).withUpdatedTimestamp();
  }

  /// Remove um volunt√°rio do evento
  EventModel removeVolunteer(String userId) {
    if (!volunteers.contains(userId)) return this;

    final newVolunteers = List<String>.from(volunteers)..remove(userId);
    return copyWith(volunteers: newVolunteers).withUpdatedTimestamp();
  }

  /// Promove um volunt√°rio a gerenciador
  EventModel promoteToManager(String userId) {
    if (managers.contains(userId)) return this;

    final newManagers = List<String>.from(managers)..add(userId);
    final newVolunteers = List<String>.from(volunteers)..remove(userId);

    return copyWith(
      managers: newManagers,
      volunteers: newVolunteers,
    ).withUpdatedTimestamp();
  }

  /// Remove um gerenciador (n√£o pode remover o criador)
  EventModel removeManager(String userId) {
    if (userId == createdBy || !managers.contains(userId)) return this;

    final newManagers = List<String>.from(managers)..remove(userId);
    return copyWith(managers: newManagers).withUpdatedTimestamp();
  }

  /// Retorna o n√∫mero total de participantes
  int get totalParticipants => managers.length + volunteers.length;

  /// Retorna o papel do usu√°rio no evento
  UserRole getUserRole(String userId) {
    if (createdBy == userId) return UserRole.creator;
    if (managers.contains(userId)) return UserRole.manager;
    if (volunteers.contains(userId)) return UserRole.volunteer;
    return UserRole.none;
  }

  /// Valida se os dados do evento s√£o v√°lidos
  bool isValid() {
    return id.isNotEmpty &&
        name.isNotEmpty &&
        tag.isNotEmpty &&
        location.isNotEmpty &&
        createdBy.isNotEmpty &&
        managers.isNotEmpty &&
        managers.contains(createdBy);
  }

  /// Factory para criar um novo evento
  /// Note: ID, tag e timestamps devem ser definidos pelo service
  factory EventModel.create({
    required String id,
    required String name,
    required String description,
    required String tag,
    required String location,
    required String createdBy,
    required List<String> requiredSkills,
    required List<String> requiredResources,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) {
    return EventModel(
      id: id,
      name: name,
      description: description,
      tag: tag,
      location: location,
      createdBy: createdBy,
      managers: [createdBy], // Criador √© automaticamente gerenciador
      volunteers: [],
      requiredSkills: requiredSkills,
      requiredResources: requiredResources,
      status: EventStatus.active,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  /// Converte para string para debug
  @override
  String toString() {
    return 'EventModel(id: $id, name: $name, tag: $tag, status: ${status.value}, participants: $totalParticipants)';
  }

  /// Implementa igualdade baseada no ID
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is EventModel && other.id == id;
  }

  /// Implementa hashCode baseado no ID
  @override
  int get hashCode => id.hashCode;

  /// M√©todo para validar dados antes de salvar
  List<String> validate() {
    final errors = <String>[];

    if (id.isEmpty) {
      errors.add('ID √© obrigat√≥rio');
    }

    if (name.isEmpty) {
      errors.add('Nome √© obrigat√≥rio');
    } else if (name.length < 3) {
      errors.add('Nome deve ter pelo menos 3 caracteres');
    } else if (name.length > 100) {
      errors.add('Nome deve ter no m√°ximo 100 caracteres');
    }

    if (description.length > 500) {
      errors.add('Descri√ß√£o deve ter no m√°ximo 500 caracteres');
    }

    if (tag.isEmpty) {
      errors.add('Tag √© obrigat√≥ria');
    } else if (tag.length != 6) {
      errors.add('Tag deve ter exatamente 6 caracteres');
    }

    if (location.isEmpty) {
      errors.add('Localiza√ß√£o √© obrigat√≥ria');
    } else if (location.length > 200) {
      errors.add('Localiza√ß√£o deve ter no m√°ximo 200 caracteres');
    }

    if (createdBy.isEmpty) {
      errors.add('Criador √© obrigat√≥rio');
    }

    if (managers.isEmpty) {
      errors.add('Deve haver pelo menos um gerenciador');
    }

    if (!managers.contains(createdBy)) {
      errors.add('Criador deve ser um gerenciador');
    }

    return errors;
  }

  /// Retorna h√° quanto tempo o evento foi criado
  String get createdTimeAgo {
    final now = DateTime.now();
    final difference = now.difference(createdAt);

    if (difference.inDays > 0) {
      return '${difference.inDays} dia${difference.inDays > 1 ? 's' : ''} atr√°s';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} hora${difference.inHours > 1 ? 's' : ''} atr√°s';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} minuto${difference.inMinutes > 1 ? 's' : ''} atr√°s';
    } else {
      return 'Agora mesmo';
    }
  }

  /// Retorna h√° quanto tempo o evento foi atualizado
  String get updatedTimeAgo {
    final now = DateTime.now();
    final difference = now.difference(updatedAt);

    if (difference.inDays > 0) {
      return '${difference.inDays} dia${difference.inDays > 1 ? 's' : ''} atr√°s';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} hora${difference.inHours > 1 ? 's' : ''} atr√°s';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} minuto${difference.inMinutes > 1 ? 's' : ''} atr√°s';
    } else {
      return 'Agora mesmo';
    }
  }

  /// Verifica se o evento foi criado recentemente (√∫ltimas 24 horas)
  bool get isNewEvent {
    final now = DateTime.now();
    final difference = now.difference(createdAt);
    return difference.inHours < 24;
  }

  /// Retorna uma vers√£o resumida da descri√ß√£o
  String get shortDescription {
    if (description.length <= 100) return description;
    return '${description.substring(0, 97)}...';
  }

  /// Retorna as habilidades como string formatada
  String get skillsText {
    if (requiredSkills.isEmpty) return 'Nenhuma habilidade espec√≠fica';
    return requiredSkills.join(', ');
  }

  /// Retorna os recursos como string formatada
  String get resourcesText {
    if (requiredResources.isEmpty) return 'Nenhum recurso espec√≠fico';
    return requiredResources.join(', ');
  }

  /// Atualiza o status do evento
  EventModel updateStatus(EventStatus newStatus) {
    return copyWith(status: newStatus).withUpdatedTimestamp();
  }

  /// Adiciona uma habilidade necess√°ria
  EventModel addRequiredSkill(String skill) {
    if (requiredSkills.contains(skill)) return this;

    final newSkills = List<String>.from(requiredSkills)..add(skill);
    return copyWith(requiredSkills: newSkills).withUpdatedTimestamp();
  }

  /// Remove uma habilidade necess√°ria
  EventModel removeRequiredSkill(String skill) {
    if (!requiredSkills.contains(skill)) return this;

    final newSkills = List<String>.from(requiredSkills)..remove(skill);
    return copyWith(requiredSkills: newSkills).withUpdatedTimestamp();
  }

  /// Adiciona um recurso necess√°rio
  EventModel addRequiredResource(String resource) {
    if (requiredResources.contains(resource)) return this;

    final newResources = List<String>.from(requiredResources)..add(resource);
    return copyWith(requiredResources: newResources).withUpdatedTimestamp();
  }

  /// Remove um recurso necess√°rio
  EventModel removeRequiredResource(String resource) {
    if (!requiredResources.contains(resource)) return this;

    final newResources = List<String>.from(requiredResources)..remove(resource);
    return copyWith(requiredResources: newResources).withUpdatedTimestamp();
  }
}

/// Enum para representar o status do evento
enum EventStatus {
  active('active'),
  completed('completed'),
  cancelled('cancelled');

  const EventStatus(this.value);
  final String value;

  static EventStatus fromString(String value) {
    return EventStatus.values.firstWhere(
      (status) => status.value == value,
      orElse: () => EventStatus.active,
    );
  }

  String get displayName {
    switch (this) {
      case EventStatus.active:
        return 'Ativo';
      case EventStatus.completed:
        return 'Conclu√≠do';
      case EventStatus.cancelled:
        return 'Cancelado';
    }
  }
}

/// Enum para representar o papel do usu√°rio no evento
enum UserRole {
  creator('creator'),
  manager('manager'),
  volunteer('volunteer'),
  none('none');

  const UserRole(this.value);
  final String value;

  String get displayName {
    switch (this) {
      case UserRole.creator:
        return 'Criador';
      case UserRole.manager:
        return 'Gerenciador';
      case UserRole.volunteer:
        return 'Volunt√°rio';
      case UserRole.none:
        return 'N√£o participante';
    }
  }
}

## lib\presentation\widgets\event\event_stats_widget.dart <a id="event_stats_widget_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/event_model.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/event_model.dart';

/// Widget para exibir estat√≠sticas de um evento
class EventStatsWidget extends StatelessWidget {
  final EventModel event;
  final bool showDetailed;

  const EventStatsWidget({
    super.key,
    required this.event,
    this.showDetailed = false,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: AppDimensions.elevationSm,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
      ),
      child: Padding(
        padding: const EdgeInsets.all(AppDimensions.paddingLg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // T√≠tulo
            const Row(
              children: [
                Icon(
                  Icons.analytics,
                  color: AppColors.primary,
                  size: 24,
                ),
                SizedBox(width: AppDimensions.spacingSm),
                Text(
                  'Estat√≠sticas do Evento',
                  style: TextStyle(
                    fontSize: AppDimensions.fontSizeLg,
                    fontWeight: FontWeight.bold,
                    color: AppColors.textPrimary,
                  ),
                ),
              ],
            ),

            const SizedBox(height: AppDimensions.spacingLg),

            // Estat√≠sticas b√°sicas
            _buildBasicStats(),

            if (showDetailed) ...[
              const SizedBox(height: AppDimensions.spacingLg),
              const Divider(),
              const SizedBox(height: AppDimensions.spacingLg),

              // Estat√≠sticas detalhadas
              _buildDetailedStats(),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildBasicStats() {
    return Row(
      children: [
        Expanded(
          child: _buildStatItem(
            icon: Icons.people,
            label: 'Participantes',
            value: event.totalParticipants.toString(),
            color: AppColors.primary,
          ),
        ),
        const SizedBox(width: AppDimensions.spacingMd),
        Expanded(
          child: _buildStatItem(
            icon: Icons.admin_panel_settings,
            label: 'Gerenciadores',
            value: event.managers.length.toString(),
            color: AppColors.secondary,
          ),
        ),
        const SizedBox(width: AppDimensions.spacingMd),
        Expanded(
          child: _buildStatItem(
            icon: Icons.volunteer_activism,
            label: 'Volunt√°rios',
            value: event.volunteers.length.toString(),
            color: AppColors.success,
          ),
        ),
      ],
    );
  }

  Widget _buildDetailedStats() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Habilidades necess√°rias
        _buildRequirementStats(
          title: 'Habilidades Necess√°rias',
          icon: Icons.psychology,
          items: event.requiredSkills,
          color: AppColors.info,
        ),

        const SizedBox(height: AppDimensions.spacingLg),

        // Recursos necess√°rios
        _buildRequirementStats(
          title: 'Recursos Necess√°rios',
          icon: Icons.inventory,
          items: event.requiredResources,
          color: AppColors.warning,
        ),

        const SizedBox(height: AppDimensions.spacingLg),

        // Informa√ß√µes temporais
        _buildTemporalInfo(),
      ],
    );
  }

  Widget _buildStatItem({
    required IconData icon,
    required String label,
    required String value,
    required Color color,
  }) {
    return Container(
      padding: const EdgeInsets.all(AppDimensions.paddingMd),
      decoration: BoxDecoration(
        color: color.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        border: Border.all(color: color.withValues(alpha: 0.3)),
      ),
      child: Column(
        children: [
          Icon(
            icon,
            color: color,
            size: 28,
          ),
          const SizedBox(height: AppDimensions.spacingSm),
          Text(
            value,
            style: TextStyle(
              fontSize: AppDimensions.fontSizeXl,
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingXs),
          Text(
            label,
            style: const TextStyle(
              fontSize: AppDimensions.fontSizeSm,
              color: AppColors.textSecondary,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildRequirementStats({
    required String title,
    required IconData icon,
    required List<String> items,
    required Color color,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(
              icon,
              color: color,
              size: 20,
            ),
            const SizedBox(width: AppDimensions.spacingSm),
            Text(
              title,
              style: TextStyle(
                fontSize: AppDimensions.fontSizeMd,
                fontWeight: FontWeight.w600,
                color: color,
              ),
            ),
            const Spacer(),
            Container(
              padding: const EdgeInsets.symmetric(
                horizontal: AppDimensions.paddingSm,
                vertical: AppDimensions.paddingXs,
              ),
              decoration: BoxDecoration(
                color: color.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(AppDimensions.radiusSm),
              ),
              child: Text(
                items.length.toString(),
                style: TextStyle(
                  fontSize: AppDimensions.fontSizeSm,
                  fontWeight: FontWeight.bold,
                  color: color,
                ),
              ),
            ),
          ],
        ),

        const SizedBox(height: AppDimensions.spacingSm),

        if (items.isEmpty)
          Text(
            'Nenhum item especificado',
            style: TextStyle(
              fontSize: AppDimensions.fontSizeMd,
              color: AppColors.textSecondary.withValues(alpha: 0.7),
              fontStyle: FontStyle.italic,
            ),
          )
        else
          Wrap(
            spacing: AppDimensions.spacingSm,
            runSpacing: AppDimensions.spacingSm,
            children: items.map((item) {
              return Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppDimensions.paddingSm,
                  vertical: AppDimensions.paddingXs,
                ),
                decoration: BoxDecoration(
                  color: color.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(AppDimensions.radiusSm),
                  border: Border.all(color: color.withValues(alpha: 0.3)),
                ),
                child: Text(
                  item,
                  style: TextStyle(
                    fontSize: AppDimensions.fontSizeSm,
                    color: color,
                  ),
                ),
              );
            }).toList(),
          ),
      ],
    );
  }

  Widget _buildTemporalInfo() {
    return Container(
      padding: const EdgeInsets.all(AppDimensions.paddingMd),
      decoration: BoxDecoration(
        color: AppColors.surface,
        borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        border: Border.all(color: AppColors.border),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Row(
            children: [
              Icon(
                Icons.schedule,
                color: AppColors.textSecondary,
                size: 20,
              ),
              SizedBox(width: AppDimensions.spacingSm),
              Text(
                'Informa√ß√µes Temporais',
                style: TextStyle(
                  fontSize: AppDimensions.fontSizeMd,
                  fontWeight: FontWeight.w600,
                  color: AppColors.textPrimary,
                ),
              ),
            ],
          ),

          const SizedBox(height: AppDimensions.spacingMd),

          // Data de cria√ß√£o
          _buildTemporalItem(
            icon: Icons.add_circle,
            label: 'Criado em',
            value: _formatDate(event.createdAt),
            subtitle: event.createdTimeAgo,
          ),

          const SizedBox(height: AppDimensions.spacingSm),

          // Data de atualiza√ß√£o
          if (event.createdAt != event.updatedAt)
            _buildTemporalItem(
              icon: Icons.update,
              label: '√öltima atualiza√ß√£o',
              value: _formatDate(event.updatedAt),
              subtitle: event.updatedTimeAgo,
            ),

          const SizedBox(height: AppDimensions.spacingSm),

          // Indicador de evento novo
          if (event.isNewEvent)
            Container(
              padding: const EdgeInsets.symmetric(
                horizontal: AppDimensions.paddingSm,
                vertical: AppDimensions.paddingXs,
              ),
              decoration: BoxDecoration(
                color: AppColors.success.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(AppDimensions.radiusSm),
                border: Border.all(color: AppColors.success.withValues(alpha: 0.3)),
              ),
              child: const Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    Icons.new_releases,
                    size: 16,
                    color: AppColors.success,
                  ),
                  SizedBox(width: AppDimensions.spacingXs),
                  Text(
                    'Evento Novo',
                    style: TextStyle(
                      fontSize: AppDimensions.fontSizeSm,
                      fontWeight: FontWeight.w600,
                      color: AppColors.success,
                    ),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildTemporalItem({
    required IconData icon,
    required String label,
    required String value,
    String? subtitle,
  }) {
    return Row(
      children: [
        Icon(
          icon,
          size: 16,
          color: AppColors.textSecondary,
        ),
        const SizedBox(width: AppDimensions.spacingSm),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                label,
                style: const TextStyle(
                  fontSize: AppDimensions.fontSizeSm,
                  color: AppColors.textSecondary,
                ),
              ),
              Text(
                value,
                style: const TextStyle(
                  fontSize: AppDimensions.fontSizeMd,
                  fontWeight: FontWeight.w500,
                  color: AppColors.textPrimary,
                ),
              ),
              if (subtitle != null)
                Text(
                  subtitle,
                  style: const TextStyle(
                    fontSize: AppDimensions.fontSizeXs,
                    color: AppColors.textSecondary,
                  ),
                ),
            ],
          ),
        ),
      ],
    );
  }

  String _formatDate(DateTime date) {
    return '${date.day.toString().padLeft(2, '0')}/${date.month.toString().padLeft(2, '0')}/${date.year} √†s ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
  }
}

## lib\firebase_options.dart <a id="firebase_options_dart"></a>

### Dependencies

- `firebase_options.dart`

// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: "[REDACTED]",
    appId: '1:407007104181:web:e47996ce88ac6067d942fc',
    messagingSenderId: '407007104181',
    projectId: 'contask-52156',
    authDomain: 'contask-52156.firebaseapp.com',
    storageBucket: 'contask-52156.firebasestorage.app',
    measurementId: 'G-JY0KQ9T96E',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: "[REDACTED]",
    appId: '1:407007104181:android:5deaa18342a8bb50d942fc',
    messagingSenderId: '407007104181',
    projectId: 'contask-52156',
    storageBucket: 'contask-52156.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: "[REDACTED]",
    appId: '1:407007104181:ios:1d95291a2dc4a755d942fc',
    messagingSenderId: '407007104181',
    projectId: 'contask-52156',
    storageBucket: 'contask-52156.firebasestorage.app',
    iosClientId: '407007104181-4rhd2d3mhu8j35rq9ehbuj3r4lov2jva.apps.googleusercontent.com',
    iosBundleId: 'com.example.contask',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: "[REDACTED]",
    appId: '1:407007104181:ios:1d95291a2dc4a755d942fc',
    messagingSenderId: '407007104181',
    projectId: 'contask-52156',
    storageBucket: 'contask-52156.firebasestorage.app',
    iosClientId: '407007104181-4rhd2d3mhu8j35rq9ehbuj3r4lov2jva.apps.googleusercontent.com',
    iosBundleId: 'com.example.contask',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: "[REDACTED]",
    appId: '1:407007104181:web:54e10aaa1ec1c479d942fc',
    messagingSenderId: '407007104181',
    projectId: 'contask-52156',
    authDomain: 'contask-52156.firebaseapp.com',
    storageBucket: 'contask-52156.firebasestorage.app',
    measurementId: 'G-EWHDP21GD0',
  );

}
## ios\Flutter\ephemeral\flutter_lldbinit <a id="flutter_lldbinit"></a>

#
# Generated file, do not edit.
#

command script import --relative-to-command-file flutter_lldb_helper.py

## firebase.json <a id="firebase_json"></a>

{"flutter":{"platforms":{"android":{"default":{"projectId":"contask-52156","appId":"1:407007104181:android:5deaa18342a8bb50d942fc","fileOutput":"android/app/google-services.json"}},"dart":{"lib/firebase_options.dart":{"projectId":"contask-52156","configurations":{"android":"1:407007104181:android:5deaa18342a8bb50d942fc","ios":"1:407007104181:ios:1d95291a2dc4a755d942fc","macos":"1:407007104181:ios:1d95291a2dc4a755d942fc","web":"1:407007104181:web:e47996ce88ac6067d942fc","windows":"1:407007104181:web:54e10aaa1ec1c479d942fc"}}}}}}
## macos\Flutter\ephemeral\flutter_export_environment.sh <a id="flutter_export_environment_sh"></a>

#!/bin/sh
# This is a generated file; do not edit or check into version control.
export "FLUTTER_ROOT=C:\Users\Pichau\Documents\victor_teste\projetoTCC\flutter"
export "FLUTTER_APPLICATION_PATH=C:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask"
export "COCOAPODS_PARALLEL_CODE_SIGN=true"
export "FLUTTER_BUILD_DIR=build"
export "FLUTTER_BUILD_NAME=1.0.0"
export "FLUTTER_BUILD_NUMBER=1"
export "DART_OBFUSCATION=false"
export "TRACK_WIDGET_CREATION=true"
export "TREE_SHAKE_ICONS=false"
export "PACKAGE_CONFIG=.dart_tool/package_config.json"

## ios\Flutter\flutter_export_environment.sh <a id="flutter_export_environment_sh"></a>

#!/bin/sh
# This is a generated file; do not edit or check into version control.
export "FLUTTER_ROOT=C:\Users\Pichau\Documents\victor_teste\projetoTCC\flutter"
export "FLUTTER_APPLICATION_PATH=C:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask"
export "COCOAPODS_PARALLEL_CODE_SIGN=true"
export "FLUTTER_TARGET=lib\main.dart"
export "FLUTTER_BUILD_DIR=build"
export "FLUTTER_BUILD_NAME=1.0.0"
export "FLUTTER_BUILD_NUMBER=1"
export "DART_OBFUSCATION=false"
export "TRACK_WIDGET_CREATION=true"
export "TREE_SHAKE_ICONS=false"
export "PACKAGE_CONFIG=.dart_tool/package_config.json"

## lib\core\utils\form_validators.dart <a id="form_validators_dart"></a>

/// Classe utilit√°ria para valida√ß√µes de formul√°rios
class FormValidators {
  FormValidators._();

  /// Valida se o campo n√£o est√° vazio
  static String? required(String? value, {String? fieldName}) {
    if (value == null || value.trim().isEmpty) {
      return '${fieldName ?? 'Campo'} √© obrigat√≥rio';
    }
    return null;
  }

  /// Valida email
  static String? email(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'E-mail √© obrigat√≥rio';
    }

    final emailRegex = RegExp(
      r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',
    );

    if (!emailRegex.hasMatch(value.trim())) {
      return 'E-mail inv√°lido';
    }

    return null;
  }

  /// Valida senha
  static String? password(String? value, {int minLength = 6}) {
    if (value == null || value.isEmpty) {
      return 'Senha √© obrigat√≥ria';
    }

    if (value.length < minLength) {
      return 'Senha deve ter pelo menos $minLength caracteres';
    }

    return null;
  }

  /// Valida confirma√ß√£o de senha
  static String? confirmPassword(String? value, String? originalPassword) {
    if (value == null || value.isEmpty) {
      return 'Confirma√ß√£o de senha √© obrigat√≥ria';
    }

    if (value != originalPassword) {
      return 'Senhas n√£o coincidem';
    }

    return null;
  }

  /// Valida nome
  static String? name(String? value, {int minLength = 2, int maxLength = 100}) {
    if (value == null || value.trim().isEmpty) {
      return 'Nome √© obrigat√≥rio';
    }

    final trimmedValue = value.trim();

    if (trimmedValue.length < minLength) {
      return 'Nome deve ter pelo menos $minLength caracteres';
    }

    if (trimmedValue.length > maxLength) {
      return 'Nome deve ter no m√°ximo $maxLength caracteres';
    }

    // Verifica se cont√©m apenas letras, espa√ßos e alguns caracteres especiais
    final nameRegex = RegExp(r"^[a-zA-Z√Ä-√ø\s'-]+$");
    if (!nameRegex.hasMatch(trimmedValue)) {
      return 'Nome cont√©m caracteres inv√°lidos';
    }

    return null;
  }

  /// Valida nome de evento
  static String? eventName(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'Nome do evento √© obrigat√≥rio';
    }

    final trimmedValue = value.trim();

    if (trimmedValue.length < 3) {
      return 'Nome deve ter pelo menos 3 caracteres';
    }

    if (trimmedValue.length > 100) {
      return 'Nome deve ter no m√°ximo 100 caracteres';
    }

    return null;
  }

  /// Valida descri√ß√£o
  static String? description(String? value, {int maxLength = 500}) {
    if (value != null && value.length > maxLength) {
      return 'Descri√ß√£o deve ter no m√°ximo $maxLength caracteres';
    }

    return null;
  }

  /// Valida localiza√ß√£o
  static String? location(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'Localiza√ß√£o √© obrigat√≥ria';
    }

    final trimmedValue = value.trim();

    if (trimmedValue.length > 200) {
      return 'Localiza√ß√£o deve ter no m√°ximo 200 caracteres';
    }

    return null;
  }

  /// Valida tag/c√≥digo de evento
  static String? eventTag(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'C√≥digo do evento √© obrigat√≥rio';
    }

    final trimmedValue = value.trim().toUpperCase();

    if (trimmedValue.length != 6) {
      return 'C√≥digo deve ter exatamente 6 caracteres';
    }

    // Verifica se cont√©m apenas letras e n√∫meros
    final tagRegex = RegExp(r'^[A-Z0-9]+$');
    if (!tagRegex.hasMatch(trimmedValue)) {
      return 'C√≥digo deve conter apenas letras e n√∫meros';
    }

    return null;
  }

  /// Valida lista n√£o vazia
  static String? nonEmptyList(List<dynamic>? list, {String? fieldName}) {
    if (list == null || list.isEmpty) {
      return '${fieldName ?? 'Lista'} n√£o pode estar vazia';
    }
    return null;
  }

  /// Valida hor√°rio
  static String? timeRange(String? startTime, String? endTime) {
    if (startTime == null || startTime.isEmpty) {
      return 'Hor√°rio de in√≠cio √© obrigat√≥rio';
    }

    if (endTime == null || endTime.isEmpty) {
      return 'Hor√°rio de fim √© obrigat√≥rio';
    }

    // Converte strings para compara√ß√£o
    final start = _parseTime(startTime);
    final end = _parseTime(endTime);

    if (start == null) {
      return 'Hor√°rio de in√≠cio inv√°lido';
    }

    if (end == null) {
      return 'Hor√°rio de fim inv√°lido';
    }

    if (start.isAfter(end) || start.isAtSameMomentAs(end)) {
      return 'Hor√°rio de in√≠cio deve ser anterior ao hor√°rio de fim';
    }

    return null;
  }

  /// Valida URL
  static String? url(String? value, {bool required = false}) {
    if (!required && (value == null || value.trim().isEmpty)) {
      return null;
    }

    if (value == null || value.trim().isEmpty) {
      return 'URL √© obrigat√≥ria';
    }

    final urlRegex = RegExp(
      r'^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$',
    );

    if (!urlRegex.hasMatch(value.trim())) {
      return 'URL inv√°lida';
    }

    return null;
  }

  /// Valida telefone (formato brasileiro)
  static String? phone(String? value, {bool required = false}) {
    if (!required && (value == null || value.trim().isEmpty)) {
      return null;
    }

    if (value == null || value.trim().isEmpty) {
      return 'Telefone √© obrigat√≥rio';
    }

    // Remove caracteres n√£o num√©ricos
    final numbersOnly = value.replaceAll(RegExp(r'[^0-9]'), '');

    // Verifica se tem 10 ou 11 d√≠gitos (telefone brasileiro)
    if (numbersOnly.length < 10 || numbersOnly.length > 11) {
      return 'Telefone deve ter 10 ou 11 d√≠gitos';
    }

    return null;
  }

  /// Combina m√∫ltiplos validadores
  static String? combine(List<String? Function()> validators) {
    for (final validator in validators) {
      final result = validator();
      if (result != null) {
        return result;
      }
    }
    return null;
  }

  /// Valida se o valor est√° dentro de um range num√©rico
  static String? numberRange(
    String? value, {
    required double min,
    required double max,
    String? fieldName,
  }) {
    if (value == null || value.trim().isEmpty) {
      return '${fieldName ?? 'Campo'} √© obrigat√≥rio';
    }

    final number = double.tryParse(value.trim());
    if (number == null) {
      return '${fieldName ?? 'Campo'} deve ser um n√∫mero v√°lido';
    }

    if (number < min || number > max) {
      return '${fieldName ?? 'Campo'} deve estar entre $min e $max';
    }

    return null;
  }

  /// Valida comprimento m√≠nimo e m√°ximo
  static String? length(
    String? value, {
    int? min,
    int? max,
    String? fieldName,
  }) {
    if (value == null) {
      return '${fieldName ?? 'Campo'} √© obrigat√≥rio';
    }

    final length = value.length;

    if (min != null && length < min) {
      return '${fieldName ?? 'Campo'} deve ter pelo menos $min caracteres';
    }

    if (max != null && length > max) {
      return '${fieldName ?? 'Campo'} deve ter no m√°ximo $max caracteres';
    }

    return null;
  }

  /// M√©todo auxiliar para converter string de tempo em DateTime
  static DateTime? _parseTime(String timeString) {
    try {
      final parts = timeString.split(':');
      if (parts.length != 2) return null;

      final hour = int.parse(parts[0]);
      final minute = int.parse(parts[1]);

      if (hour < 0 || hour > 23 || minute < 0 || minute > 59) {
        return null;
      }

      final now = DateTime.now();
      return DateTime(now.year, now.month, now.day, hour, minute);
    } catch (e) {
      return null;
    }
  }
}

## windows\flutter\generated_plugin_registrant.cc <a id="generated_plugin_registrant_cc"></a>

### Dependencies

- `generated_plugin_registrant.h`
- `cloud_firestore/cloud_firestore_plugin_c_api.h`
- `firebase_auth/firebase_auth_plugin_c_api.h`
- `firebase_core/firebase_core_plugin_c_api.h`

//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"

#include <cloud_firestore/cloud_firestore_plugin_c_api.h>
#include <firebase_auth/firebase_auth_plugin_c_api.h>
#include <firebase_core/firebase_core_plugin_c_api.h>

void RegisterPlugins(flutter::PluginRegistry* registry) {
  CloudFirestorePluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("CloudFirestorePluginCApi"));
  FirebaseAuthPluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FirebaseAuthPluginCApi"));
  FirebaseCorePluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FirebaseCorePluginCApi"));
}

## android\app\google-services.json <a id="google-services_json"></a>

{
  "project_info": {
    "project_number": "407007104181",
    "project_id": "contask-52156",
    "storage_bucket": "contask-52156.firebasestorage.app"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:407007104181:android:5deaa18342a8bb50d942fc",
        "android_client_info": {
          "package_name": "com.example.contask"
        }
      },
      "oauth_client": [
        {
          "client_id": "407007104181-u8rjv708urkeds7ndjgblgpm94rmksil.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyByenvoJbzLpxtG8J1omzZ5R1Y4JhVnPK8"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "407007104181-u8rjv708urkeds7ndjgblgpm94rmksil.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "407007104181-4rhd2d3mhu8j35rq9ehbuj3r4lov2jva.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.example.contask"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:407007104181:android:78829fafe9143e6dd942fc",
        "android_client_info": {
          "package_name": "com.example.event_task_manager"
        }
      },
      "oauth_client": [
        {
          "client_id": "407007104181-u8rjv708urkeds7ndjgblgpm94rmksil.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyByenvoJbzLpxtG8J1omzZ5R1Y4JhVnPK8"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "407007104181-u8rjv708urkeds7ndjgblgpm94rmksil.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "407007104181-4rhd2d3mhu8j35rq9ehbuj3r4lov2jva.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.example.contask"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:407007104181:android:af7c472563cb761dd942fc",
        "android_client_info": {
          "package_name": "com.example.new_contaskcursor"
        }
      },
      "oauth_client": [
        {
          "client_id": "407007104181-u8rjv708urkeds7ndjgblgpm94rmksil.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyByenvoJbzLpxtG8J1omzZ5R1Y4JhVnPK8"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "407007104181-u8rjv708urkeds7ndjgblgpm94rmksil.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "407007104181-4rhd2d3mhu8j35rq9ehbuj3r4lov2jva.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.example.contask"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:407007104181:android:e761aae8bcb8debfd942fc",
        "android_client_info": {
          "package_name": "com.tasksevents.tasks_events_manager"
        }
      },
      "oauth_client": [
        {
          "client_id": "407007104181-u8rjv708urkeds7ndjgblgpm94rmksil.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyByenvoJbzLpxtG8J1omzZ5R1Y4JhVnPK8"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "407007104181-u8rjv708urkeds7ndjgblgpm94rmksil.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "407007104181-4rhd2d3mhu8j35rq9ehbuj3r4lov2jva.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.example.contask"
              }
            }
          ]
        }
      }
    }
  ],
  "configuration_version": "1"
}
## linux\flutter\generated_plugin_registrant.cc <a id="generated_plugin_registrant_cc"></a>

### Dependencies

- `generated_plugin_registrant.h`

//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"


void fl_register_plugins(FlPluginRegistry* registry) {
}

## android\gradlew <a id="gradlew"></a>

#!/usr/bin/env bash

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn ( ) {
    echo "$*"
}

die ( ) {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
esac

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
function splitJvmOpts() {
    JVM_OPTS=("$@")
}
eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"

exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"

## lib\presentation\screens\home\home_screen.dart <a id="home_screen_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `package:provider/provider.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../controllers/auth_controller.dart`
- `../../controllers/event_controller.dart`
- `../../widgets/common/custom_button.dart`
- `../../widgets/event/event_card.dart`
- `../../routes/app_routes.dart`

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../controllers/auth_controller.dart';
import '../../controllers/event_controller.dart';
import '../../widgets/common/custom_button.dart';
import '../../widgets/event/event_card.dart';
import '../../routes/app_routes.dart';

/// Tela home principal do aplicativo
/// Exibe lista de eventos do usu√°rio e op√ß√µes para criar/participar de eventos
class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadUserEvents();
    });
  }

  void _loadUserEvents() {
    final authController = Provider.of<AuthController>(context, listen: false);
    final eventController = Provider.of<EventController>(
      context,
      listen: false,
    );

    if (authController.currentUser != null) {
      eventController.loadUserEvents(authController.currentUser!.id);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.background,
      appBar: _buildAppBar(),
      body: Consumer2<AuthController, EventController>(
        builder: (context, authController, eventController, child) {
          final user = authController.currentUser;

          if (user == null) {
            return const Center(child: Text('Usu√°rio n√£o encontrado'));
          }

          return RefreshIndicator(
            onRefresh: () async => _loadUserEvents(),
            child: Column(
              children: [
                // Se√ß√£o de boas-vindas
                _buildWelcomeSection(user.displayName),

                // Lista de eventos
                Expanded(child: _buildEventsList(eventController)),
              ],
            ),
          );
        },
      ),
      floatingActionButton: _buildFloatingActionButton(),
    );
  }

  PreferredSizeWidget _buildAppBar() {
    return AppBar(
      backgroundColor: AppColors.primary,
      foregroundColor: AppColors.textOnPrimary,
      elevation: 0,
      title: const Text(
        'ConTask',
        style: TextStyle(fontWeight: FontWeight.bold),
      ),
      actions: [
        Consumer<AuthController>(
          builder: (context, authController, child) {
            final user = authController.currentUser;

            return Padding(
              padding: const EdgeInsets.only(right: AppDimensions.paddingMd),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  // Foto do usu√°rio ou iniciais
                  CircleAvatar(
                    radius: 16,
                    backgroundColor: AppColors.secondary,
                    backgroundImage: user?.hasPhoto == true
                        ? NetworkImage(user!.photoUrl!)
                        : null,
                    child: user?.hasPhoto != true
                        ? Text(
                            user?.initials ?? 'U',
                            style: const TextStyle(
                              color: AppColors.textOnPrimary,
                              fontSize: AppDimensions.fontSizeSm,
                              fontWeight: FontWeight.bold,
                            ),
                          )
                        : null,
                  ),
                  const SizedBox(width: AppDimensions.spacingSm),
                  // Menu de op√ß√µes
                  PopupMenuButton<String>(
                    icon: const Icon(Icons.more_vert),
                    onSelected: (value) {
                      if (value == 'logout') {
                        _handleLogout(context);
                      }
                    },
                    itemBuilder: (context) => [
                      const PopupMenuItem(
                        value: 'logout',
                        child: Row(
                          children: [
                            Icon(Icons.logout, size: 20),
                            SizedBox(width: AppDimensions.spacingSm),
                            Text('Sair'),
                          ],
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            );
          },
        ),
      ],
    );
  }

  Widget _buildWelcomeSection(String userName) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(AppDimensions.paddingLg),
      decoration: const BoxDecoration(
        color: AppColors.primary,
        borderRadius: BorderRadius.only(
          bottomLeft: Radius.circular(AppDimensions.radiusLg),
          bottomRight: Radius.circular(AppDimensions.radiusLg),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Ol√°, ${userName.split(' ').first}!',
            style: const TextStyle(
              fontSize: AppDimensions.fontSizeXl,
              fontWeight: FontWeight.bold,
              color: AppColors.textOnPrimary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingSm),
          Text(
            'Gerencie seus eventos e tarefas',
            style: TextStyle(
              fontSize: AppDimensions.fontSizeMd,
              color: AppColors.textOnPrimary.withValues(alpha: 0.9),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEventsList(EventController eventController) {
    if (eventController.isLoadingUserEvents) {
      return const Center(child: CircularProgressIndicator());
    }

    if (eventController.hasError) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 64, color: AppColors.error),
            const SizedBox(height: AppDimensions.spacingMd),
            Text(
              eventController.errorMessage ?? 'Erro desconhecido',
              style: const TextStyle(
                fontSize: AppDimensions.fontSizeMd,
                color: AppColors.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: AppDimensions.spacingMd),
            CustomButton.outline(
              text: 'Tentar novamente',
              onPressed: _loadUserEvents,
            ),
          ],
        ),
      );
    }

    if (eventController.userEvents.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(
              Icons.event_note,
              size: 64,
              color: AppColors.textSecondary,
            ),
            const SizedBox(height: AppDimensions.spacingMd),
            const Text(
              'Nenhum evento encontrado',
              style: TextStyle(
                fontSize: AppDimensions.fontSizeLg,
                fontWeight: FontWeight.w600,
                color: AppColors.textPrimary,
              ),
            ),
            const SizedBox(height: AppDimensions.spacingSm),
            const Text(
              'Crie um novo evento ou participe de um existente',
              style: TextStyle(
                fontSize: AppDimensions.fontSizeMd,
                color: AppColors.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: AppDimensions.spacingLg),
            CustomButton(
              text: 'Criar Evento',
              onPressed: () => _navigateToCreateEvent(),
            ),
            const SizedBox(height: AppDimensions.spacingSm),
            CustomButton.outline(
              text: 'Participar de Evento',
              onPressed: () => _navigateToJoinEvent(),
            ),
          ],
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(AppDimensions.paddingMd),
      itemCount: eventController.userEvents.length,
      itemBuilder: (context, index) {
        final event = eventController.userEvents[index];
        return Padding(
          padding: const EdgeInsets.only(bottom: AppDimensions.spacingMd),
          child: EventCard(
            event: event,
            onTap: () => _navigateToEventDetails(event.id),
          ),
        );
      },
    );
  }

  Widget _buildFloatingActionButton() {
    return FloatingActionButton(
      onPressed: () => _showActionDialog(),
      backgroundColor: AppColors.primary,
      child: const Icon(Icons.add, color: AppColors.textOnPrimary),
    );
  }

  void _showActionDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('O que voc√™ gostaria de fazer?'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.add_circle, color: AppColors.primary),
              title: const Text('Criar Evento'),
              subtitle: const Text('Organize um novo evento'),
              onTap: () {
                Navigator.of(context).pop(); // Fecha o dialog
                _navigateToCreateEvent();
              },
            ),
            ListTile(
              leading: const Icon(Icons.group_add, color: AppColors.secondary),
              title: const Text('Participar de Evento'),
              subtitle: const Text('Entre em um evento existente'),
              onTap: () {
                Navigator.of(context).pop(); // Fecha o dialog
                _navigateToJoinEvent();
              },
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancelar'),
          ),
        ],
      ),
    );
  }

  void _showActionBottomSheet() {
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(
          top: Radius.circular(AppDimensions.radiusLg),
        ),
      ),
      builder: (context) => Container(
        padding: const EdgeInsets.all(AppDimensions.paddingLg),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Indicador visual
            Container(
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: AppColors.textSecondary,
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            const SizedBox(height: AppDimensions.spacingLg),

            // T√≠tulo
            const Text(
              'O que voc√™ gostaria de fazer?',
              style: TextStyle(
                fontSize: AppDimensions.fontSizeLg,
                fontWeight: FontWeight.w600,
                color: AppColors.textPrimary,
              ),
            ),
            const SizedBox(height: AppDimensions.spacingLg),

            // Op√ß√µes
            ListTile(
              leading: const Icon(Icons.add_circle, color: AppColors.primary),
              title: const Text('Criar Evento'),
              subtitle: const Text('Organize um novo evento'),
              onTap: () {
                Navigator.pop(context);
                _navigateToCreateEvent();
              },
            ),
            ListTile(
              leading: const Icon(Icons.group_add, color: AppColors.secondary),
              title: const Text('Participar de Evento'),
              subtitle: const Text('Entre em um evento existente'),
              onTap: () {
                Navigator.pop(context);
                _navigateToJoinEvent();
              },
            ),

            const SizedBox(height: AppDimensions.spacingMd),
          ],
        ),
      ),
    );
  }

  void _navigateToCreateEvent() {
    AppRoutes.goToCreateEvent(context);
  }

  void _navigateToJoinEvent() {
    AppRoutes.goToJoinEvent(context);
  }

  void _navigateToEventDetails(String eventId) {
    AppRoutes.goToEventDetails(context, eventId);
  }

  Future<void> _handleLogout(BuildContext context) async {
    final authController = Provider.of<AuthController>(context, listen: false);

    await authController.signOut();

    if (context.mounted) {
      Navigator.of(context).pushNamedAndRemoveUntil('/login', (route) => false);
    }
  }
}

## web\index.html <a id="index_html"></a>

### Dependencies

- `flutter_bootstrap.js`

<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="contask">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>contask</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>

## android\app\src\main\res\drawable\launch_background.xml <a id="launch_background_xml"></a>

<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

## lib\presentation\screens\event\join_event_screen.dart <a id="join_event_screen_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `package:provider/provider.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/event_model.dart`
- `../../../data/models/volunteer_profile_model.dart`
- `../../controllers/auth_controller.dart`
- `../../controllers/event_controller.dart`
- `../../widgets/common/custom_button.dart`
- `../../widgets/common/custom_text_field.dart`
- `../../widgets/event/skill_chip.dart`

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/event_model.dart';
import '../../../data/models/volunteer_profile_model.dart';
import '../../controllers/auth_controller.dart';
import '../../controllers/event_controller.dart';
import '../../widgets/common/custom_button.dart';
import '../../widgets/common/custom_text_field.dart';
import '../../widgets/event/skill_chip.dart';

/// Tela para participar de eventos existentes via c√≥digo/tag
class JoinEventScreen extends StatefulWidget {
  const JoinEventScreen({super.key});

  @override
  State<JoinEventScreen> createState() => _JoinEventScreenState();
}

class _JoinEventScreenState extends State<JoinEventScreen> {
  final _formKey = GlobalKey<FormState>();
  final _tagController = TextEditingController();

  // Controllers para o perfil do volunt√°rio
  final _skillController = TextEditingController();
  final _resourceController = TextEditingController();

  // Estado da busca
  bool _hasSearched = false;

  // Dados do perfil do volunt√°rio
  final List<String> _selectedSkills = [];
  final List<String> _selectedResources = [];
  final List<String> _selectedDays = [];
  TimeOfDay _startTime = const TimeOfDay(hour: 9, minute: 0);
  TimeOfDay _endTime = const TimeOfDay(hour: 18, minute: 0);
  bool _isFullTimeAvailable = false; // Disponibilidade integral

  // Dias da semana
  final List<Map<String, String>> _weekDays = [
    {'key': 'monday', 'label': 'Segunda-feira'},
    {'key': 'tuesday', 'label': 'Ter√ßa-feira'},
    {'key': 'wednesday', 'label': 'Quarta-feira'},
    {'key': 'thursday', 'label': 'Quinta-feira'},
    {'key': 'friday', 'label': 'Sexta-feira'},
    {'key': 'saturday', 'label': 'S√°bado'},
    {'key': 'sunday', 'label': 'Domingo'},
  ];

  @override
  void dispose() {
    _tagController.dispose();
    _skillController.dispose();
    _resourceController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.background,
      appBar: AppBar(
        title: const Text('Participar de Evento'),
        backgroundColor: AppColors.primary,
        foregroundColor: AppColors.textOnPrimary,
      ),
      body: Consumer2<AuthController, EventController>(
        builder: (context, authController, eventController, child) {
          return SingleChildScrollView(
            padding: const EdgeInsets.all(AppDimensions.paddingLg),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Se√ß√£o de busca do evento
                _buildSearchSection(eventController),

                // Exibe detalhes do evento encontrado
                if (_hasSearched && eventController.searchedEvent != null) ...[
                  const SizedBox(height: AppDimensions.spacingLg),
                  _buildEventDetailsSection(
                    eventController.searchedEvent!,
                    authController.currentUser?.id,
                  ),

                  // S√≥ mostra formul√°rio e bot√£o se usu√°rio n√£o for participante
                  if (!_isUserParticipant(
                    eventController.searchedEvent!,
                    authController.currentUser?.id,
                  )) ...[
                    const SizedBox(height: AppDimensions.spacingLg),

                    // Formul√°rio do perfil do volunt√°rio
                    _buildVolunteerProfileForm(),

                    const SizedBox(height: AppDimensions.spacingXl),

                    // Bot√£o de participar
                    SizedBox(
                      width: double.infinity,
                      child: CustomButton(
                        text: 'Confirmar Participa√ß√£o',
                        onPressed: () =>
                            _handleJoinEvent(authController, eventController),
                        isLoading: eventController.isJoiningEvent,
                      ),
                    ),
                  ] else ...[
                    const SizedBox(height: AppDimensions.spacingLg),
                    _buildAlreadyParticipantMessage(
                      eventController.searchedEvent!,
                      authController.currentUser?.id,
                    ),
                  ],
                ],

                // Mensagem de erro
                if (eventController.hasError) ...[
                  const SizedBox(height: AppDimensions.spacingMd),
                  Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(AppDimensions.paddingMd),
                    decoration: BoxDecoration(
                      color: AppColors.error.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(
                        AppDimensions.radiusMd,
                      ),
                      border: Border.all(
                        color: AppColors.error.withValues(alpha: 0.3),
                      ),
                    ),
                    child: Row(
                      children: [
                        const Icon(
                          Icons.error_outline,
                          color: AppColors.error,
                          size: 20,
                        ),
                        const SizedBox(width: AppDimensions.spacingSm),
                        Expanded(
                          child: Text(
                            eventController.errorMessage ?? 'Erro desconhecido',
                            style: const TextStyle(
                              color: AppColors.error,
                              fontSize: AppDimensions.fontSizeMd,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ],
            ),
          );
        },
      ),
    );
  }

  Widget _buildSearchSection(EventController eventController) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Buscar Evento',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeLg,
            fontWeight: FontWeight.bold,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),
        const Text(
          'Digite o c√≥digo do evento que voc√™ deseja participar',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeMd,
            color: AppColors.textSecondary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingMd),

        Row(
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Expanded(
              child: CustomTextField(
                controller: _tagController,
                label: 'C√≥digo do Evento',
                hint: 'Ex: ABC123',
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'C√≥digo do evento √© obrigat√≥rio';
                  }
                  if (value.trim().length != 6) {
                    return 'C√≥digo deve ter exatamente 6 caracteres';
                  }
                  return null;
                },
              ),
            ),
            const SizedBox(width: AppDimensions.spacingSm),
            Padding(
              padding: const EdgeInsets.only(bottom: 2.0),
              child: CustomButton(
                text: 'Buscar',
                onPressed: () => _handleSearchEvent(eventController),
                isLoading: eventController.isLoading,
                isFullWidth: false,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildEventDetailsSection(EventModel event, String? currentUserId) {
    return Card(
      elevation: AppDimensions.elevationSm,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
      ),
      child: Padding(
        padding: const EdgeInsets.all(AppDimensions.paddingLg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            Row(
              children: [
                const Icon(Icons.event, color: AppColors.primary, size: 28),
                const SizedBox(width: AppDimensions.spacingSm),
                const Text(
                  'Evento Encontrado',
                  style: TextStyle(
                    fontSize: AppDimensions.fontSizeLg,
                    fontWeight: FontWeight.bold,
                    color: AppColors.textPrimary,
                  ),
                ),
              ],
            ),

            const SizedBox(height: AppDimensions.spacingMd),

            // Nome do evento
            Text(
              event.name,
              style: const TextStyle(
                fontSize: AppDimensions.fontSizeXl,
                fontWeight: FontWeight.bold,
                color: AppColors.primary,
              ),
            ),

            const SizedBox(height: AppDimensions.spacingSm),

            // Descri√ß√£o
            if (event.description.isNotEmpty) ...[
              Text(
                event.description,
                style: const TextStyle(
                  fontSize: AppDimensions.fontSizeMd,
                  color: AppColors.textSecondary,
                ),
              ),
              const SizedBox(height: AppDimensions.spacingSm),
            ],

            // Localiza√ß√£o
            Row(
              children: [
                const Icon(
                  Icons.location_on,
                  size: 16,
                  color: AppColors.textSecondary,
                ),
                const SizedBox(width: AppDimensions.spacingXs),
                Expanded(
                  child: Text(
                    event.location,
                    style: const TextStyle(
                      fontSize: AppDimensions.fontSizeMd,
                      color: AppColors.textSecondary,
                    ),
                  ),
                ),
              ],
            ),

            const SizedBox(height: AppDimensions.spacingMd),

            // Habilidades necess√°rias
            if (event.requiredSkills.isNotEmpty) ...[
              const Text(
                'Habilidades necess√°rias:',
                style: TextStyle(
                  fontSize: AppDimensions.fontSizeMd,
                  fontWeight: FontWeight.w600,
                  color: AppColors.textPrimary,
                ),
              ),
              const SizedBox(height: AppDimensions.spacingSm),
              Wrap(
                spacing: AppDimensions.spacingSm,
                runSpacing: AppDimensions.spacingSm,
                children: event.requiredSkills.map((skill) {
                  return SkillChip(label: skill, isSelected: false);
                }).toList(),
              ),
              const SizedBox(height: AppDimensions.spacingMd),
            ],

            // Recursos necess√°rios
            if (event.requiredResources.isNotEmpty) ...[
              const Text(
                'Recursos necess√°rios:',
                style: TextStyle(
                  fontSize: AppDimensions.fontSizeMd,
                  fontWeight: FontWeight.w600,
                  color: AppColors.textPrimary,
                ),
              ),
              const SizedBox(height: AppDimensions.spacingSm),
              Wrap(
                spacing: AppDimensions.spacingSm,
                runSpacing: AppDimensions.spacingSm,
                children: event.requiredResources.map((resource) {
                  return SkillChip(label: resource, isSelected: false);
                }).toList(),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildVolunteerProfileForm() {
    return Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Seu Perfil de Volunt√°rio',
            style: TextStyle(
              fontSize: AppDimensions.fontSizeLg,
              fontWeight: FontWeight.bold,
              color: AppColors.textPrimary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingSm),
          const Text(
            'Preencha suas informa√ß√µes para participar do evento',
            style: TextStyle(
              fontSize: AppDimensions.fontSizeMd,
              color: AppColors.textSecondary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingLg),

          // Disponibilidade - Dias
          _buildAvailabilitySection(),

          const SizedBox(height: AppDimensions.spacingLg),

          // Habilidades
          _buildSkillsSection(),

          const SizedBox(height: AppDimensions.spacingLg),

          // Recursos
          _buildResourcesSection(),
        ],
      ),
    );
  }

  Widget _buildAvailabilitySection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Disponibilidade',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeMd,
            fontWeight: FontWeight.w600,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),

        // Op√ß√£o de disponibilidade integral
        CheckboxListTile(
          title: const Text(
            'Disponibilidade integral (qualquer hor√°rio)',
            style: TextStyle(
              fontSize: AppDimensions.fontSizeMd,
              color: AppColors.textPrimary,
            ),
          ),
          subtitle: const Text(
            'Marque esta op√ß√£o se voc√™ est√° dispon√≠vel a qualquer momento',
            style: TextStyle(
              fontSize: AppDimensions.fontSizeSm,
              color: AppColors.textSecondary,
            ),
          ),
          value: _isFullTimeAvailable,
          onChanged: (bool? value) {
            setState(() {
              _isFullTimeAvailable = value ?? false;
              if (_isFullTimeAvailable) {
                // Limpa sele√ß√µes espec√≠ficas quando disponibilidade integral √© marcada
                _selectedDays.clear();
              }
            });
          },
          activeColor: AppColors.primary,
          contentPadding: EdgeInsets.zero,
        ),

        const SizedBox(height: AppDimensions.spacingMd),

        // Se√ß√£o de disponibilidade espec√≠fica (s√≥ aparece se n√£o for integral)
        if (!_isFullTimeAvailable) ...[
          // Dias da semana
          const Text(
            'Dias dispon√≠veis:',
            style: TextStyle(
              fontSize: AppDimensions.fontSizeMd,
              color: AppColors.textSecondary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingSm),

          Wrap(
            spacing: AppDimensions.spacingSm,
            runSpacing: AppDimensions.spacingSm,
            children: _weekDays.map((day) {
              final isSelected = _selectedDays.contains(day['key']);
              return SkillChip(
                label: day['label']!,
                isSelected: isSelected,
                onTap: () => _toggleDay(day['key']!),
              );
            }).toList(),
          ),

          const SizedBox(height: AppDimensions.spacingMd),

          // Hor√°rios
          const Text(
            'Hor√°rio dispon√≠vel:',
            style: TextStyle(
              fontSize: AppDimensions.fontSizeMd,
              color: AppColors.textSecondary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingSm),

          Row(
            children: [
              Expanded(
                child: GestureDetector(
                  onTap: () => _selectTime(context, true),
                  child: Container(
                    padding: const EdgeInsets.all(AppDimensions.paddingMd),
                    decoration: BoxDecoration(
                      border: Border.all(color: AppColors.border),
                      borderRadius: BorderRadius.circular(
                        AppDimensions.radiusMd,
                      ),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text(
                          'In√≠cio',
                          style: TextStyle(
                            fontSize: AppDimensions.fontSizeSm,
                            color: AppColors.textSecondary,
                          ),
                        ),
                        const SizedBox(height: AppDimensions.spacingXs),
                        Text(
                          _startTime.format(context),
                          style: const TextStyle(
                            fontSize: AppDimensions.fontSizeLg,
                            fontWeight: FontWeight.w600,
                            color: AppColors.textPrimary,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
              const SizedBox(width: AppDimensions.spacingMd),
              Expanded(
                child: GestureDetector(
                  onTap: () => _selectTime(context, false),
                  child: Container(
                    padding: const EdgeInsets.all(AppDimensions.paddingMd),
                    decoration: BoxDecoration(
                      border: Border.all(color: AppColors.border),
                      borderRadius: BorderRadius.circular(
                        AppDimensions.radiusMd,
                      ),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text(
                          'Fim',
                          style: TextStyle(
                            fontSize: AppDimensions.fontSizeSm,
                            color: AppColors.textSecondary,
                          ),
                        ),
                        const SizedBox(height: AppDimensions.spacingXs),
                        Text(
                          _endTime.format(context),
                          style: const TextStyle(
                            fontSize: AppDimensions.fontSizeLg,
                            fontWeight: FontWeight.w600,
                            color: AppColors.textPrimary,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ],
          ),
        ], // Fecha a se√ß√£o condicional
      ],
    );
  }

  Widget _buildSkillsSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Suas Habilidades',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeMd,
            fontWeight: FontWeight.w600,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),
        const Text(
          'Selecione suas habilidades',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeMd,
            color: AppColors.textSecondary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingMd),

        // Campo para adicionar nova habilidade
        Row(
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Expanded(
              child: CustomTextField(
                controller: _skillController,
                label: 'Nova Habilidade',
                hint: 'Digite uma habilidade',
              ),
            ),
            const SizedBox(width: AppDimensions.spacingSm),
            Padding(
              padding: const EdgeInsets.only(bottom: 2.0),
              child: CustomButton(
                text: 'Adicionar',
                onPressed: _addSkill,
                isFullWidth: false,
              ),
            ),
          ],
        ),

        const SizedBox(height: AppDimensions.spacingMd),

        // Habilidades necess√°rias do evento
        Consumer<EventController>(
          builder: (context, eventController, child) {
            final event = eventController.searchedEvent;
            if (event != null && event.requiredSkills.isNotEmpty) {
              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Habilidades necess√°rias para este evento:',
                    style: TextStyle(
                      fontSize: AppDimensions.fontSizeMd,
                      color: AppColors.textSecondary,
                    ),
                  ),
                  const SizedBox(height: AppDimensions.spacingSm),

                  Wrap(
                    spacing: AppDimensions.spacingSm,
                    runSpacing: AppDimensions.spacingSm,
                    children: event.requiredSkills.map((skill) {
                      final isSelected = _selectedSkills.contains(skill);
                      return SkillChip(
                        label: skill,
                        isSelected: isSelected,
                        onTap: () => _toggleSkill(skill),
                        backgroundColor: isSelected
                            ? AppColors.primary.withValues(alpha: 0.1)
                            : AppColors.warning.withValues(alpha: 0.1),
                        textColor: isSelected
                            ? AppColors.primary
                            : AppColors.warning,
                        borderColor: isSelected
                            ? AppColors.primary.withValues(alpha: 0.3)
                            : AppColors.warning.withValues(alpha: 0.3),
                      );
                    }).toList(),
                  ),
                ],
              );
            }
            return const SizedBox.shrink();
          },
        ),

        // Habilidades selecionadas
        if (_selectedSkills.isNotEmpty) ...[
          const SizedBox(height: AppDimensions.spacingMd),
          const Text(
            'Habilidades selecionadas:',
            style: TextStyle(
              fontSize: AppDimensions.fontSizeMd,
              fontWeight: FontWeight.w600,
              color: AppColors.textPrimary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingSm),
          Wrap(
            spacing: AppDimensions.spacingSm,
            runSpacing: AppDimensions.spacingSm,
            children: _selectedSkills.map((skill) {
              return SkillChip(
                label: skill,
                isSelected: true,
                onTap: () => _removeSkill(skill),
                showRemove: true,
              );
            }).toList(),
          ),
        ],
      ],
    );
  }

  Widget _buildResourcesSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Seus Recursos',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeMd,
            fontWeight: FontWeight.w600,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),
        const Text(
          'Selecione os recursos que voc√™ possui',
          style: TextStyle(
            fontSize: AppDimensions.fontSizeMd,
            color: AppColors.textSecondary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingMd),

        // Campo para adicionar novo recurso
        Row(
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Expanded(
              child: CustomTextField(
                controller: _resourceController,
                label: 'Novo Recurso',
                hint: 'Digite um recurso',
              ),
            ),
            const SizedBox(width: AppDimensions.spacingSm),
            Padding(
              padding: const EdgeInsets.only(bottom: 2.0),
              child: CustomButton(
                text: 'Adicionar',
                onPressed: _addResource,
                isFullWidth: false,
              ),
            ),
          ],
        ),

        const SizedBox(height: AppDimensions.spacingMd),

        // Recursos necess√°rios do evento
        Consumer<EventController>(
          builder: (context, eventController, child) {
            final event = eventController.searchedEvent;
            if (event != null && event.requiredResources.isNotEmpty) {
              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Recursos necess√°rios para este evento:',
                    style: TextStyle(
                      fontSize: AppDimensions.fontSizeMd,
                      color: AppColors.textSecondary,
                    ),
                  ),
                  const SizedBox(height: AppDimensions.spacingSm),

                  Wrap(
                    spacing: AppDimensions.spacingSm,
                    runSpacing: AppDimensions.spacingSm,
                    children: event.requiredResources.map((resource) {
                      final isSelected = _selectedResources.contains(resource);
                      return SkillChip(
                        label: resource,
                        isSelected: isSelected,
                        onTap: () => _toggleResource(resource),
                        backgroundColor: isSelected
                            ? AppColors.secondary.withValues(alpha: 0.1)
                            : AppColors.info.withValues(alpha: 0.1),
                        textColor: isSelected
                            ? AppColors.secondary
                            : AppColors.info,
                        borderColor: isSelected
                            ? AppColors.secondary.withValues(alpha: 0.3)
                            : AppColors.info.withValues(alpha: 0.3),
                      );
                    }).toList(),
                  ),
                ],
              );
            }
            return const SizedBox.shrink();
          },
        ),

        // Recursos selecionados
        if (_selectedResources.isNotEmpty) ...[
          const SizedBox(height: AppDimensions.spacingMd),
          const Text(
            'Recursos selecionados:',
            style: TextStyle(
              fontSize: AppDimensions.fontSizeMd,
              fontWeight: FontWeight.w600,
              color: AppColors.textPrimary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingSm),
          Wrap(
            spacing: AppDimensions.spacingSm,
            runSpacing: AppDimensions.spacingSm,
            children: _selectedResources.map((resource) {
              return SkillChip(
                label: resource,
                isSelected: true,
                onTap: () => _removeResource(resource),
                showRemove: true,
              );
            }).toList(),
          ),
        ],
      ],
    );
  }

  // M√©todos para gerenciar dias da semana
  void _toggleDay(String day) {
    setState(() {
      if (_selectedDays.contains(day)) {
        _selectedDays.remove(day);
      } else {
        _selectedDays.add(day);
      }
    });
  }

  // M√©todos para gerenciar hor√°rios
  Future<void> _selectTime(BuildContext context, bool isStartTime) async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: isStartTime ? _startTime : _endTime,
    );

    if (picked != null) {
      setState(() {
        if (isStartTime) {
          _startTime = picked;
        } else {
          _endTime = picked;
        }
      });
    }
  }

  // M√©todos para gerenciar habilidades
  void _addSkill() {
    final skill = _skillController.text.trim();
    if (skill.isNotEmpty && !_selectedSkills.contains(skill)) {
      setState(() {
        _selectedSkills.add(skill);
        _skillController.clear();
      });
    }
  }

  void _toggleSkill(String skill) {
    setState(() {
      if (_selectedSkills.contains(skill)) {
        _selectedSkills.remove(skill);
      } else {
        _selectedSkills.add(skill);
      }
    });
  }

  void _removeSkill(String skill) {
    setState(() {
      _selectedSkills.remove(skill);
    });
  }

  // M√©todos para gerenciar recursos
  void _addResource() {
    final resource = _resourceController.text.trim();
    if (resource.isNotEmpty && !_selectedResources.contains(resource)) {
      setState(() {
        _selectedResources.add(resource);
        _resourceController.clear();
      });
    }
  }

  void _toggleResource(String resource) {
    setState(() {
      if (_selectedResources.contains(resource)) {
        _selectedResources.remove(resource);
      } else {
        _selectedResources.add(resource);
      }
    });
  }

  void _removeResource(String resource) {
    setState(() {
      _selectedResources.remove(resource);
    });
  }

  // M√©todo para buscar evento
  Future<void> _handleSearchEvent(EventController eventController) async {
    final tag = _tagController.text.trim();
    if (tag.isEmpty) {
      return;
    }

    eventController.clearError();

    final event = await eventController.searchEventByTag(tag);

    setState(() {
      _hasSearched = true;
    });

    if (event == null && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Evento n√£o encontrado'),
          backgroundColor: AppColors.error,
        ),
      );
    }
  }

  // M√©todo para participar do evento
  Future<void> _handleJoinEvent(
    AuthController authController,
    EventController eventController,
  ) async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    final user = authController.currentUser;
    final event = eventController.searchedEvent;

    if (user == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Usu√°rio n√£o encontrado'),
          backgroundColor: AppColors.error,
        ),
      );
      return;
    }

    if (event == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Evento n√£o encontrado'),
          backgroundColor: AppColors.error,
        ),
      );
      return;
    }

    // Valida√ß√µes espec√≠ficas
    if (!_isFullTimeAvailable && _selectedDays.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text(
            'Selecione pelo menos um dia de disponibilidade ou marque disponibilidade integral',
          ),
          backgroundColor: AppColors.error,
        ),
      );
      return;
    }

    // Converte hor√°rios para string (ou usa valores padr√£o para disponibilidade integral)
    final startTimeString = _isFullTimeAvailable
        ? '00:00'
        : '${_startTime.hour.toString().padLeft(2, '0')}:${_startTime.minute.toString().padLeft(2, '0')}';
    final endTimeString = _isFullTimeAvailable
        ? '23:59'
        : '${_endTime.hour.toString().padLeft(2, '0')}:${_endTime.minute.toString().padLeft(2, '0')}';

    final timeRange = TimeRange(start: startTimeString, end: endTimeString);

    // Para disponibilidade integral, usa todos os dias da semana
    final availableDays = _isFullTimeAvailable
        ? [
            'monday',
            'tuesday',
            'wednesday',
            'thursday',
            'friday',
            'saturday',
            'sunday',
          ]
        : _selectedDays;

    // Limpa erros anteriores
    eventController.clearError();

    final success = await eventController.joinEvent(
      eventId: event.id,
      userId: user.id,
      availableDays: availableDays,
      availableHours: timeRange,
      isFullTimeAvailable: _isFullTimeAvailable,
      skills: _selectedSkills,
      resources: _selectedResources,
    );

    if (success && mounted) {
      // Mostra dialog de sucesso
      _showSuccessDialog();
    }
  }

  void _showSuccessDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        ),
        title: const Row(
          children: [
            Icon(Icons.check_circle, color: AppColors.success, size: 28),
            SizedBox(width: AppDimensions.spacingSm),
            Text('Participa√ß√£o Confirmada!'),
          ],
        ),
        content: const Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Voc√™ agora faz parte deste evento!',
              style: TextStyle(fontSize: AppDimensions.fontSizeMd),
            ),
            SizedBox(height: AppDimensions.spacingMd),
            Text(
              'Voc√™ pode acompanhar o evento na tela inicial e receber atualiza√ß√µes dos organizadores.',
              style: TextStyle(
                fontSize: AppDimensions.fontSizeSm,
                color: AppColors.textSecondary,
              ),
            ),
          ],
        ),
        actions: [
          CustomButton(
            text: 'Continuar',
            onPressed: () {
              Navigator.of(context).pop(); // Fecha o dialog
              Navigator.of(context).pop(); // Volta para a tela anterior
            },
          ),
        ],
      ),
    );
  }

  // Verifica se o usu√°rio j√° √© participante do evento
  bool _isUserParticipant(EventModel event, String? userId) {
    if (userId == null) return false;
    return event.isParticipant(userId);
  }

  // Widget para mostrar que o usu√°rio j√° √© participante
  Widget _buildAlreadyParticipantMessage(EventModel event, String? userId) {
    if (userId == null) return const SizedBox.shrink();

    final userRole = event.getUserRole(userId);
    String roleText;
    Color roleColor;
    IconData roleIcon;

    switch (userRole) {
      case UserRole.creator:
        roleText = 'Voc√™ √© o criador deste evento';
        roleColor = AppColors.primary;
        roleIcon = Icons.star;
        break;
      case UserRole.manager:
        roleText = 'Voc√™ √© gerenciador deste evento';
        roleColor = AppColors.secondary;
        roleIcon = Icons.admin_panel_settings;
        break;
      case UserRole.volunteer:
        roleText = 'Voc√™ j√° √© volunt√°rio neste evento';
        roleColor = AppColors.success;
        roleIcon = Icons.volunteer_activism;
        break;
      case UserRole.none:
        return const SizedBox.shrink();
    }

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(AppDimensions.paddingLg),
      decoration: BoxDecoration(
        color: roleColor.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(AppDimensions.radiusMd),
        border: Border.all(color: roleColor.withValues(alpha: 0.3)),
      ),
      child: Column(
        children: [
          Icon(roleIcon, size: 48, color: roleColor),
          const SizedBox(height: AppDimensions.spacingMd),
          Text(
            roleText,
            style: TextStyle(
              fontSize: AppDimensions.fontSizeLg,
              fontWeight: FontWeight.bold,
              color: roleColor,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: AppDimensions.spacingSm),
          Text(
            'Voc√™ pode acompanhar este evento na tela inicial.',
            style: TextStyle(
              fontSize: AppDimensions.fontSizeMd,
              color: roleColor.withValues(alpha: 0.8),
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: AppDimensions.spacingLg),
          SizedBox(
            width: double.infinity,
            child: CustomButton.outline(
              text: 'Voltar √† Tela Inicial',
              onPressed: () {
                Navigator.of(context).pop(); // Volta para a tela anterior
              },
            ),
          ),
        ],
      ),
    );
  }
}

## android\app\src\main\res\drawable-v21\launch_background.xml <a id="launch_background_xml"></a>

<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

## lib\presentation\widgets\common\loading_widget.dart <a id="loading_widget_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';

/// Widget para exibir indicador de carregamento
class LoadingWidget extends StatelessWidget {
  final String? message;
  final Color? color;
  final double? size;

  const LoadingWidget({
    super.key,
    this.message,
    this.color,
    this.size,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          SizedBox(
            width: size ?? 40,
            height: size ?? 40,
            child: CircularProgressIndicator(
              valueColor: AlwaysStoppedAnimation<Color>(
                color ?? AppColors.primary,
              ),
              strokeWidth: 3,
            ),
          ),
          if (message != null) ...[
            const SizedBox(height: AppDimensions.spacingMd),
            Text(
              message!,
              style: const TextStyle(
                fontSize: AppDimensions.fontSizeMd,
                color: AppColors.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ],
      ),
    );
  }
}

## linux\runner\main.cc <a id="main_cc"></a>

### Dependencies

- `my_application.h`

#include "my_application.h"

int main(int argc, char** argv) {
  g_autoptr(MyApplication) app = my_application_new();
  return g_application_run(G_APPLICATION(app), argc, argv);
}

## web\manifest.json <a id="manifest_json"></a>

{
    "name": "contask",
    "short_name": "contask",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}

## lib\main.dart <a id="main_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `package:firebase_core/firebase_core.dart`
- `package:provider/provider.dart`
- `core/theme/app_theme.dart`
- `firebase_options.dart`
- `presentation/controllers/auth_controller.dart`
- `presentation/controllers/event_controller.dart`
- `presentation/controllers/task_controller.dart`
- `presentation/routes/app_routes.dart`

import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:provider/provider.dart';
import 'core/theme/app_theme.dart';
import 'firebase_options.dart';
import 'presentation/controllers/auth_controller.dart';
import 'presentation/controllers/event_controller.dart';
import 'presentation/controllers/task_controller.dart';
import 'presentation/routes/app_routes.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Inicializa o Firebase
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  runApp(const ConTaskApp());
}

class ConTaskApp extends StatelessWidget {
  const ConTaskApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(
          create: (context) => AuthController()..initialize(),
        ),
        ChangeNotifierProvider(create: (context) => EventController()),
        ChangeNotifierProvider(create: (context) => TaskController()),
      ],
      child: Consumer<AuthController>(
        builder: (context, authController, child) {
          return MaterialApp(
            title: 'ConTask',
            theme: AppTheme.lightTheme,
            debugShowCheckedModeBanner: false,

            // Configura√ß√£o de rotas
            initialRoute: _getInitialRoute(authController),
            routes: AppRoutes.routes,
            onGenerateRoute: AppRoutes.onGenerateRoute,

            // Builder para interceptar mudan√ßas de autentica√ß√£o
            builder: (context, child) {
              return _AuthWrapper(child: child!);
            },
          );
        },
      ),
    );
  }

  String _getInitialRoute(AuthController authController) {
    // Se est√° autenticado, vai para home, sen√£o vai para login
    if (authController.isAuthenticated) {
      return AppRoutes.home;
    }
    return AppRoutes.login;
  }
}

/// Widget que monitora mudan√ßas de autentica√ß√£o e redireciona conforme necess√°rio
class _AuthWrapper extends StatefulWidget {
  final Widget child;

  const _AuthWrapper({required this.child});

  @override
  State<_AuthWrapper> createState() => _AuthWrapperState();
}

class _AuthWrapperState extends State<_AuthWrapper> {
  @override
  Widget build(BuildContext context) {
    return Consumer<AuthController>(
      builder: (context, authController, _) {
        // Monitora mudan√ßas no estado de autentica√ß√£o apenas ap√≥s o build
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (!mounted) return;

          final navigator = Navigator.maybeOf(context);
          if (navigator == null) return;

          final currentRoute = ModalRoute.of(context)?.settings.name;

          if (authController.isAuthenticated &&
              currentRoute == AppRoutes.login) {
            // Se est√° autenticado mas na tela de login, vai para home
            navigator.pushReplacementNamed(AppRoutes.home);
          } else if (authController.isUnauthenticated &&
              currentRoute != AppRoutes.login &&
              currentRoute != AppRoutes.register) {
            // Se n√£o est√° autenticado mas n√£o est√° na tela de login/cadastro, vai para login
            navigator.pushNamedAndRemoveUntil(
              AppRoutes.login,
              (route) => false,
            );
          }
        });

        return widget.child;
      },
    );
  }
}

## lib\presentation\screens\event\manage_volunteers_screen.dart <a id="manage_volunteers_screen_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `package:provider/provider.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/event_model.dart`
- `../../../data/models/user_model.dart`
- `../../../data/models/volunteer_profile_model.dart`
- `../../../data/models/microtask_model.dart`
- `../../controllers/event_controller.dart`
- `../../controllers/task_controller.dart`
- `../../controllers/auth_controller.dart`
- `../../widgets/common/loading_widget.dart`
- `../../widgets/volunteer/volunteer_card.dart`
- `../../widgets/dialogs/confirmation_dialog.dart`
- `../assignment/assignment_screen.dart`

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/event_model.dart';
import '../../../data/models/user_model.dart';
import '../../../data/models/volunteer_profile_model.dart';
import '../../../data/models/microtask_model.dart';
import '../../controllers/event_controller.dart';
import '../../controllers/task_controller.dart';
import '../../controllers/auth_controller.dart';
import '../../widgets/common/loading_widget.dart';
import '../../widgets/volunteer/volunteer_card.dart';
import '../../widgets/dialogs/confirmation_dialog.dart';
import '../assignment/assignment_screen.dart';

/// Tela para gerenciamento de volunt√°rios
class ManageVolunteersScreen extends StatefulWidget {
  final String eventId;

  const ManageVolunteersScreen({super.key, required this.eventId});

  @override
  State<ManageVolunteersScreen> createState() => _ManageVolunteersScreenState();
}

class _ManageVolunteersScreenState extends State<ManageVolunteersScreen> {
  EventModel? _event;
  List<UserModel> _volunteers = [];
  List<VolunteerProfileModel> _volunteerProfiles = [];
  List<MicrotaskModel> _availableMicrotasks = [];
  bool _isLoading = true;
  String _searchQuery = '';
  String _filterStatus = 'all'; // all, available, assigned
  final List<String> _selectedSkillsFilter =
      []; // Filtro por habilidades selecionadas
  List<String> _availableSkills =
      []; // Todas as habilidades dispon√≠veis no evento

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  Future<void> _loadData() async {
    try {
      final eventController = Provider.of<EventController>(
        context,
        listen: false,
      );
      final taskController = Provider.of<TaskController>(
        context,
        listen: false,
      );

      // Carrega evento
      final event = await eventController.loadEvent(widget.eventId);

      // Carrega tasks e microtasks
      await taskController.loadTasksByEventId(widget.eventId);

      // Carrega volunt√°rios e perfis (OTIMIZADO - dados denormalizados)
      final profiles = await eventController.getEventVolunteersOptimized(
        widget.eventId,
      );

      // DEBUG: Carregados ${profiles.length} perfis de volunt√°rios

      // N√£o precisamos mais buscar usu√°rios separadamente - dados est√£o nos perfis
      final volunteers = <UserModel>[]; // Mantido para compatibilidade

      // Se n√£o h√° volunt√°rios, voc√™ pode adicionar dados de teste aqui
      // _addTestVolunteers(); // Descomente para testar

      // Carrega microtasks dispon√≠veis
      final availableMicrotasks = <MicrotaskModel>[];
      final allSkills = <String>{};

      for (final task in taskController.tasks) {
        final microtasks = taskController.getMicrotasksByTaskId(task.id);
        availableMicrotasks.addAll(
          microtasks.where(
            (m) =>
                m.status != MicrotaskStatus.completed &&
                m.status != MicrotaskStatus.cancelled,
          ),
        );

        // Coleta todas as habilidades necess√°rias das microtasks
        for (final microtask in microtasks) {
          allSkills.addAll(microtask.requiredSkills);
        }
      }

      // Adiciona habilidades do evento se dispon√≠veis
      if (event != null && event.requiredSkills.isNotEmpty) {
        allSkills.addAll(event.requiredSkills);
      }

      if (mounted) {
        setState(() {
          _event = event;
          _volunteers = volunteers;
          _volunteerProfiles = profiles;
          _availableMicrotasks = availableMicrotasks;
          _availableSkills = allSkills.toList()..sort();
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Erro ao carregar dados: $e'),
            backgroundColor: AppColors.error,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const LoadingWidget(message: 'Carregando volunt√°rios...');
    }

    if (_event == null) {
      return const Center(
        child: Text(
          'Erro ao carregar evento',
          style: TextStyle(fontSize: 16, color: AppColors.error),
        ),
      );
    }

    final filteredVolunteers = _getFilteredVolunteers();

    return Column(
      children: [
        // Header com busca e filtros
        _buildHeader(),

        // Lista de volunt√°rios
        Expanded(
          child: filteredVolunteers.isEmpty
              ? _buildEmptyState()
              : _buildVolunteersList(filteredVolunteers),
        ),
      ],
    );
  }

  Widget _buildHeader() {
    return Container(
      padding: const EdgeInsets.all(AppDimensions.paddingMd),
      decoration: const BoxDecoration(
        color: AppColors.background,
        border: Border(bottom: BorderSide(color: AppColors.border)),
      ),
      child: Column(
        children: [
          // Barra de busca
          TextField(
            onChanged: (value) {
              setState(() {
                _searchQuery = value;
              });
            },
            decoration: InputDecoration(
              hintText: 'Buscar volunt√°rios...',
              prefixIcon: const Icon(Icons.search),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              contentPadding: const EdgeInsets.symmetric(
                horizontal: AppDimensions.paddingMd,
                vertical: AppDimensions.paddingSm,
              ),
            ),
          ),

          const SizedBox(height: AppDimensions.spacingMd),

          // Filtros
          Row(
            children: [
              const Text(
                'Filtrar:',
                style: TextStyle(
                  fontWeight: FontWeight.w500,
                  color: AppColors.textSecondary,
                ),
              ),
              const SizedBox(width: AppDimensions.spacingSm),

              Expanded(
                child: SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    children: [
                      _buildFilterChip('Todos', 'all'),
                      const SizedBox(width: AppDimensions.spacingSm),
                      _buildFilterChip('Dispon√≠veis', 'available'),
                      const SizedBox(width: AppDimensions.spacingSm),
                      _buildFilterChip('Com Tarefas', 'assigned'),
                      const SizedBox(width: AppDimensions.spacingSm),
                      _buildSkillsFilterButton(),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildFilterChip(String label, String value) {
    final isSelected = _filterStatus == value;
    return FilterChip(
      label: Text(label),
      selected: isSelected,
      onSelected: (selected) {
        setState(() {
          _filterStatus = value;
        });
      },
      selectedColor: AppColors.primary.withOpacity(0.2),
      checkmarkColor: AppColors.primary,
    );
  }

  // Bot√£o de filtro por habilidades
  Widget _buildSkillsFilterButton() {
    final hasActiveFilter = _selectedSkillsFilter.isNotEmpty;

    return GestureDetector(
      onTap: _availableSkills.isNotEmpty ? _showSkillsFilterDialog : null,
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: AppDimensions.paddingSm,
          vertical: AppDimensions.paddingSm / 2,
        ),
        decoration: BoxDecoration(
          color: hasActiveFilter
              ? AppColors.primary.withOpacity(0.2)
              : AppColors.background,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(
            color: hasActiveFilter ? AppColors.primary : AppColors.border,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.filter_list,
              size: 16,
              color: hasActiveFilter
                  ? AppColors.primary
                  : AppColors.textSecondary,
            ),
            const SizedBox(width: 4),
            Text(
              hasActiveFilter
                  ? 'Habilidades (${_selectedSkillsFilter.length})'
                  : 'Filtrar por Habilidade',
              style: TextStyle(
                fontSize: 12,
                color: hasActiveFilter
                    ? AppColors.primary
                    : AppColors.textSecondary,
                fontWeight: hasActiveFilter
                    ? FontWeight.w600
                    : FontWeight.normal,
              ),
            ),
            if (hasActiveFilter) ...[
              const SizedBox(width: 4),
              GestureDetector(
                onTap: () {
                  setState(() {
                    _selectedSkillsFilter.clear();
                  });
                },
                child: Icon(Icons.close, size: 14, color: AppColors.primary),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.people_outline,
            size: 64,
            color: AppColors.textSecondary.withOpacity(0.5),
          ),
          const SizedBox(height: AppDimensions.spacingLg),
          const Text(
            'Nenhum volunt√°rio encontrado',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.w600,
              color: AppColors.textSecondary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingSm),
          const Text(
            'Compartilhe o c√≥digo do evento para que\nvolunt√°rios possam se inscrever.',
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 14, color: AppColors.textSecondary),
          ),
          const SizedBox(height: AppDimensions.spacingLg),

          // C√≥digo do evento
          Container(
            padding: const EdgeInsets.all(AppDimensions.paddingMd),
            decoration: BoxDecoration(
              color: AppColors.primary.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: AppColors.primary.withOpacity(0.3)),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Icon(Icons.qr_code, color: AppColors.primary),
                const SizedBox(width: AppDimensions.spacingSm),
                Text(
                  'C√≥digo: ${_event?.tag ?? 'N/A'}',
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    color: AppColors.primary,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildVolunteersList(List<UserModel> volunteers) {
    // Agora usamos os perfis diretamente (com dados denormalizados)
    final profiles = _volunteerProfiles.where((profile) {
      return _shouldShowVolunteer(profile);
    }).toList();

    return ListView.builder(
      padding: const EdgeInsets.all(AppDimensions.paddingSm),
      itemCount: profiles.length,
      itemBuilder: (context, index) {
        final profile = profiles[index];

        // Cria um UserModel tempor√°rio para compatibilidade com VolunteerCard
        final user = UserModel(
          id: profile.userId,
          name: profile.userName,
          email: profile.userEmail,
          photoUrl: profile.userPhotoUrl,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        return VolunteerCard(
          user: user,
          profile: profile,
          isManager: true,
          showActions: true,
          assignedMicrotasksCount: _getAssignedMicrotasksCount(profile.userId),
          isCompatible: _isVolunteerCompatible(profile),
          showDetailedAvailability: true,
          onShowActions: () => _showVolunteerActionsDialog(user, profile),
        );
      },
    );
  }

  /// Verifica se um volunt√°rio deve ser mostrado baseado nos filtros
  bool _shouldShowVolunteer(VolunteerProfileModel profile) {
    // Filtro por status
    if (_filterStatus == 'available') {
      final assignedCount = _getAssignedMicrotasksCount(profile.userId);
      if (assignedCount > 0) return false;
    } else if (_filterStatus == 'assigned') {
      final assignedCount = _getAssignedMicrotasksCount(profile.userId);
      if (assignedCount == 0) return false;
    }

    // Filtro por habilidades
    if (!_hasRequiredSkills(profile)) return false;

    return true;
  }

  /// Verifica se o perfil tem as habilidades necess√°rias (filtro)
  bool _hasRequiredSkills(VolunteerProfileModel profile) {
    if (_selectedSkillsFilter.isEmpty) return true;
    return _selectedSkillsFilter.every(
      (skill) => profile.skills.contains(skill),
    );
  }

  /// Exibe um di√°logo com as a√ß√µes dispon√≠veis para um volunt√°rio.
  void _showVolunteerActionsDialog(
    UserModel volunteer,
    VolunteerProfileModel? profile,
  ) {
    final assignedCount = _getAssignedMicrotasksCount(volunteer.id);
    final availableMicrotasksCount = _availableMicrotasks
        .where(
          (m) =>
              m.assignedTo.length < m.maxVolunteers &&
              !m.assignedTo.contains(volunteer.id),
        )
        .length;

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        title: Row(
          children: [
            CircleAvatar(
              radius: 20,
              backgroundColor: AppColors.primary.withOpacity(0.1),
              backgroundImage: volunteer.photoUrl != null
                  ? NetworkImage(volunteer.photoUrl!)
                  : null,
              child: volunteer.photoUrl == null
                  ? Text(
                      volunteer.name.isNotEmpty
                          ? volunteer.name[0].toUpperCase()
                          : '?',
                      style: const TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.bold,
                        color: AppColors.primary,
                      ),
                    )
                  : null,
            ),
            const SizedBox(width: AppDimensions.spacingMd),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    volunteer.name,
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  if (profile != null) ...[
                    const SizedBox(height: 2),
                    Text(
                      profile.workloadLevel,
                      style: TextStyle(
                        fontSize: 12,
                        color: _getMicrotaskBadgeColor(assignedCount),
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ],
              ),
            ),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Informa√ß√µes do volunt√°rio
            if (profile != null) ...[
              Container(
                padding: const EdgeInsets.all(AppDimensions.paddingSm),
                decoration: BoxDecoration(
                  color: AppColors.background,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: AppColors.border),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(
                          Icons.assignment,
                          size: 16,
                          color: AppColors.primary,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          'Microtasks: $assignedCount atribu√≠das',
                          style: const TextStyle(fontSize: 12),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        Icon(
                          Icons.schedule,
                          size: 16,
                          color: AppColors.secondary,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          profile.isFullTimeAvailable
                              ? 'Disponibilidade integral'
                              : 'Dispon√≠vel: ${profile.availableDays.join(', ')}',
                          style: const TextStyle(fontSize: 12),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ],
                    ),
                    if (profile.skills.isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Icon(
                            Icons.construction,
                            size: 16,
                            color: AppColors.success,
                          ),
                          const SizedBox(width: 4),
                          Expanded(
                            child: Text(
                              'Habilidades: ${profile.skills.join(', ')}',
                              style: const TextStyle(fontSize: 12),
                              maxLines: 2,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ],
                ),
              ),
              const SizedBox(height: AppDimensions.spacingMd),
            ],

            // A√ß√µes dispon√≠veis
            ListTile(
              leading: Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: AppColors.primary.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: const Icon(
                  Icons.assignment_ind_outlined,
                  color: AppColors.primary,
                  size: 20,
                ),
              ),
              title: const Text('Atribuir Microtask'),
              subtitle: Text(
                availableMicrotasksCount > 0
                    ? '$availableMicrotasksCount microtasks dispon√≠veis'
                    : 'Nenhuma microtask dispon√≠vel',
              ),
              enabled: availableMicrotasksCount > 0,
              onTap: availableMicrotasksCount > 0
                  ? () {
                      Navigator.of(context).pop();
                      _showAssignmentDialog(volunteer, profile);
                    }
                  : null,
            ),

            const Divider(),

            ListTile(
              leading: Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: AppColors.warning.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: const Icon(
                  Icons.admin_panel_settings_outlined,
                  color: AppColors.warning,
                  size: 20,
                ),
              ),
              title: const Text('Promover a Gerente'),
              subtitle: const Text('Conceder permiss√µes de gerenciamento'),
              onTap: () {
                Navigator.of(context).pop();
                _promoteToManager(volunteer);
              },
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancelar'),
          ),
        ],
      ),
    );
  }

  List<UserModel> _getFilteredVolunteers() {
    // Agora criamos UserModels a partir dos perfis (dados denormalizados)
    List<UserModel> filtered = _volunteerProfiles.map((profile) {
      return UserModel(
        id: profile.userId,
        name: profile.userName,
        email: profile.userEmail,
        photoUrl: profile.userPhotoUrl,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
    }).toList();

    // Aplicar filtro de busca
    if (_searchQuery.isNotEmpty) {
      filtered = filtered.where((volunteer) {
        final name = volunteer.name.toLowerCase();
        final email = volunteer.email.toLowerCase();
        final query = _searchQuery.toLowerCase();
        return name.contains(query) || email.contains(query);
      }).toList();
    }

    // Aplicar filtro de status
    switch (_filterStatus) {
      case 'available':
        // Filtrar volunt√°rios dispon√≠veis hoje
        filtered = filtered.where((volunteer) {
          final profile = _getVolunteerProfile(volunteer.id);
          if (profile == null) return false;

          final currentDay = _getCurrentDayString();
          return profile.availableDays.contains(currentDay);
        }).toList();
        break;
      case 'assigned':
        // Filtrar volunt√°rios com microtasks atribu√≠das
        filtered = filtered.where((volunteer) {
          return _getAssignedMicrotasksCount(volunteer.id) > 0;
        }).toList();
        break;
      case 'all':
      default:
        // N√£o aplicar filtro adicional
        break;
    }

    // Aplicar filtro por habilidades
    if (_selectedSkillsFilter.isNotEmpty) {
      filtered = filtered.where((volunteer) {
        final profile = _getVolunteerProfile(volunteer.id);
        if (profile == null) return false;

        // O volunt√°rio deve possuir TODAS as habilidades selecionadas no filtro
        return _selectedSkillsFilter.every(
          (skill) => profile.skills.contains(skill),
        );
      }).toList();
    }

    return filtered;
  }

  String _getCurrentDayString() {
    final now = DateTime.now();
    final weekdays = ['seg', 'ter', 'qua', 'qui', 'sex', 'sab', 'dom'];
    return weekdays[now.weekday - 1];
  }

  VolunteerProfileModel? _getVolunteerProfile(String userId) {
    try {
      return _volunteerProfiles.firstWhere((p) => p.userId == userId);
    } catch (e) {
      return null;
    }
  }

  // Verifica se o volunt√°rio √© compat√≠vel com os filtros de habilidades ativos
  bool _isVolunteerCompatible(VolunteerProfileModel? profile) {
    if (profile == null || _selectedSkillsFilter.isEmpty) return false;

    // Retorna true se o volunt√°rio possui todas as habilidades do filtro
    return _selectedSkillsFilter.every(
      (skill) => profile.skills.contains(skill),
    );
  }

  // Cor do badge baseada na carga de trabalho
  Color _getMicrotaskBadgeColor(int count) {
    if (count == 0) return AppColors.textSecondary;
    if (count < 3) return AppColors.success;
    if (count < 5) return AppColors.warning;
    return AppColors.error;
  }

  int _getAssignedMicrotasksCount(String userId) {
    // Primeiro, tenta usar o contador do perfil se dispon√≠vel
    final profile = _getVolunteerProfile(userId);
    if (profile != null) {
      return profile.assignedMicrotasksCount;
    }

    // Fallback: conta manualmente nas microtasks
    int count = 0;
    for (final microtask in _availableMicrotasks) {
      if (microtask.assignedTo.contains(userId)) {
        count++;
      }
    }

    return count;
  }

  // Modal de sele√ß√£o de habilidades para filtro
  void _showSkillsFilterDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Filtrar por Habilidades'),
        content: SizedBox(
          width: double.maxFinite,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text(
                'Selecione as habilidades para filtrar volunt√°rios:',
                style: TextStyle(fontSize: 14, color: AppColors.textSecondary),
              ),
              const SizedBox(height: AppDimensions.spacingMd),
              Flexible(
                child: ListView.builder(
                  shrinkWrap: true,
                  itemCount: _availableSkills.length,
                  itemBuilder: (context, index) {
                    final skill = _availableSkills[index];
                    final isSelected = _selectedSkillsFilter.contains(skill);

                    return CheckboxListTile(
                      title: Text(skill),
                      value: isSelected,
                      onChanged: (bool? value) {
                        setState(() {
                          if (value == true) {
                            _selectedSkillsFilter.add(skill);
                          } else {
                            _selectedSkillsFilter.remove(skill);
                          }
                        });
                      },
                      activeColor: AppColors.primary,
                      dense: true,
                    );
                  },
                ),
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () {
              setState(() {
                _selectedSkillsFilter.clear();
              });
              Navigator.of(context).pop();
            },
            child: const Text('Limpar'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancelar'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Aplicar'),
          ),
        ],
      ),
    );
  }

  void _showAssignmentDialog(
    UserModel volunteer,
    VolunteerProfileModel? profile,
  ) {
    Navigator.of(context)
        .push(
          MaterialPageRoute(
            builder: (context) => AssignmentScreen(
              eventId: widget.eventId,
              volunteer: volunteer,
              volunteerProfile: profile,
            ),
          ),
        )
        .then((result) {
          // Se a atribui√ß√£o foi bem-sucedida, recarrega os dados
          if (result == true) {
            _loadData();
          }
        });
  }

  Future<void> _promoteToManager(UserModel volunteer) async {
    final confirmed = await ConfirmationDialog.showPromoteVolunteer(
      context: context,
      volunteerName: volunteer.name,
    );

    if (confirmed == true && mounted) {
      try {
        final eventController = Provider.of<EventController>(
          context,
          listen: false,
        );
        final currentUser = Provider.of<AuthController>(
          context,
          listen: false,
        ).currentUser;

        if (currentUser == null) {
          throw Exception('Usu√°rio n√£o autenticado');
        }

        final success = await eventController.promoteVolunteerToManager(
          eventId: widget.eventId,
          volunteerId: volunteer.id,
          managerId: currentUser.id,
        );

        if (success && mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                '${volunteer.name} foi promovido(a) a gerente com sucesso!',
              ),
              backgroundColor: AppColors.success,
            ),
          );

          // Recarrega os dados para refletir as mudan√ßas
          _loadData();
        } else if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                eventController.errorMessage ?? 'Erro ao promover volunt√°rio',
              ),
              backgroundColor: AppColors.error,
            ),
          );
        }
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Erro ao promover volunt√°rio: $e'),
              backgroundColor: AppColors.error,
            ),
          );
        }
      }
    }
  }
}

## lib\presentation\widgets\task\microtask_card.dart <a id="microtask_card_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/microtask_model.dart`
- `../../../data/models/user_model.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/microtask_model.dart';
import '../../../data/models/user_model.dart';

/// Widget card para exibir informa√ß√µes de uma microtask com m√∫ltiplos volunt√°rios
class MicrotaskCard extends StatelessWidget {
  final MicrotaskModel microtask;
  final List<UserModel> assignedVolunteers;
  final VoidCallback? onTap;
  final VoidCallback? onAssignVolunteer;
  final Function(String userId)? onRemoveVolunteer;
  final Function(String userId, String status)? onUpdateStatus;
  final bool showActions;
  final bool isManager;

  const MicrotaskCard({
    super.key,
    required this.microtask,
    this.assignedVolunteers = const [],
    this.onTap,
    this.onAssignVolunteer,
    this.onRemoveVolunteer,
    this.onUpdateStatus,
    this.showActions = true,
    this.isManager = false,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 1,
      margin: const EdgeInsets.symmetric(
        horizontal: AppDimensions.paddingMd,
        vertical: AppDimensions.paddingSm,
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(8),
        child: Padding(
          padding: const EdgeInsets.all(AppDimensions.paddingMd),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  // √çcone de status
                  Container(
                    width: 10,
                    height: 10,
                    decoration: BoxDecoration(
                      color: _getStatusColor(),
                      shape: BoxShape.circle,
                    ),
                  ),
                  const SizedBox(width: AppDimensions.spacingSm),

                  // T√≠tulo
                  Expanded(
                    child: Text(
                      microtask.title,
                      style: const TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                        color: AppColors.textPrimary,
                      ),
                    ),
                  ),

                  // Badge de prioridade
                  _buildPriorityBadge(),
                ],
              ),

              const SizedBox(height: AppDimensions.spacingSm),

              // Descri√ß√£o
              if (microtask.description.isNotEmpty)
                Text(
                  microtask.description,
                  style: const TextStyle(
                    fontSize: 12,
                    color: AppColors.textSecondary,
                    height: 1.3,
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),

              const SizedBox(height: AppDimensions.spacingMd),

              // Informa√ß√µes da microtask
              Wrap(
                spacing: AppDimensions.spacingSm,
                runSpacing: AppDimensions.spacingSm,
                children: [
                  _buildInfoChip(
                    icon: Icons.schedule,
                    label: microtask.hasSchedule
                        ? microtask.periodFormatted
                        : 'Hor√°rio n√£o definido',
                    color: AppColors.secondary,
                  ),
                  _buildInfoChip(
                    icon: Icons.people,
                    label:
                        '${assignedVolunteers.length}/${microtask.maxVolunteers}',
                    color: _getVolunteerCountColor(),
                  ),
                  _buildInfoChip(
                    icon: Icons.info_outline,
                    label: _getStatusText(),
                    color: _getStatusColor(),
                  ),
                ],
              ),

              // Habilidades necess√°rias
              if (microtask.requiredSkills.isNotEmpty) ...[
                const SizedBox(height: AppDimensions.spacingMd),
                _buildSkillsSection(),
              ],

              // Recursos necess√°rios
              if (microtask.requiredResources.isNotEmpty) ...[
                const SizedBox(height: AppDimensions.spacingSm),
                _buildResourcesSection(),
              ],

              // Lista de volunt√°rios atribu√≠dos
              if (assignedVolunteers.isNotEmpty) ...[
                const SizedBox(height: AppDimensions.spacingMd),
                _buildVolunteersSection(),
              ],

              // A√ß√µes (se habilitadas)
              if (showActions) ...[
                const SizedBox(height: AppDimensions.spacingMd),
                _buildActionsSection(),
              ],
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPriorityBadge() {
    Color color;
    String text;

    final priorityValue = microtask.priority is int
        ? microtask.priority as int
        : 2;

    switch (priorityValue) {
      case 3: // high
        color = AppColors.error;
        text = 'Alta';
        break;
      case 2: // medium
        color = AppColors.warning;
        text = 'M√©dia';
        break;
      case 1: // low
        color = AppColors.success;
        text = 'Baixa';
        break;
      default:
        color = AppColors.warning;
        text = 'M√©dia';
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontSize: 9,
          fontWeight: FontWeight.w600,
          color: color,
        ),
      ),
    );
  }

  Widget _buildInfoChip({
    required IconData icon,
    required String label,
    required Color color,
  }) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 12, color: color),
          const SizedBox(width: 4),
          Text(
            label,
            style: TextStyle(
              fontSize: 11,
              fontWeight: FontWeight.w500,
              color: color,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSkillsSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Habilidades:',
          style: TextStyle(
            fontSize: 11,
            fontWeight: FontWeight.w600,
            color: AppColors.textSecondary,
          ),
        ),
        const SizedBox(height: 4),
        Wrap(
          spacing: 4,
          runSpacing: 4,
          children: microtask.requiredSkills.map((skill) {
            return Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(
                color: AppColors.primary.withOpacity(0.1),
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: AppColors.primary.withOpacity(0.3)),
              ),
              child: Text(
                skill,
                style: const TextStyle(fontSize: 10, color: AppColors.primary),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  Widget _buildResourcesSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Recursos:',
          style: TextStyle(
            fontSize: 11,
            fontWeight: FontWeight.w600,
            color: AppColors.textSecondary,
          ),
        ),
        const SizedBox(height: 4),
        Wrap(
          spacing: 4,
          runSpacing: 4,
          children: microtask.requiredResources.map((resource) {
            return Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(
                color: AppColors.secondary.withOpacity(0.1),
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: AppColors.secondary.withOpacity(0.3)),
              ),
              child: Text(
                resource,
                style: const TextStyle(
                  fontSize: 10,
                  color: AppColors.secondary,
                ),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  Widget _buildVolunteersSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Volunt√°rios:',
          style: TextStyle(
            fontSize: 11,
            fontWeight: FontWeight.w600,
            color: AppColors.textSecondary,
          ),
        ),
        const SizedBox(height: 4),
        ...assignedVolunteers.map(
          (volunteer) => _buildVolunteerItem(volunteer),
        ),
      ],
    );
  }

  Widget _buildVolunteerItem(UserModel volunteer) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 4),
      child: Row(
        children: [
          CircleAvatar(
            radius: 12,
            backgroundColor: AppColors.primary.withOpacity(0.1),
            child: Text(
              volunteer.name.isNotEmpty ? volunteer.name[0].toUpperCase() : '?',
              style: const TextStyle(
                fontSize: 10,
                fontWeight: FontWeight.bold,
                color: AppColors.primary,
              ),
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              volunteer.name,
              style: const TextStyle(
                fontSize: 11,
                color: AppColors.textPrimary,
              ),
            ),
          ),
          if (isManager && onRemoveVolunteer != null)
            IconButton(
              onPressed: () => onRemoveVolunteer!(volunteer.id),
              icon: const Icon(Icons.remove_circle_outline),
              iconSize: 16,
              color: AppColors.error,
              constraints: const BoxConstraints(minWidth: 24, minHeight: 24),
              padding: EdgeInsets.zero,
            ),
        ],
      ),
    );
  }

  Widget _buildActionsSection() {
    return Row(
      children: [
        if (isManager &&
            onAssignVolunteer != null &&
            assignedVolunteers.length < microtask.maxVolunteers)
          Expanded(
            child: OutlinedButton.icon(
              onPressed: onAssignVolunteer,
              icon: const Icon(Icons.person_add, size: 16),
              label: const Text('Atribuir'),
              style: OutlinedButton.styleFrom(
                foregroundColor: AppColors.primary,
                side: const BorderSide(color: AppColors.primary),
                padding: const EdgeInsets.symmetric(vertical: 8),
              ),
            ),
          ),
      ],
    );
  }

  Color _getStatusColor() {
    switch (microtask.status) {
      case MicrotaskStatus.pending:
        return AppColors.warning;
      case MicrotaskStatus.assigned:
        return AppColors.primary;
      case MicrotaskStatus.inProgress:
        return AppColors.secondary;
      case MicrotaskStatus.completed:
        return AppColors.success;
      case MicrotaskStatus.cancelled:
        return AppColors.error;
    }
  }

  String _getStatusText() {
    switch (microtask.status) {
      case MicrotaskStatus.pending:
        return 'Pendente';
      case MicrotaskStatus.assigned:
        return 'Atribu√≠da';
      case MicrotaskStatus.inProgress:
        return 'Em Progresso';
      case MicrotaskStatus.completed:
        return 'Conclu√≠da';
      case MicrotaskStatus.cancelled:
        return 'Cancelada';
    }
  }

  Color _getVolunteerCountColor() {
    if (assignedVolunteers.length == microtask.maxVolunteers) {
      return AppColors.success;
    } else if (assignedVolunteers.isEmpty) {
      return AppColors.warning;
    } else {
      return AppColors.primary;
    }
  }
}

## linux\runner\my_application.cc <a id="my_application_cc"></a>

### Dependencies

- `my_application.h`
- `flutter_linux/flutter_linux.h`
- `gdk/gdkx.h`
- `flutter/generated_plugin_registrant.h`

#include "my_application.h"

#include <flutter_linux/flutter_linux.h>
#ifdef GDK_WINDOWING_X11
#include <gdk/gdkx.h>
#endif

#include "flutter/generated_plugin_registrant.h"

struct _MyApplication {
  GtkApplication parent_instance;
  char** dart_entrypoint_arguments;
};

G_DEFINE_TYPE(MyApplication, my_application, GTK_TYPE_APPLICATION)

// Implements GApplication::activate.
static void my_application_activate(GApplication* application) {
  MyApplication* self = MY_APPLICATION(application);
  GtkWindow* window =
      GTK_WINDOW(gtk_application_window_new(GTK_APPLICATION(application)));

  // Use a header bar when running in GNOME as this is the common style used
  // by applications and is the setup most users will be using (e.g. Ubuntu
  // desktop).
  // If running on X and not using GNOME then just use a traditional title bar
  // in case the window manager does more exotic layout, e.g. tiling.
  // If running on Wayland assume the header bar will work (may need changing
  // if future cases occur).
  gboolean use_header_bar = TRUE;
#ifdef GDK_WINDOWING_X11
  GdkScreen* screen = gtk_window_get_screen(window);
  if (GDK_IS_X11_SCREEN(screen)) {
    const gchar* wm_name = gdk_x11_screen_get_window_manager_name(screen);
    if (g_strcmp0(wm_name, "GNOME Shell") != 0) {
      use_header_bar = FALSE;
    }
  }
#endif
  if (use_header_bar) {
    GtkHeaderBar* header_bar = GTK_HEADER_BAR(gtk_header_bar_new());
    gtk_widget_show(GTK_WIDGET(header_bar));
    gtk_header_bar_set_title(header_bar, "contask");
    gtk_header_bar_set_show_close_button(header_bar, TRUE);
    gtk_window_set_titlebar(window, GTK_WIDGET(header_bar));
  } else {
    gtk_window_set_title(window, "contask");
  }

  gtk_window_set_default_size(window, 1280, 720);
  gtk_widget_show(GTK_WIDGET(window));

  g_autoptr(FlDartProject) project = fl_dart_project_new();
  fl_dart_project_set_dart_entrypoint_arguments(project, self->dart_entrypoint_arguments);

  FlView* view = fl_view_new(project);
  gtk_widget_show(GTK_WIDGET(view));
  gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(view));

  fl_register_plugins(FL_PLUGIN_REGISTRY(view));

  gtk_widget_grab_focus(GTK_WIDGET(view));
}

// Implements GApplication::local_command_line.
static gboolean my_application_local_command_line(GApplication* application, gchar*** arguments, int* exit_status) {
  MyApplication* self = MY_APPLICATION(application);
  // Strip out the first argument as it is the binary name.
  self->dart_entrypoint_arguments = g_strdupv(*arguments + 1);

  g_autoptr(GError) error = nullptr;
  if (!g_application_register(application, nullptr, &error)) {
     g_warning("Failed to register: %s", error->message);
     *exit_status = 1;
     return TRUE;
  }

  g_application_activate(application);
  *exit_status = 0;

  return TRUE;
}

// Implements GApplication::startup.
static void my_application_startup(GApplication* application) {
  //MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application startup.

  G_APPLICATION_CLASS(my_application_parent_class)->startup(application);
}

// Implements GApplication::shutdown.
static void my_application_shutdown(GApplication* application) {
  //MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application shutdown.

  G_APPLICATION_CLASS(my_application_parent_class)->shutdown(application);
}

// Implements GObject::dispose.
static void my_application_dispose(GObject* object) {
  MyApplication* self = MY_APPLICATION(object);
  g_clear_pointer(&self->dart_entrypoint_arguments, g_strfreev);
  G_OBJECT_CLASS(my_application_parent_class)->dispose(object);
}

static void my_application_class_init(MyApplicationClass* klass) {
  G_APPLICATION_CLASS(klass)->activate = my_application_activate;
  G_APPLICATION_CLASS(klass)->local_command_line = my_application_local_command_line;
  G_APPLICATION_CLASS(klass)->startup = my_application_startup;
  G_APPLICATION_CLASS(klass)->shutdown = my_application_shutdown;
  G_OBJECT_CLASS(klass)->dispose = my_application_dispose;
}

static void my_application_init(MyApplication* self) {}

MyApplication* my_application_new() {
  // Set the program name to the application ID, which helps various systems
  // like GTK and desktop environments map this running application to its
  // corresponding .desktop file. This ensures better integration by allowing
  // the application to be recognized beyond its binary name.
  g_set_prgname(APPLICATION_ID);

  return MY_APPLICATION(g_object_new(my_application_get_type(),
                                     "application-id", APPLICATION_ID,
                                     "flags", G_APPLICATION_NON_UNIQUE,
                                     nullptr));
}

## lib\data\services\microtask_service.dart <a id="microtask_service_dart"></a>

### Dependencies

- `package:cloud_firestore/cloud_firestore.dart`
- `package:uuid/uuid.dart`
- `../models/microtask_model.dart`
- `../models/user_microtask_model.dart`
- `../../core/exceptions/app_exceptions.dart`

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:uuid/uuid.dart';
import '../models/microtask_model.dart';
import '../models/user_microtask_model.dart';
import '../../core/exceptions/app_exceptions.dart';

/// Servi√ßo respons√°vel por opera√ß√µes relacionadas a microtasks no Firebase
class MicrotaskService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final Uuid _uuid = const Uuid();

  // Refer√™ncias das cole√ß√µes
  CollectionReference get _microtasksCollection =>
      _firestore.collection('microtasks');
  CollectionReference get _userMicrotasksCollection =>
      _firestore.collection('user_microtasks');

  /// Cria uma nova microtask
  Future<MicrotaskModel> createMicrotask({
    required String taskId,
    required String eventId,
    required String title,
    required String description,
    required List<String> requiredSkills,
    required List<String> requiredResources,
    DateTime? startDateTime,
    DateTime? endDateTime,
    required String priority,
    required int maxVolunteers,
    required String createdBy,
    String? notes,
  }) async {
    try {
      // Gera um ID √∫nico para a microtask
      final microtaskId = _uuid.v4();
      final now = DateTime.now();

      // Cria a microtask com dados gerados pelo service
      final microtask = MicrotaskModel.create(
        id: microtaskId,
        taskId: taskId,
        eventId: eventId,
        title: title,
        description: description,
        requiredSkills: requiredSkills,
        requiredResources: requiredResources,
        startDateTime: startDateTime,
        endDateTime: endDateTime,
        priority: priority,
        maxVolunteers: maxVolunteers,
        createdBy: createdBy,
        createdAt: now,
        updatedAt: now,
        notes: notes,
      );

      // Note: Validation should be done by repository/controller before calling service

      // Salva no Firestore
      await _microtasksCollection.doc(microtaskId).set(microtask.toFirestore());

      return microtask;
    } catch (e) {
      if (e is ValidationException) rethrow;
      throw DatabaseException('Erro ao criar microtask: ${e.toString()}');
    }
  }

  /// Busca uma microtask por ID
  Future<MicrotaskModel?> getMicrotaskById(String microtaskId) async {
    try {
      final doc = await _microtasksCollection.doc(microtaskId).get();

      if (!doc.exists) return null;

      return MicrotaskModel.fromFirestore(doc);
    } catch (e) {
      throw DatabaseException('Erro ao buscar microtask: ${e.toString()}');
    }
  }

  /// Busca todas as microtasks de uma task
  Future<List<MicrotaskModel>> getMicrotasksByTaskId(String taskId) async {
    try {
      final querySnapshot = await _microtasksCollection
          .where('taskId', isEqualTo: taskId)
          .orderBy('createdAt', descending: false)
          .get();

      return querySnapshot.docs
          .map((doc) => MicrotaskModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      print('Erro ao buscar microtasks da task: ${e.toString()}');
      throw DatabaseException(
        'Erro ao buscar microtasks da task: ${e.toString()}',
      );
    }
  }

  /// Busca todas as microtasks de um evento
  Future<List<MicrotaskModel>> getMicrotasksByEventId(String eventId) async {
    try {
      final querySnapshot = await _microtasksCollection
          .where('eventId', isEqualTo: eventId)
          .orderBy('createdAt', descending: false)
          .get();

      return querySnapshot.docs
          .map((doc) => MicrotaskModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      throw DatabaseException(
        'Erro ao buscar microtasks do evento: ${e.toString()}',
      );
    }
  }

  /// Busca microtasks atribu√≠das a um usu√°rio espec√≠fico
  Future<List<MicrotaskModel>> getMicrotasksByUserId(String userId) async {
    try {
      final querySnapshot = await _microtasksCollection
          .where('assignedTo', arrayContains: userId)
          .orderBy('createdAt', descending: false)
          .get();

      return querySnapshot.docs
          .map((doc) => MicrotaskModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      throw DatabaseException(
        'Erro ao buscar microtasks do usu√°rio: ${e.toString()}',
      );
    }
  }

  /// Busca microtasks por status
  Future<List<MicrotaskModel>> getMicrotasksByStatus(
    String eventId,
    MicrotaskStatus status,
  ) async {
    try {
      final querySnapshot = await _microtasksCollection
          .where('eventId', isEqualTo: eventId)
          .where('status', isEqualTo: status.value)
          .orderBy('createdAt', descending: false)
          .get();

      return querySnapshot.docs
          .map((doc) => MicrotaskModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      throw DatabaseException(
        'Erro ao buscar microtasks por status: ${e.toString()}',
      );
    }
  }

  /// Atualiza uma microtask
  Future<MicrotaskModel> updateMicrotask(MicrotaskModel microtask) async {
    try {
      if (microtask.id.isEmpty) {
        throw ValidationException(
          'ID da microtask √© obrigat√≥rio para atualiza√ß√£o',
        );
      }

      // Valida os dados antes de salvar
      final validationErrors = microtask.validate();
      if (validationErrors.isNotEmpty) {
        throw ValidationException(
          'Dados inv√°lidos: ${validationErrors.join(', ')}',
        );
      }

      // Atualiza o timestamp
      final updatedMicrotask = microtask.withUpdatedTimestamp();

      // Salva no Firestore
      await _microtasksCollection
          .doc(microtask.id)
          .update(updatedMicrotask.toFirestore());

      return updatedMicrotask;
    } catch (e) {
      if (e is ValidationException) rethrow;
      throw DatabaseException('Erro ao atualizar microtask: ${e.toString()}');
    }
  }

  /// Atribui um volunt√°rio a uma microtask
  Future<MicrotaskModel> assignVolunteer(
    String microtaskId,
    String userId,
  ) async {
    try {
      final microtask = await getMicrotaskById(microtaskId);
      if (microtask == null) {
        throw DatabaseException('Microtask n√£o encontrada');
      }

      // Verifica se j√° est√° atribu√≠do
      if (microtask.isAssignedTo(userId)) {
        throw ValidationException('Usu√°rio j√° est√° atribu√≠do a esta microtask');
      }

      // Verifica se h√° vagas dispon√≠veis
      if (!microtask.hasAvailableSlots) {
        throw ValidationException('N√£o h√° vagas dispon√≠veis nesta microtask');
      }

      // Atribui o volunt√°rio
      final updatedMicrotask = microtask.assignVolunteer(userId);

      // Salva a microtask atualizada
      final savedMicrotask = await updateMicrotask(updatedMicrotask);

      // Cria o registro de rela√ß√£o usu√°rio-microtask
      await _createUserMicrotaskRelation(
        userId,
        microtaskId,
        microtask.eventId,
      );

      print('Volunt√°rio atribu√≠do com sucesso!');

      return savedMicrotask;
    } catch (e) {
      if (e is DatabaseException || e is ValidationException) rethrow;
      throw DatabaseException('Erro ao atribuir volunt√°rio: ${e.toString()}');
    }
  }

  /// Remove um volunt√°rio de uma microtask
  Future<MicrotaskModel> unassignVolunteer(
    String microtaskId,
    String userId,
  ) async {
    try {
      final microtask = await getMicrotaskById(microtaskId);
      if (microtask == null) {
        throw DatabaseException('Microtask n√£o encontrada');
      }

      // Verifica se est√° atribu√≠do
      if (!microtask.isAssignedTo(userId)) {
        throw ValidationException(
          'Usu√°rio n√£o est√° atribu√≠do a esta microtask',
        );
      }

      // Remove o volunt√°rio
      final updatedMicrotask = microtask.unassignVolunteer(userId);

      // Salva a microtask atualizada
      final savedMicrotask = await updateMicrotask(updatedMicrotask);

      // Remove o registro de rela√ß√£o usu√°rio-microtask
      await _deleteUserMicrotaskRelation(userId, microtaskId);

      return savedMicrotask;
    } catch (e) {
      if (e is DatabaseException || e is ValidationException) rethrow;
      throw DatabaseException('Erro ao remover volunt√°rio: ${e.toString()}');
    }
  }

  /// Atualiza o status de uma microtask
  Future<MicrotaskModel> updateMicrotaskStatus(
    String microtaskId,
    MicrotaskStatus status,
  ) async {
    try {
      final microtask = await getMicrotaskById(microtaskId);
      if (microtask == null) {
        throw DatabaseException('Microtask n√£o encontrada');
      }

      MicrotaskModel updatedMicrotask;
      switch (status) {
        case MicrotaskStatus.inProgress:
          updatedMicrotask = microtask.markAsStarted();
          break;
        case MicrotaskStatus.completed:
          updatedMicrotask = microtask.markAsCompleted();
          break;
        case MicrotaskStatus.cancelled:
          updatedMicrotask = microtask.markAsCancelled();
          break;
        default:
          updatedMicrotask = microtask.copyWith(
            status: status,
            updatedAt: DateTime.now(),
          );
      }

      return await updateMicrotask(updatedMicrotask);
    } catch (e) {
      if (e is DatabaseException || e is ValidationException) rethrow;
      throw DatabaseException(
        'Erro ao atualizar status da microtask: ${e.toString()}',
      );
    }
  }

  /// Deleta uma microtask
  Future<void> deleteMicrotask(String microtaskId) async {
    try {
      // Remove todas as rela√ß√µes usu√°rio-microtask
      await _deleteAllUserMicrotaskRelations(microtaskId);

      // Remove a microtask
      await _microtasksCollection.doc(microtaskId).delete();
    } catch (e) {
      throw DatabaseException('Erro ao deletar microtask: ${e.toString()}');
    }
  }

  /// Deleta todas as microtasks de uma task
  Future<void> deleteMicrotasksByTaskId(String taskId) async {
    try {
      final microtasks = await getMicrotasksByTaskId(taskId);

      final batch = _firestore.batch();
      for (final microtask in microtasks) {
        // Decrementa o contador para cada volunt√°rio atribu√≠do
        for (final userId in microtask.assignedTo) {
          try {
            await _decrementVolunteerMicrotaskCount(microtask.eventId, userId);
          } catch (e) {
            // Log do erro, mas n√£o interrompe o processo de dele√ß√£o
            print('Erro ao decrementar contador para usu√°rio $userId: $e');
          }
        }

        // Remove rela√ß√µes usu√°rio-microtask
        await _deleteAllUserMicrotaskRelations(microtask.id);

        // Adiciona remo√ß√£o da microtask ao batch
        batch.delete(_microtasksCollection.doc(microtask.id));
      }

      await batch.commit();
    } catch (e) {
      throw DatabaseException(
        'Erro ao deletar microtasks da task: ${e.toString()}',
      );
    }
  }

  /// Stream para escutar mudan√ßas em uma microtask
  Stream<MicrotaskModel?> watchMicrotask(String microtaskId) {
    return _microtasksCollection.doc(microtaskId).snapshots().map((doc) {
      if (!doc.exists) return null;
      return MicrotaskModel.fromFirestore(doc);
    });
  }

  /// Stream para escutar mudan√ßas nas microtasks de uma task
  Stream<List<MicrotaskModel>> watchMicrotasksByTaskId(String taskId) {
    return _microtasksCollection
        .where('taskId', isEqualTo: taskId)
        .orderBy('createdAt', descending: false)
        .snapshots()
        .map(
          (snapshot) => snapshot.docs
              .map((doc) => MicrotaskModel.fromFirestore(doc))
              .toList(),
        );
  }

  /// Stream para escutar mudan√ßas nas microtasks de um evento
  Stream<List<MicrotaskModel>> watchMicrotasksByEventId(String eventId) {
    return _microtasksCollection
        .where('eventId', isEqualTo: eventId)
        .orderBy('createdAt', descending: false)
        .snapshots()
        .map(
          (snapshot) => snapshot.docs
              .map((doc) => MicrotaskModel.fromFirestore(doc))
              .toList(),
        );
  }

  /// Cria uma rela√ß√£o usu√°rio-microtask
  Future<void> _createUserMicrotaskRelation(
    String userId,
    String microtaskId,
    String eventId,
  ) async {
    try {
      final relationId = _uuid.v4();
      final now = DateTime.now();

      final userMicrotask = UserMicrotaskModel.create(
        id: relationId,
        userId: userId,
        microtaskId: microtaskId,
        eventId: eventId,
        assignedAt: now,
        createdAt: now,
        updatedAt: now,
      );

      await _userMicrotasksCollection
          .doc(relationId)
          .set(userMicrotask.toFirestore());
      print('Rela√ß√£o usu√°rio-microtask criada com sucesso!');
    } catch (e) {
      print('Erro ao criar rela√ß√£o usu√°rio-microtask: ${e.toString()}');
      throw DatabaseException(
        'Erro ao criar rela√ß√£o usu√°rio-microtask: ${e.toString()}',
      );
    }
  }

  /// Remove uma rela√ß√£o usu√°rio-microtask espec√≠fica
  Future<void> _deleteUserMicrotaskRelation(
    String userId,
    String microtaskId,
  ) async {
    try {
      final querySnapshot = await _userMicrotasksCollection
          .where('userId', isEqualTo: userId)
          .where('microtaskId', isEqualTo: microtaskId)
          .get();

      final batch = _firestore.batch();
      for (final doc in querySnapshot.docs) {
        batch.delete(doc.reference);
      }

      await batch.commit();
    } catch (e) {
      throw DatabaseException(
        'Erro ao remover rela√ß√£o usu√°rio-microtask: ${e.toString()}',
      );
    }
  }

  /// Remove todas as rela√ß√µes usu√°rio-microtask de uma microtask
  Future<void> _deleteAllUserMicrotaskRelations(String microtaskId) async {
    try {
      final querySnapshot = await _userMicrotasksCollection
          .where('microtaskId', isEqualTo: microtaskId)
          .get();

      final batch = _firestore.batch();
      for (final doc in querySnapshot.docs) {
        batch.delete(doc.reference);
      }

      await batch.commit();
    } catch (e) {
      throw DatabaseException(
        'Erro ao remover rela√ß√µes usu√°rio-microtask: ${e.toString()}',
      );
    }
  }

  /// Decrementa o contador de microtasks atribu√≠das para um volunt√°rio
  /// Implementa√ß√£o local para evitar depend√™ncia circular com EventService
  Future<void> _decrementVolunteerMicrotaskCount(
    String eventId,
    String userId,
  ) async {
    try {
      final profileQuery = await _firestore
          .collection('volunteer_profiles')
          .where('eventId', isEqualTo: eventId)
          .where('userId', isEqualTo: userId)
          .limit(1)
          .get();

      if (profileQuery.docs.isNotEmpty) {
        final doc = profileQuery.docs.first;
        final currentData = doc.data();

        // Verifica se o campo existe, se n√£o, inicializa com contagem real
        int assignedCount;
        if (currentData.containsKey('assignedMicrotasksCount')) {
          assignedCount = currentData['assignedMicrotasksCount'] as int? ?? 0;
        } else {
          // Campo n√£o existe, calcula a contagem real e inicializa
          assignedCount = await _calculateActualMicrotaskCount(eventId, userId);
        }

        await doc.reference.update({
          'assignedMicrotasksCount': assignedCount > 0 ? assignedCount - 1 : 0,
        });
      }
    } catch (e) {
      throw DatabaseException(
        'Erro ao decrementar contador de microtasks: ${e.toString()}',
      );
    }
  }

  /// Calcula a contagem real de microtasks atribu√≠das a um volunt√°rio
  /// Implementa√ß√£o local para evitar depend√™ncia circular
  Future<int> _calculateActualMicrotaskCount(
    String eventId,
    String userId,
  ) async {
    try {
      final microtasksQuery = await _microtasksCollection
          .where('eventId', isEqualTo: eventId)
          .where('assignedTo', arrayContains: userId)
          .get();

      return microtasksQuery.docs.length;
    } catch (e) {
      // Em caso de erro, retorna 0 para n√£o quebrar o fluxo
      print('Erro ao calcular contagem real de microtasks: $e');
      return 0;
    }
  }
}

## lib\data\models\microtask_model.dart <a id="microtask_model_dart"></a>

### Dependencies

- `package:cloud_firestore/cloud_firestore.dart`

import 'package:cloud_firestore/cloud_firestore.dart';

/// Enums para status das microtasks
enum MicrotaskStatus {
  pending('pending'),
  assigned('assigned'),
  inProgress('in_progress'),
  completed('completed'),
  cancelled('cancelled');

  const MicrotaskStatus(this.value);
  final String value;

  static MicrotaskStatus fromString(String value) {
    return MicrotaskStatus.values.firstWhere(
      (status) => status.value == value,
      orElse: () => MicrotaskStatus.pending,
    );
  }

  @override
  String toString() => value;
}

/// Modelo de dados para representar uma microtask no sistema
/// Microtasks s√£o as unidades de trabalho que podem ter m√∫ltiplos volunt√°rios
/// Baseado na estrutura definida no SPEC_GERAL.md
class MicrotaskModel {
  final String id;
  final String taskId;
  final String eventId;
  final String title;
  final String description;
  final List<String> assignedTo;
  final int maxVolunteers;
  final List<String> requiredSkills;
  final List<String> requiredResources;
  final DateTime?
  startDateTime; // Data e hora inicial da microtask (dd/mm/yyyy HH:MM)
  final DateTime?
  endDateTime; // Data e hora final da microtask (dd/mm/yyyy HH:MM)
  final String priority; // Usa string para compatibilidade com TaskPriority
  final MicrotaskStatus status;
  final String createdBy;
  final DateTime? assignedAt;
  final DateTime? startedAt;
  final DateTime? completedAt;
  final String notes;
  final DateTime createdAt;
  final DateTime updatedAt;

  const MicrotaskModel({
    required this.id,
    required this.taskId,
    required this.eventId,
    required this.title,
    required this.description,
    required this.assignedTo,
    required this.maxVolunteers,
    required this.requiredSkills,
    required this.requiredResources,
    this.startDateTime,
    this.endDateTime,
    required this.priority,
    required this.status,
    required this.createdBy,
    this.assignedAt,
    this.startedAt,
    this.completedAt,
    required this.notes,
    required this.createdAt,
    required this.updatedAt,
  });

  /// Cria uma inst√¢ncia de MicrotaskModel a partir de um Map (JSON)
  factory MicrotaskModel.fromMap(Map<String, dynamic> map) {
    return MicrotaskModel(
      id: map['id'] as String,
      taskId: map['taskId'] as String,
      eventId: map['eventId'] as String,
      title: map['title'] as String,
      description: map['description'] as String,
      assignedTo: List<String>.from(map['assignedTo'] as List? ?? []),
      maxVolunteers: map['maxVolunteers'] as int? ?? 1,
      requiredSkills: List<String>.from(map['requiredSkills'] as List? ?? []),
      requiredResources: List<String>.from(
        map['requiredResources'] as List? ?? [],
      ),
      startDateTime: map['startDateTime'] != null
          ? (map['startDateTime'] as Timestamp).toDate()
          : null,
      endDateTime: map['endDateTime'] != null
          ? (map['endDateTime'] as Timestamp).toDate()
          : null,
      priority: map['priority'] as String? ?? 'medium',
      status: MicrotaskStatus.fromString(map['status'] as String? ?? 'pending'),
      createdBy: map['createdBy'] as String,
      assignedAt: map['assignedAt'] != null
          ? (map['assignedAt'] as Timestamp).toDate()
          : null,
      startedAt: map['startedAt'] != null
          ? (map['startedAt'] as Timestamp).toDate()
          : null,
      completedAt: map['completedAt'] != null
          ? (map['completedAt'] as Timestamp).toDate()
          : null,
      notes: map['notes'] as String? ?? '',
      createdAt: (map['createdAt'] as Timestamp).toDate(),
      updatedAt: (map['updatedAt'] as Timestamp).toDate(),
    );
  }

  /// Cria uma inst√¢ncia de MicrotaskModel a partir de um DocumentSnapshot do Firestore
  factory MicrotaskModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return MicrotaskModel.fromMap({'id': doc.id, ...data});
  }

  /// Converte a inst√¢ncia para um Map (JSON)
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'taskId': taskId,
      'eventId': eventId,
      'title': title,
      'description': description,
      'assignedTo': assignedTo,
      'maxVolunteers': maxVolunteers,
      'requiredSkills': requiredSkills,
      'requiredResources': requiredResources,
      'startDateTime': startDateTime != null
          ? Timestamp.fromDate(startDateTime!)
          : null,
      'endDateTime': endDateTime != null
          ? Timestamp.fromDate(endDateTime!)
          : null,
      'priority': priority,
      'status': status.value,
      'createdBy': createdBy,
      'assignedAt': assignedAt != null ? Timestamp.fromDate(assignedAt!) : null,
      'startedAt': startedAt != null ? Timestamp.fromDate(startedAt!) : null,
      'completedAt': completedAt != null
          ? Timestamp.fromDate(completedAt!)
          : null,
      'notes': notes,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
    };
  }

  /// Converte para formato do Firestore (sem o ID)
  Map<String, dynamic> toFirestore() {
    final map = toMap();
    map.remove('id');
    return map;
  }

  /// Cria uma c√≥pia da inst√¢ncia com alguns campos alterados
  MicrotaskModel copyWith({
    String? id,
    String? taskId,
    String? eventId,
    String? title,
    String? description,
    List<String>? assignedTo,
    int? maxVolunteers,
    List<String>? requiredSkills,
    List<String>? requiredResources,
    DateTime? startDateTime,
    DateTime? endDateTime,
    String? priority,
    MicrotaskStatus? status,
    String? createdBy,
    DateTime? assignedAt,
    DateTime? startedAt,
    DateTime? completedAt,
    String? notes,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return MicrotaskModel(
      id: id ?? this.id,
      taskId: taskId ?? this.taskId,
      eventId: eventId ?? this.eventId,
      title: title ?? this.title,
      description: description ?? this.description,
      assignedTo: assignedTo ?? List<String>.from(this.assignedTo),
      maxVolunteers: maxVolunteers ?? this.maxVolunteers,
      requiredSkills: requiredSkills ?? List<String>.from(this.requiredSkills),
      requiredResources:
          requiredResources ?? List<String>.from(this.requiredResources),
      startDateTime: startDateTime ?? this.startDateTime,
      endDateTime: endDateTime ?? this.endDateTime,
      priority: priority ?? this.priority,
      status: status ?? this.status,
      createdBy: createdBy ?? this.createdBy,
      assignedAt: assignedAt ?? this.assignedAt,
      startedAt: startedAt ?? this.startedAt,
      completedAt: completedAt ?? this.completedAt,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  /// Cria uma nova inst√¢ncia com updatedAt atualizado para agora
  MicrotaskModel withUpdatedTimestamp() {
    return copyWith(updatedAt: DateTime.now());
  }

  /// Factory para criar uma nova microtask
  /// Note: ID e timestamps devem ser definidos pelo service
  factory MicrotaskModel.create({
    required String id,
    required String taskId,
    required String eventId,
    required String title,
    required String description,
    required List<String> requiredSkills,
    required List<String> requiredResources,
    DateTime? startDateTime,
    DateTime? endDateTime,
    required String priority,
    required int maxVolunteers,
    required String createdBy,
    required DateTime createdAt,
    required DateTime updatedAt,
    String? notes,
  }) {
    return MicrotaskModel(
      id: id,
      taskId: taskId,
      eventId: eventId,
      title: title,
      description: description,
      assignedTo: [],
      maxVolunteers: maxVolunteers > 0 ? maxVolunteers : 1,
      requiredSkills: requiredSkills,
      requiredResources: requiredResources,
      startDateTime: startDateTime,
      endDateTime: endDateTime,
      priority: priority,
      status: MicrotaskStatus.pending,
      createdBy: createdBy,
      notes: notes ?? '',
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  /// Valida se os dados da microtask s√£o v√°lidos
  List<String> validate() {
    final errors = <String>[];

    if (taskId.isEmpty) {
      errors.add('ID da task pai √© obrigat√≥rio');
    }

    if (eventId.isEmpty) {
      errors.add('ID do evento √© obrigat√≥rio');
    }

    if (title.isEmpty) {
      errors.add('T√≠tulo da microtask √© obrigat√≥rio');
    } else if (title.length < 3) {
      errors.add('T√≠tulo deve ter pelo menos 3 caracteres');
    } else if (title.length > 100) {
      errors.add('T√≠tulo deve ter no m√°ximo 100 caracteres');
    }

    if (description.isEmpty) {
      errors.add('Descri√ß√£o da microtask √© obrigat√≥ria');
    } else if (description.length > 1000) {
      errors.add('Descri√ß√£o deve ter no m√°ximo 1000 caracteres');
    }

    if (maxVolunteers <= 0) {
      errors.add('N√∫mero m√°ximo de volunt√°rios deve ser maior que zero');
    }

    if (assignedTo.length > maxVolunteers) {
      errors.add('N√∫mero de volunt√°rios atribu√≠dos excede o m√°ximo permitido');
    }

    if (startDateTime != null &&
        endDateTime != null &&
        startDateTime!.isAfter(endDateTime!)) {
      errors.add('Data/hora inicial deve ser anterior √† data/hora final');
    }

    if (createdBy.isEmpty) {
      errors.add('Criador da microtask √© obrigat√≥rio');
    }

    return errors;
  }

  /// Verifica se a microtask √© v√°lida
  bool isValid() => validate().isEmpty;

  /// Verifica se h√° vagas dispon√≠veis para volunt√°rios
  bool get hasAvailableSlots => assignedTo.length < maxVolunteers;

  /// N√∫mero de vagas dispon√≠veis
  int get availableSlots => maxVolunteers - assignedTo.length;

  /// Verifica se a microtask est√° conclu√≠da
  bool get isCompleted => status == MicrotaskStatus.completed;

  /// Verifica se a microtask est√° em progresso
  bool get isInProgress => status == MicrotaskStatus.inProgress;

  /// Verifica se a microtask est√° pendente
  bool get isPending => status == MicrotaskStatus.pending;

  /// Verifica se a microtask foi cancelada
  bool get isCancelled => status == MicrotaskStatus.cancelled;

  /// Verifica se a microtask tem volunt√°rios atribu√≠dos
  bool get hasAssignedVolunteers => assignedTo.isNotEmpty;

  /// Verifica se um usu√°rio espec√≠fico est√° atribu√≠do √† microtask
  bool isAssignedTo(String userId) => assignedTo.contains(userId);

  /// Adiciona um volunt√°rio √† microtask
  MicrotaskModel assignVolunteer(String userId) {
    if (isAssignedTo(userId)) {
      return this; // J√° est√° atribu√≠do
    }

    if (!hasAvailableSlots) {
      return this; // N√£o h√° vagas dispon√≠veis
    }

    final newAssignedTo = List<String>.from(assignedTo)..add(userId);
    final now = DateTime.now();

    return copyWith(
      assignedTo: newAssignedTo,
      status: MicrotaskStatus.assigned,
      assignedAt: assignedAt ?? now,
      updatedAt: now,
    );
  }

  /// Remove um volunt√°rio da microtask
  MicrotaskModel unassignVolunteer(String userId) {
    if (!isAssignedTo(userId)) {
      return this; // N√£o est√° atribu√≠do
    }

    final newAssignedTo = List<String>.from(assignedTo)..remove(userId);
    final now = DateTime.now();

    // Atualiza o status baseado no n√∫mero de volunt√°rios restantes
    MicrotaskStatus newStatus;
    if (newAssignedTo.isEmpty) {
      newStatus = MicrotaskStatus.pending;
    } else {
      newStatus = status; // Mant√©m o status atual se ainda h√° volunt√°rios
    }

    return copyWith(
      assignedTo: newAssignedTo,
      status: newStatus,
      updatedAt: now,
    );
  }

  /// Marca a microtask como iniciada
  MicrotaskModel markAsStarted() {
    if (status == MicrotaskStatus.pending ||
        status == MicrotaskStatus.assigned) {
      final now = DateTime.now();
      return copyWith(
        status: MicrotaskStatus.inProgress,
        startedAt: startedAt ?? now,
        updatedAt: now,
      );
    }
    return this;
  }

  /// Marca a microtask como conclu√≠da
  MicrotaskModel markAsCompleted() {
    final now = DateTime.now();
    return copyWith(
      status: MicrotaskStatus.completed,
      completedAt: completedAt ?? now,
      updatedAt: now,
    );
  }

  /// Marca a microtask como cancelada
  MicrotaskModel markAsCancelled() {
    final now = DateTime.now();
    return copyWith(status: MicrotaskStatus.cancelled, updatedAt: now);
  }

  /// Atualiza as notas da microtask
  MicrotaskModel updateNotes(String newNotes) {
    return copyWith(notes: newNotes, updatedAt: DateTime.now());
  }

  /// Verifica se a microtask √© compat√≠vel com as habilidades de um volunt√°rio
  bool isCompatibleWith(List<String> volunteerSkills) {
    if (requiredSkills.isEmpty) return true;

    return requiredSkills.every((skill) => volunteerSkills.contains(skill));
  }

  /// Calcula a porcentagem de compatibilidade com as habilidades de um volunt√°rio
  double getCompatibilityScore(List<String> volunteerSkills) {
    if (requiredSkills.isEmpty) return 1.0;

    final matchingSkills = requiredSkills
        .where((skill) => volunteerSkills.contains(skill))
        .length;
    return matchingSkills / requiredSkills.length;
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is MicrotaskModel &&
        other.id == id &&
        other.taskId == taskId &&
        other.eventId == eventId &&
        other.title == title &&
        other.description == description &&
        other.maxVolunteers == maxVolunteers &&
        other.startDateTime == startDateTime &&
        other.endDateTime == endDateTime &&
        other.priority == priority &&
        other.status == status &&
        other.createdBy == createdBy;
  }

  @override
  int get hashCode {
    return Object.hash(
      id,
      taskId,
      eventId,
      title,
      description,
      maxVolunteers,
      startDateTime,
      endDateTime,
      priority,
      status,
      createdBy,
    );
  }

  /// Retorna a dura√ß√£o estimada em horas (para compatibilidade)
  double get estimatedHours {
    if (startDateTime == null || endDateTime == null) return 0.0;
    final duration = endDateTime!.difference(startDateTime!);
    return duration.inMinutes / 60.0;
  }

  /// Retorna a data/hora inicial formatada
  String get startDateTimeFormatted {
    if (startDateTime == null) return 'N√£o definida';
    return '${startDateTime!.day.toString().padLeft(2, '0')}/${startDateTime!.month.toString().padLeft(2, '0')}/${startDateTime!.year} ${startDateTime!.hour.toString().padLeft(2, '0')}:${startDateTime!.minute.toString().padLeft(2, '0')}';
  }

  /// Retorna a data/hora final formatada
  String get endDateTimeFormatted {
    if (endDateTime == null) return 'N√£o definida';
    return '${endDateTime!.day.toString().padLeft(2, '0')}/${endDateTime!.month.toString().padLeft(2, '0')}/${endDateTime!.year} ${endDateTime!.hour.toString().padLeft(2, '0')}:${endDateTime!.minute.toString().padLeft(2, '0')}';
  }

  /// Retorna o per√≠odo formatado
  String get periodFormatted {
    if (startDateTime == null || endDateTime == null) {
      return 'Per√≠odo n√£o definido';
    }
    return '$startDateTimeFormatted - $endDateTimeFormatted';
  }

  /// Verifica se a microtask tem hor√°rio definido
  bool get hasSchedule => startDateTime != null && endDateTime != null;

  @override
  String toString() {
    return 'MicrotaskModel(id: $id, title: $title, status: $status, assigned: ${assignedTo.length}/$maxVolunteers)';
  }
}

## lib\utils\migration_utils.dart <a id="migration_utils_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../data/repositories/event_repository.dart`
- `../presentation/controllers/event_controller.dart`

import 'package:flutter/material.dart';
import '../data/repositories/event_repository.dart';
import '../presentation/controllers/event_controller.dart';

/// Utilit√°rios para migra√ß√£o de dados do banco
class MigrationUtils {
  static final EventRepository _eventRepository = EventRepository();

  /// Executa a migra√ß√£o de perfis de volunt√°rios para incluir o campo assignedMicrotasksCount
  /// Este m√©todo deve ser executado uma √∫nica vez ap√≥s a implementa√ß√£o do sistema de contagem
  static Future<bool> runVolunteerProfilesMigration() async {
    try {
      await _eventRepository.migrateVolunteerProfilesTaskCounts();
      return true;
    } catch (e) {
      print('Erro na migra√ß√£o: $e');
      return false;
    }
  }

  /// Recalcula os contadores para um evento espec√≠fico
  static Future<bool> recalculateEventCounts(String eventId) async {
    try {
      await _eventRepository.recalculateEventVolunteerCounts(eventId);
      return true;
    } catch (e) {
      print('Erro ao recalcular contadores: $e');
      return false;
    }
  }

  /// Recalcula o contador para um volunt√°rio espec√≠fico
  static Future<bool> recalculateVolunteerCount(String eventId, String userId) async {
    try {
      await _eventRepository.recalculateVolunteerMicrotaskCount(eventId, userId);
      return true;
    } catch (e) {
      print('Erro ao recalcular contador do volunt√°rio: $e');
      return false;
    }
  }

  /// Mostra um di√°logo para executar a migra√ß√£o
  static void showMigrationDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Migra√ß√£o de Dados'),
        content: const Text(
          'Esta opera√ß√£o ir√° migrar todos os perfis de volunt√°rios existentes '
          'para incluir o campo de contagem de microtasks. Esta opera√ß√£o deve '
          'ser executada apenas uma vez.\n\n'
          'Deseja continuar?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancelar'),
          ),
          ElevatedButton(
            onPressed: () async {
              Navigator.of(context).pop();
              _showMigrationProgress(context);
            },
            child: const Text('Executar Migra√ß√£o'),
          ),
        ],
      ),
    );
  }

  /// Mostra o progresso da migra√ß√£o
  static void _showMigrationProgress(BuildContext context) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('Executando Migra√ß√£o'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const CircularProgressIndicator(),
            const SizedBox(height: 16),
            const Text('Migrando perfis de volunt√°rios...'),
          ],
        ),
      ),
    );

    runVolunteerProfilesMigration().then((success) {
      Navigator.of(context).pop(); // Fecha o di√°logo de progresso

      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text(success ? 'Sucesso' : 'Erro'),
          content: Text(
            success
              ? 'Migra√ß√£o executada com sucesso!'
              : 'Erro ao executar a migra√ß√£o. Verifique os logs.',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('OK'),
            ),
          ],
        ),
      );
    });
  }

  /// Mostra um di√°logo para recalcular contadores de um evento
  static void showRecalculateEventDialog(BuildContext context, String eventId) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Recalcular Contadores'),
        content: const Text(
          'Esta opera√ß√£o ir√° recalcular os contadores de microtasks '
          'para todos os volunt√°rios deste evento baseado nas '
          'atribui√ß√µes reais no banco de dados.\n\n'
          'Deseja continuar?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancelar'),
          ),
          ElevatedButton(
            onPressed: () async {
              Navigator.of(context).pop();

              final success = await recalculateEventCounts(eventId);

              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(
                      success
                        ? 'Contadores recalculados com sucesso!'
                        : 'Erro ao recalcular contadores.',
                    ),
                    backgroundColor: success ? Colors.green : Colors.red,
                  ),
                );
              }
            },
            child: const Text('Recalcular'),
          ),
        ],
      ),
    );
  }
}

## lib\data\repositories\microtask_repository.dart <a id="microtask_repository_dart"></a>

### Dependencies

- `../models/microtask_model.dart`
- `../models/user_microtask_model.dart`
- `../models/volunteer_profile_model.dart`
- `../services/microtask_service.dart`
- `../services/assignment_service.dart`
- `../../core/exceptions/app_exceptions.dart`

import '../models/microtask_model.dart';
import '../models/user_microtask_model.dart';
import '../models/volunteer_profile_model.dart';
import '../services/microtask_service.dart';
import '../services/assignment_service.dart';
import '../../core/exceptions/app_exceptions.dart';

/// Reposit√≥rio respons√°vel por gerenciar dados de microtasks
/// Atua como uma camada de abstra√ß√£o entre os controllers e os services
class MicrotaskRepository {
  final MicrotaskService _microtaskService;
  final AssignmentService _assignmentService;

  MicrotaskRepository({
    MicrotaskService? microtaskService,
    AssignmentService? assignmentService,
  }) : _microtaskService = microtaskService ?? MicrotaskService(),
       _assignmentService = assignmentService ?? AssignmentService();

  /// Cria uma nova microtask
  Future<MicrotaskModel> createMicrotask({
    required String taskId,
    required String eventId,
    required String title,
    required String description,
    required List<String> requiredSkills,
    required List<String> requiredResources,
    DateTime? startDateTime,
    DateTime? endDateTime,
    required String priority,
    required int maxVolunteers,
    required String createdBy,
    String? notes,
  }) async {
    try {
      // Create a temporary microtask for validation
      final tempMicrotask = MicrotaskModel.create(
        id: 'temp', // Temporary ID for validation
        taskId: taskId,
        eventId: eventId,
        title: title.trim(),
        description: description.trim(),
        requiredSkills: requiredSkills,
        requiredResources: requiredResources,
        startDateTime: startDateTime,
        endDateTime: endDateTime,
        priority: priority,
        maxVolunteers: maxVolunteers,
        createdBy: createdBy,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        notes: notes?.trim(),
      );

      // Validate before calling service
      final validationErrors = tempMicrotask.validate();
      if (validationErrors.isNotEmpty) {
        throw ValidationException(
          'Dados inv√°lidos: ${validationErrors.join(', ')}',
        );
      }

      // Repository delegates to service for creation with ID/timestamp generation
      return await _microtaskService.createMicrotask(
        taskId: taskId,
        eventId: eventId,
        title: title.trim(),
        description: description.trim(),
        requiredSkills: requiredSkills,
        requiredResources: requiredResources,
        startDateTime: startDateTime,
        endDateTime: endDateTime,
        priority: priority,
        maxVolunteers: maxVolunteers,
        createdBy: createdBy,
        notes: notes?.trim(),
      );
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao criar microtask: ${e.toString()}');
    }
  }

  /// Busca uma microtask por ID
  Future<MicrotaskModel?> getMicrotaskById(String microtaskId) async {
    try {
      if (microtaskId.isEmpty) {
        throw ValidationException('ID da microtask √© obrigat√≥rio');
      }

      return await _microtaskService.getMicrotaskById(microtaskId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao buscar microtask: ${e.toString()}');
    }
  }

  /// Busca todas as microtasks de uma task
  Future<List<MicrotaskModel>> getMicrotasksByTaskId(String taskId) async {
    try {
      if (taskId.isEmpty) {
        throw ValidationException('ID da task √© obrigat√≥rio');
      }

      return await _microtaskService.getMicrotasksByTaskId(taskId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar microtasks da task: ${e.toString()}',
      );
    }
  }

  /// Busca todas as microtasks de um evento
  Future<List<MicrotaskModel>> getMicrotasksByEventId(String eventId) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      return await _microtaskService.getMicrotasksByEventId(eventId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar microtasks do evento: ${e.toString()}',
      );
    }
  }

  /// Busca microtasks atribu√≠das a um usu√°rio espec√≠fico
  Future<List<MicrotaskModel>> getMicrotasksByUserId(String userId) async {
    try {
      if (userId.isEmpty) {
        throw ValidationException('ID do usu√°rio √© obrigat√≥rio');
      }

      return await _microtaskService.getMicrotasksByUserId(userId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar microtasks do usu√°rio: ${e.toString()}',
      );
    }
  }

  /// Busca microtasks por status
  Future<List<MicrotaskModel>> getMicrotasksByStatus(
    String eventId,
    MicrotaskStatus status,
  ) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      return await _microtaskService.getMicrotasksByStatus(eventId, status);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar microtasks por status: ${e.toString()}',
      );
    }
  }

  /// Atualiza uma microtask
  Future<MicrotaskModel> updateMicrotask(MicrotaskModel microtask) async {
    try {
      if (microtask.id.isEmpty) {
        throw ValidationException(
          'ID da microtask √© obrigat√≥rio para atualiza√ß√£o',
        );
      }

      return await _microtaskService.updateMicrotask(microtask);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao atualizar microtask: ${e.toString()}');
    }
  }

  /// Atribui um volunt√°rio a uma microtask
  Future<MicrotaskModel> assignVolunteer({
    required String microtaskId,
    required String userId,
    required String eventId,
  }) async {
    try {
      if (microtaskId.isEmpty || userId.isEmpty || eventId.isEmpty) {
        throw ValidationException(
          'IDs da microtask, usu√°rio e evento s√£o obrigat√≥rios',
        );
      }

      print("ABACAXI4: assinando microtask");
      return await _assignmentService.assignVolunteerToMicrotask(
        microtaskId: microtaskId,
        userId: userId,
        eventId: eventId,
      );
    } catch (e) {
      print("ABACAX_A3: assinando microtask$e");
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao atribuir volunt√°rio: ${e.toString()}');
    }
  }

  /// Remove um volunt√°rio de uma microtask
  Future<MicrotaskModel> unassignVolunteer({
    required String microtaskId,
    required String userId,
  }) async {
    try {
      if (microtaskId.isEmpty) {
        throw ValidationException('ID da microtask √© obrigat√≥rio');
      }
      if (userId.isEmpty) {
        throw ValidationException('ID do usu√°rio √© obrigat√≥rio');
      }

      return await _assignmentService.unassignVolunteerFromMicrotask(
        microtaskId: microtaskId,
        userId: userId,
      );
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao remover volunt√°rio: ${e.toString()}');
    }
  }

  /// Busca volunt√°rios compat√≠veis com uma microtask
  Future<List<VolunteerProfileModel>> getCompatibleVolunteers({
    required String eventId,
    required String microtaskId,
  }) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }
      if (microtaskId.isEmpty) {
        throw ValidationException('ID da microtask √© obrigat√≥rio');
      }

      return await _assignmentService.getCompatibleVolunteers(
        eventId: eventId,
        microtaskId: microtaskId,
      );
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar volunt√°rios compat√≠veis: ${e.toString()}',
      );
    }
  }

  /// Busca microtasks dispon√≠veis para um volunt√°rio
  Future<List<MicrotaskModel>> getAvailableMicrotasksForVolunteer({
    required String eventId,
    required String userId,
  }) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }
      if (userId.isEmpty) {
        throw ValidationException('ID do usu√°rio √© obrigat√≥rio');
      }

      return await _assignmentService.getAvailableMicrotasksForVolunteer(
        eventId: eventId,
        userId: userId,
      );
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar microtasks dispon√≠veis: ${e.toString()}',
      );
    }
  }

  /// Atualiza o status de uma microtask
  Future<MicrotaskModel> updateMicrotaskStatus(
    String microtaskId,
    MicrotaskStatus status,
  ) async {
    try {
      if (microtaskId.isEmpty) {
        throw ValidationException('ID da microtask √© obrigat√≥rio');
      }

      return await _microtaskService.updateMicrotaskStatus(microtaskId, status);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao atualizar status da microtask: ${e.toString()}',
      );
    }
  }

  /// Busca o status individual de um usu√°rio em uma microtask
  Future<UserMicrotaskModel?> getUserMicrotaskStatus({
    required String userId,
    required String microtaskId,
  }) async {
    try {
      if (userId.isEmpty) {
        throw ValidationException('ID do usu√°rio √© obrigat√≥rio');
      }
      if (microtaskId.isEmpty) {
        throw ValidationException('ID da microtask √© obrigat√≥rio');
      }

      return await _assignmentService.getUserMicrotaskStatus(
        userId: userId,
        microtaskId: microtaskId,
      );
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar status do usu√°rio: ${e.toString()}',
      );
    }
  }

  /// Atualiza o status individual de um usu√°rio em uma microtask
  Future<UserMicrotaskModel> updateUserMicrotaskStatus({
    required String userId,
    required String microtaskId,
    required UserMicrotaskStatus status,
    double? actualHours,
    String? notes,
  }) async {
    try {
      if (userId.isEmpty) {
        throw ValidationException('ID do usu√°rio √© obrigat√≥rio');
      }
      if (microtaskId.isEmpty) {
        throw ValidationException('ID da microtask √© obrigat√≥rio');
      }

      return await _assignmentService.updateUserMicrotaskStatus(
        userId: userId,
        microtaskId: microtaskId,
        status: status,
        actualHours: actualHours,
        notes: notes,
      );
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao atualizar status do usu√°rio: ${e.toString()}',
      );
    }
  }

  /// Busca todas as rela√ß√µes usu√°rio-microtask de uma microtask
  Future<List<UserMicrotaskModel>> getUserMicrotasksByMicrotaskId(
    String microtaskId,
  ) async {
    try {
      if (microtaskId.isEmpty) {
        throw ValidationException('ID da microtask √© obrigat√≥rio');
      }

      return await _assignmentService.getUserMicrotasksByMicrotaskId(
        microtaskId,
      );
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar rela√ß√µes usu√°rio-microtask: ${e.toString()}',
      );
    }
  }

  /// Busca todas as microtasks de um usu√°rio com seus status
  Future<List<UserMicrotaskModel>> getUserMicrotasksByUserId(
    String userId,
  ) async {
    try {
      if (userId.isEmpty) {
        throw ValidationException('ID do usu√°rio √© obrigat√≥rio');
      }

      return await _assignmentService.getUserMicrotasksByUserId(userId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar microtasks do usu√°rio: ${e.toString()}',
      );
    }
  }

  /// Deleta uma microtask
  Future<void> deleteMicrotask(String microtaskId) async {
    try {
      if (microtaskId.isEmpty) {
        throw ValidationException('ID da microtask √© obrigat√≥rio');
      }

      await _microtaskService.deleteMicrotask(microtaskId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao deletar microtask: ${e.toString()}');
    }
  }

  /// Deleta todas as microtasks de uma task
  Future<void> deleteMicrotasksByTaskId(String taskId) async {
    try {
      if (taskId.isEmpty) {
        throw ValidationException('ID da task √© obrigat√≥rio');
      }

      await _microtaskService.deleteMicrotasksByTaskId(taskId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao deletar microtasks da task: ${e.toString()}',
      );
    }
  }

  /// Stream para escutar mudan√ßas em uma microtask
  Stream<MicrotaskModel?> watchMicrotask(String microtaskId) {
    if (microtaskId.isEmpty) {
      throw ValidationException('ID da microtask √© obrigat√≥rio');
    }

    return _microtaskService.watchMicrotask(microtaskId);
  }

  /// Stream para escutar mudan√ßas nas microtasks de uma task
  Stream<List<MicrotaskModel>> watchMicrotasksByTaskId(String taskId) {
    if (taskId.isEmpty) {
      throw ValidationException('ID da task √© obrigat√≥rio');
    }

    return _microtaskService.watchMicrotasksByTaskId(taskId);
  }

  /// Stream para escutar mudan√ßas nas microtasks de um evento
  Stream<List<MicrotaskModel>> watchMicrotasksByEventId(String eventId) {
    if (eventId.isEmpty) {
      throw ValidationException('ID do evento √© obrigat√≥rio');
    }

    return _microtaskService.watchMicrotasksByEventId(eventId);
  }

  /// Valida se os dados de uma microtask s√£o v√°lidos
  bool validateMicrotaskData({
    required String title,
    required String description,
    required String taskId,
    required String eventId,
    required String createdBy,
    required int maxVolunteers,
    DateTime? startDateTime,
    DateTime? endDateTime,
  }) {
    if (title.trim().isEmpty) return false;
    if (title.trim().length < 3) return false;
    if (title.trim().length > 100) return false;
    if (description.trim().isEmpty) return false;
    if (description.trim().length > 1000) return false;
    if (taskId.isEmpty) return false;
    if (eventId.isEmpty) return false;
    if (createdBy.isEmpty) return false;
    if (maxVolunteers <= 0) return false;

    // Valida√ß√£o de data/hora (opcional, mas se fornecida deve ser v√°lida)
    if (startDateTime != null && endDateTime != null) {
      if (startDateTime.isAfter(endDateTime)) return false;
    }

    return true;
  }
}

## pubspec.yaml <a id="pubspec_yaml"></a>

name: contask
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.8.1

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8

  # Firebase
  firebase_core: ^3.0.0
  firebase_auth: ^5.0.0
  cloud_firestore: ^5.0.0
  google_sign_in: ^6.1.5
  google_sign_in_web: ^0.12.0

  # State Management
  provider: ^6.0.5

  # UI & Utils
  cached_network_image: ^3.2.3
  intl: ^0.18.1
  uuid: ^3.0.7

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^5.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package

## android\settings.gradle.kts <a id="settings_gradle_kts"></a>

pluginManagement {
    val flutterSdkPath = run {
        val properties = java.util.Properties()
        file("local.properties").inputStream().use { properties.load(it) }
        val flutterSdkPath = properties.getProperty("flutter.sdk")
        require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
        flutterSdkPath
    }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.7.3" apply false
    // START: FlutterFire Configuration
    id("com.google.gms.google-services") version("4.3.15") apply false
    // END: FlutterFire Configuration
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")

## lib\presentation\widgets\common\skill_chip.dart <a id="skill_chip_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';

/// Chip para exibir habilidades e recursos
class SkillChip extends StatelessWidget {
  final String label;
  final IconData? icon;
  final Color? color;
  final Color? backgroundColor;
  final Color? borderColor;
  final VoidCallback? onTap;
  final VoidCallback? onDelete;
  final bool isSelected;
  final bool isSmall;
  final bool showBorder;

  const SkillChip({
    super.key,
    required this.label,
    this.icon,
    this.color,
    this.backgroundColor,
    this.borderColor,
    this.onTap,
    this.onDelete,
    this.isSelected = false,
    this.isSmall = false,
    this.showBorder = true,
  });

  @override
  Widget build(BuildContext context) {
    final chipColor = isSelected
        ? AppColors.primary
        : (color ?? AppColors.textSecondary);

    final chipBackgroundColor = isSelected
        ? AppColors.primary.withOpacity(0.1)
        : (backgroundColor ?? chipColor.withOpacity(0.1));

    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: EdgeInsets.symmetric(
          horizontal: isSmall ? 8 : 12,
          vertical: isSmall ? 4 : 6,
        ),
        decoration: BoxDecoration(
          color: chipBackgroundColor,
          borderRadius: BorderRadius.circular(isSmall ? 12 : 16),
          border: showBorder ? Border.all(
            color: borderColor ?? chipColor.withOpacity(0.3),
            width: 1,
          ) : null,
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (icon != null) ...[
              Icon(
                icon,
                size: isSmall ? 14 : 16,
                color: chipColor,
              ),
              SizedBox(width: isSmall ? 4 : 6),
            ],
            Text(
              label,
              style: TextStyle(
                fontSize: isSmall ? 11 : 13,
                fontWeight: FontWeight.w500,
                color: chipColor,
              ),
            ),
            if (onDelete != null) ...[
              SizedBox(width: isSmall ? 4 : 6),
              GestureDetector(
                onTap: onDelete,
                child: Icon(
                  Icons.close,
                  size: isSmall ? 14 : 16,
                  color: chipColor,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

/// Chip para habilidades espec√≠ficas
class SkillTagChip extends StatelessWidget {
  final String skill;
  final bool isRequired;
  final bool hasSkill;
  final VoidCallback? onTap;

  const SkillTagChip({
    super.key,
    required this.skill,
    this.isRequired = false,
    this.hasSkill = false,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    Color chipColor;
    IconData? icon;

    if (isRequired && !hasSkill) {
      chipColor = AppColors.error;
      icon = Icons.warning;
    } else if (hasSkill) {
      chipColor = AppColors.success;
      icon = Icons.check_circle;
    } else {
      chipColor = AppColors.textSecondary;
    }

    return SkillChip(
      label: skill,
      icon: icon,
      color: chipColor,
      onTap: onTap,
      isSmall: true,
    );
  }
}

/// Chip para recursos
class ResourceChip extends StatelessWidget {
  final String resource;
  final bool isAvailable;
  final VoidCallback? onTap;

  const ResourceChip({
    super.key,
    required this.resource,
    this.isAvailable = false,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return SkillChip(
      label: resource,
      icon: isAvailable ? Icons.check : Icons.close,
      color: isAvailable ? AppColors.success : AppColors.error,
      onTap: onTap,
      isSmall: true,
    );
  }
}

/// Chip selecion√°vel para filtros
class FilterChip extends StatelessWidget {
  final String label;
  final bool isSelected;
  final VoidCallback onTap;
  final IconData? icon;

  const FilterChip({
    super.key,
    required this.label,
    required this.isSelected,
    required this.onTap,
    this.icon,
  });

  @override
  Widget build(BuildContext context) {
    return SkillChip(
      label: label,
      icon: icon,
      isSelected: isSelected,
      onTap: onTap,
    );
  }
}

/// Widget para exibir lista de chips
class SkillChipList extends StatelessWidget {
  final List<String> items;
  final String? title;
  final IconData? itemIcon;
  final Color? chipColor;
  final bool isSmall;
  final bool showTitle;
  final Function(String)? onItemTap;
  final Function(String)? onItemDelete;
  final int? maxItems;
  final String? moreText;

  const SkillChipList({
    super.key,
    required this.items,
    this.title,
    this.itemIcon,
    this.chipColor,
    this.isSmall = false,
    this.showTitle = true,
    this.onItemTap,
    this.onItemDelete,
    this.maxItems,
    this.moreText,
  });

  @override
  Widget build(BuildContext context) {
    if (items.isEmpty) return const SizedBox.shrink();

    final displayItems = maxItems != null && items.length > maxItems!
        ? items.take(maxItems!).toList()
        : items;

    final remainingCount = maxItems != null && items.length > maxItems!
        ? items.length - maxItems!
        : 0;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (showTitle && title != null) ...[
          Text(
            title!,
            style: const TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.w600,
              color: AppColors.textSecondary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingXs),
        ],
        Wrap(
          spacing: AppDimensions.spacingXs,
          runSpacing: AppDimensions.spacingXs,
          children: [
            ...displayItems.map((item) => SkillChip(
              label: item,
              icon: itemIcon,
              color: chipColor,
              isSmall: isSmall,
              onTap: onItemTap != null ? () => onItemTap!(item) : null,
              onDelete: onItemDelete != null ? () => onItemDelete!(item) : null,
            )),
            if (remainingCount > 0)
              SkillChip(
                label: moreText ?? '+$remainingCount',
                color: AppColors.textSecondary,
                isSmall: isSmall,
              ),
          ],
        ),
      ],
    );
  }
}

/// Widget para sele√ß√£o de habilidades
class SkillSelector extends StatefulWidget {
  final List<String> availableSkills;
  final List<String> selectedSkills;
  final Function(List<String>) onSelectionChanged;
  final String? title;
  final bool allowCustomSkills;

  const SkillSelector({
    super.key,
    required this.availableSkills,
    required this.selectedSkills,
    required this.onSelectionChanged,
    this.title,
    this.allowCustomSkills = false,
  });

  @override
  State<SkillSelector> createState() => _SkillSelectorState();
}

class _SkillSelectorState extends State<SkillSelector> {
  late List<String> _selectedSkills;
  final TextEditingController _customSkillController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _selectedSkills = List.from(widget.selectedSkills);
  }

  @override
  void dispose() {
    _customSkillController.dispose();
    super.dispose();
  }

  void _toggleSkill(String skill) {
    setState(() {
      if (_selectedSkills.contains(skill)) {
        _selectedSkills.remove(skill);
      } else {
        _selectedSkills.add(skill);
      }
    });
    widget.onSelectionChanged(_selectedSkills);
  }

  void _addCustomSkill() {
    final skill = _customSkillController.text.trim();
    if (skill.isNotEmpty && !_selectedSkills.contains(skill)) {
      setState(() {
        _selectedSkills.add(skill);
        _customSkillController.clear();
      });
      widget.onSelectionChanged(_selectedSkills);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (widget.title != null) ...[
          Text(
            widget.title!,
            style: const TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.w600,
              color: AppColors.textPrimary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingMd),
        ],

        // Habilidades dispon√≠veis
        Wrap(
          spacing: AppDimensions.spacingSm,
          runSpacing: AppDimensions.spacingSm,
          children: widget.availableSkills.map((skill) => FilterChip(
            label: skill,
            isSelected: _selectedSkills.contains(skill),
            onTap: () => _toggleSkill(skill),
          )).toList(),
        ),

        // Campo para habilidades customizadas
        if (widget.allowCustomSkills) ...[
          const SizedBox(height: AppDimensions.spacingMd),
          Row(
            children: [
              Expanded(
                child: TextField(
                  controller: _customSkillController,
                  decoration: const InputDecoration(
                    hintText: 'Adicionar habilidade personalizada',
                    border: OutlineInputBorder(),
                    isDense: true,
                  ),
                  onSubmitted: (_) => _addCustomSkill(),
                ),
              ),
              const SizedBox(width: AppDimensions.spacingSm),
              IconButton(
                onPressed: _addCustomSkill,
                icon: const Icon(Icons.add),
                color: AppColors.primary,
              ),
            ],
          ),
        ],
      ],
    );
  }
}

## lib\presentation\widgets\event\skill_chip.dart <a id="skill_chip_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';

/// Widget de chip para exibir habilidades e recursos
/// Pode ser usado tanto para sele√ß√£o quanto para exibi√ß√£o
class SkillChip extends StatelessWidget {
  final String label;
  final bool isSelected;
  final VoidCallback? onTap;
  final bool showRemove;
  final Color? backgroundColor;
  final Color? textColor;
  final Color? borderColor;

  const SkillChip({
    super.key,
    required this.label,
    this.isSelected = false,
    this.onTap,
    this.showRemove = false,
    this.backgroundColor,
    this.textColor,
    this.borderColor,
  });

  @override
  Widget build(BuildContext context) {
    final effectiveBackgroundColor = backgroundColor ??
        (isSelected
            ? AppColors.primary.withValues(alpha: 0.1)
            : AppColors.surface);

    final effectiveTextColor = textColor ??
        (isSelected
            ? AppColors.primary
            : AppColors.textSecondary);

    final effectiveBorderColor = borderColor ??
        (isSelected
            ? AppColors.primary.withValues(alpha: 0.3)
            : AppColors.border);

    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: AppDimensions.paddingMd,
          vertical: AppDimensions.paddingSm,
        ),
        decoration: BoxDecoration(
          color: effectiveBackgroundColor,
          borderRadius: BorderRadius.circular(AppDimensions.radiusLg),
          border: Border.all(color: effectiveBorderColor),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            // √çcone de sele√ß√£o
            if (isSelected && !showRemove) ...[
              Icon(
                Icons.check_circle,
                size: 16,
                color: effectiveTextColor,
              ),
              const SizedBox(width: AppDimensions.spacingXs),
            ],

            // Texto do label
            Text(
              label,
              style: TextStyle(
                fontSize: AppDimensions.fontSizeSm,
                fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                color: effectiveTextColor,
              ),
            ),

            // √çcone de remo√ß√£o
            if (showRemove) ...[
              const SizedBox(width: AppDimensions.spacingXs),
              Icon(
                Icons.close,
                size: 16,
                color: effectiveTextColor,
              ),
            ],
          ],
        ),
      ),
    );
  }
}

/// Varia√ß√£o do SkillChip para habilidades
class SkillChipVariant extends SkillChip {
  const SkillChipVariant({
    super.key,
    required super.label,
    super.isSelected = false,
    super.onTap,
    super.showRemove = false,
  }) : super(
          backgroundColor: null,
          textColor: null,
          borderColor: null,
        );
}

/// Varia√ß√£o do SkillChip para recursos
class ResourceChip extends SkillChip {
  const ResourceChip({
    super.key,
    required super.label,
    super.isSelected = false,
    super.onTap,
    super.showRemove = false,
  }) : super(
          backgroundColor: null,
          textColor: null,
          borderColor: null,
        );
}

/// Varia√ß√£o do SkillChip para prioridades
class PriorityChip extends SkillChip {
  const PriorityChip({
    super.key,
    required super.label,
    super.isSelected = false,
    super.onTap,
    super.showRemove = false,
    required PriorityLevel priority,
  }) : super(
          backgroundColor: priority == PriorityLevel.high
              ? AppColors.priorityHigh
              : priority == PriorityLevel.medium
                  ? AppColors.priorityMedium
                  : AppColors.priorityLow,
          textColor: AppColors.textOnPrimary,
          borderColor: null,
        );
}

/// Enum para n√≠veis de prioridade
enum PriorityLevel {
  high,
  medium,
  low,
}

/// Varia√ß√£o do SkillChip para status
class StatusChip extends SkillChip {
  const StatusChip({
    super.key,
    required super.label,
    super.isSelected = false,
    super.onTap,
    super.showRemove = false,
    required StatusType status,
  }) : super(
          backgroundColor: status == StatusType.pending
              ? AppColors.statusPending
              : status == StatusType.inProgress
                  ? AppColors.statusInProgress
                  : status == StatusType.completed
                      ? AppColors.statusCompleted
                      : AppColors.statusCancelled,
          textColor: AppColors.textOnPrimary,
          borderColor: null,
        );
}

/// Enum para tipos de status
enum StatusType {
  pending,
  inProgress,
  completed,
  cancelled,
}

/// Widget para exibir uma lista de chips de habilidades
class SkillChipList extends StatelessWidget {
  final List<String> skills;
  final List<String> selectedSkills;
  final Function(String) onSkillToggle;
  final bool showRemoveButton;

  const SkillChipList({
    super.key,
    required this.skills,
    required this.selectedSkills,
    required this.onSkillToggle,
    this.showRemoveButton = false,
  });

  @override
  Widget build(BuildContext context) {
    if (skills.isEmpty) {
      return const Text(
        'Nenhuma habilidade dispon√≠vel',
        style: TextStyle(
          fontSize: AppDimensions.fontSizeMd,
          color: AppColors.textSecondary,
        ),
      );
    }

    return Wrap(
      spacing: AppDimensions.spacingSm,
      runSpacing: AppDimensions.spacingSm,
      children: skills.map((skill) {
        final isSelected = selectedSkills.contains(skill);
        return SkillChip(
          label: skill,
          isSelected: isSelected,
          onTap: () => onSkillToggle(skill),
          showRemove: showRemoveButton && isSelected,
        );
      }).toList(),
    );
  }
}

/// Widget para exibir uma lista de chips de recursos
class ResourceChipList extends StatelessWidget {
  final List<String> resources;
  final List<String> selectedResources;
  final Function(String) onResourceToggle;
  final bool showRemoveButton;

  const ResourceChipList({
    super.key,
    required this.resources,
    required this.selectedResources,
    required this.onResourceToggle,
    this.showRemoveButton = false,
  });

  @override
  Widget build(BuildContext context) {
    if (resources.isEmpty) {
      return const Text(
        'Nenhum recurso dispon√≠vel',
        style: TextStyle(
          fontSize: AppDimensions.fontSizeMd,
          color: AppColors.textSecondary,
        ),
      );
    }

    return Wrap(
      spacing: AppDimensions.spacingSm,
      runSpacing: AppDimensions.spacingSm,
      children: resources.map((resource) {
        final isSelected = selectedResources.contains(resource);
        return ResourceChip(
          label: resource,
          isSelected: isSelected,
          onTap: () => onResourceToggle(resource),
          showRemove: showRemoveButton && isSelected,
        );
      }).toList(),
    );
  }
}

## lib\core\utils\string_helpers.dart <a id="string_helpers_dart"></a>

### Dependencies

- `dart:math`

import 'dart:math';

/// Classe utilit√°ria para manipula√ß√£o de strings
class StringHelpers {
  /// Capitaliza a primeira letra de uma string
  static String capitalize(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1).toLowerCase();
  }

  /// Capitaliza a primeira letra de cada palavra
  static String capitalizeWords(String text) {
    if (text.isEmpty) return text;
    return text.split(' ').map((word) => capitalize(word)).join(' ');
  }

  /// Remove espa√ßos extras e quebras de linha
  static String cleanText(String text) {
    return text.trim().replaceAll(RegExp(r'\s+'), ' ');
  }

  /// Trunca o texto se exceder o limite de caracteres
  static String truncate(String text, int maxLength, {String suffix = '...'}) {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength - suffix.length) + suffix;
  }

  /// Gera um c√≥digo alfanum√©rico aleat√≥rio
  static String generateRandomCode(int length) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    final random = Random();
    return String.fromCharCodes(
      Iterable.generate(
        length,
        (_) => chars.codeUnitAt(random.nextInt(chars.length)),
      ),
    );
  }

  /// Gera um ID √∫nico baseado em timestamp e random
  static String generateUniqueId() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final random = Random().nextInt(9999);
    return '${timestamp}_$random';
  }

  /// Valida se uma string cont√©m apenas letras e espa√ßos
  static bool isValidName(String text) {
    return RegExp(r'^[a-zA-Z√Ä-√ø\s]+$').hasMatch(text);
  }

  /// Valida se uma string √© um email v√°lido
  static bool isValidEmail(String email) {
    return RegExp(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
        .hasMatch(email);
  }

  /// Remove acentos de uma string
  static String removeAccents(String text) {
    const withAccents = '√Ä√Å√Ç√É√Ñ√Ö√†√°√¢√£√§√•√í√ì√î√ï√ñ√ò√≤√≥√¥√µ√∂√∏√à√â√ä√ã√®√©√™√´√á√ß√å√ç√é√è√¨√≠√Æ√Ø√ô√ö√õ√ú√π√∫√ª√º√ø√ë√±';
    const withoutAccents = 'AAAAAAaaaaaaOOOOOOooooooEEEEeeeeeCcIIIIiiiiUUUUuuuuyNn';

    String result = text;
    for (int i = 0; i < withAccents.length; i++) {
      result = result.replaceAll(withAccents[i], withoutAccents[i]);
    }
    return result;
  }

  /// Converte string para formato de busca (sem acentos, min√∫scula)
  static String toSearchFormat(String text) {
    return removeAccents(text.toLowerCase().trim());
  }

  /// Extrai iniciais de um nome
  static String getInitials(String name, {int maxInitials = 2}) {
    if (name.isEmpty) return '';

    final words = name.trim().split(' ');
    final initials = words
        .where((word) => word.isNotEmpty)
        .take(maxInitials)
        .map((word) => word[0].toUpperCase())
        .join();

    return initials;
  }

  /// Formata um n√∫mero de telefone
  static String formatPhoneNumber(String phone) {
    // Remove todos os caracteres n√£o num√©ricos
    final numbers = phone.replaceAll(RegExp(r'[^0-9]'), '');

    if (numbers.length == 11) {
      // Formato: (XX) XXXXX-XXXX
      return '(${numbers.substring(0, 2)}) ${numbers.substring(2, 7)}-${numbers.substring(7)}';
    } else if (numbers.length == 10) {
      // Formato: (XX) XXXX-XXXX
      return '(${numbers.substring(0, 2)}) ${numbers.substring(2, 6)}-${numbers.substring(6)}';
    }

    return phone; // Retorna original se n√£o conseguir formatar
  }

  /// Converte uma lista de strings em uma string separada por v√≠rgulas
  static String joinWithComma(List<String> items) {
    return items.join(', ');
  }

  /// Converte uma string separada por v√≠rgulas em lista
  static List<String> splitByComma(String text) {
    return text.split(',').map((item) => item.trim()).where((item) => item.isNotEmpty).toList();
  }

  /// Verifica se uma string est√° vazia ou cont√©m apenas espa√ßos
  static bool isNullOrEmpty(String? text) {
    return text == null || text.trim().isEmpty;
  }

  /// Verifica se uma string n√£o est√° vazia
  static bool isNotNullOrEmpty(String? text) {
    return !isNullOrEmpty(text);
  }

  /// Conta o n√∫mero de palavras em um texto
  static int countWords(String text) {
    if (text.trim().isEmpty) return 0;
    return text.trim().split(RegExp(r'\s+')).length;
  }

  /// Estima o tempo de leitura em minutos (baseado em 200 palavras por minuto)
  static int estimateReadingTime(String text) {
    final wordCount = countWords(text);
    return (wordCount / 200).ceil();
  }

  /// Converte uma string para slug (URL-friendly)
  static String toSlug(String text) {
    return removeAccents(text)
        .toLowerCase()
        .replaceAll(RegExp(r'[^a-z0-9\s-]'), '')
        .replaceAll(RegExp(r'\s+'), '-')
        .replaceAll(RegExp(r'-+'), '-')
        .replaceAll(RegExp(r'^-|-$'), '');
  }

  /// Mascara informa√ß√µes sens√≠veis (ex: email, telefone)
  static String maskSensitiveInfo(String text, {int visibleChars = 3}) {
    if (text.length <= visibleChars * 2) return text;

    final start = text.substring(0, visibleChars);
    final end = text.substring(text.length - visibleChars);
    final middle = '*' * (text.length - visibleChars * 2);

    return start + middle + end;
  }

  /// Converte bytes para string leg√≠vel (KB, MB, GB)
  static String formatBytes(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    if (bytes < 1024 * 1024 * 1024) return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
    return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(1)} GB';
  }

  /// Converte dura√ß√£o em segundos para string leg√≠vel
  static String formatDuration(int seconds) {
    final hours = seconds ~/ 3600;
    final minutes = (seconds % 3600) ~/ 60;
    final remainingSeconds = seconds % 60;

    if (hours > 0) {
      return '${hours}h ${minutes}m ${remainingSeconds}s';
    } else if (minutes > 0) {
      return '${minutes}m ${remainingSeconds}s';
    } else {
      return '${remainingSeconds}s';
    }
  }

  /// Pluraliza uma palavra baseada na quantidade
  static String pluralize(int count, String singular, String plural) {
    return count == 1 ? singular : plural;
  }

  /// Formata um n√∫mero com separadores de milhares
  static String formatNumber(num number) {
    return number.toString().replaceAllMapped(
      RegExp(r'(\d{1,3})(?=(\d{3})+(?!\d))'),
      (Match match) => '${match[1]}.',
    );
  }

  /// Converte uma string para camelCase
  static String toCamelCase(String text) {
    final words = text.toLowerCase().split(RegExp(r'[\s_-]+'));
    if (words.isEmpty) return '';

    return words.first + words.skip(1).map(capitalize).join();
  }

  /// Converte uma string para snake_case
  static String toSnakeCase(String text) {
    return text
        .replaceAll(RegExp(r'([A-Z])'), '_\$1')
        .toLowerCase()
        .replaceAll(RegExp(r'^_'), '')
        .replaceAll(RegExp(r'[\s-]+'), '_');
  }
}

## android\app\src\main\res\values\styles.xml <a id="styles_xml"></a>

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

## android\app\src\main\res\values-night\styles.xml <a id="styles_xml"></a>

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

## lib\data\models\task_model.dart <a id="task_model_dart"></a>

### Dependencies

- `package:cloud_firestore/cloud_firestore.dart`

import 'package:cloud_firestore/cloud_firestore.dart';

/// Enums para status e prioridade das tasks
enum TaskStatus {
  pending('pending'),
  inProgress('in_progress'),
  completed('completed'),
  cancelled('cancelled');

  const TaskStatus(this.value);
  final String value;

  static TaskStatus fromString(String value) {
    return TaskStatus.values.firstWhere(
      (status) => status.value == value,
      orElse: () => TaskStatus.pending,
    );
  }

  @override
  String toString() => value;
}

enum TaskPriority {
  low('low'),
  medium('medium'),
  high('high');

  const TaskPriority(this.value);
  final String value;

  static TaskPriority fromString(String value) {
    return TaskPriority.values.firstWhere(
      (priority) => priority.value == value,
      orElse: () => TaskPriority.medium,
    );
  }

  @override
  String toString() => value;
}

/// Modelo de dados para representar uma task (organizadora) no sistema
/// Tasks servem como agrupadores organizacionais para microtasks
/// Baseado na estrutura definida no SPEC_GERAL.md
class TaskModel {
  final String id;
  final String eventId;
  final String title;
  final String description;
  final TaskPriority priority;
  final TaskStatus status;
  final String createdBy;
  final int microtaskCount;
  final int completedMicrotasks;
  final DateTime createdAt;
  final DateTime updatedAt;

  const TaskModel({
    required this.id,
    required this.eventId,
    required this.title,
    required this.description,
    required this.priority,
    required this.status,
    required this.createdBy,
    required this.microtaskCount,
    required this.completedMicrotasks,
    required this.createdAt,
    required this.updatedAt,
  });

  /// Cria uma inst√¢ncia de TaskModel a partir de um Map (JSON)
  factory TaskModel.fromMap(Map<String, dynamic> map) {
    return TaskModel(
      id: map['id'] as String,
      eventId: map['eventId'] as String,
      title: map['title'] as String,
      description: map['description'] as String,
      priority: TaskPriority.fromString(map['priority'] as String),
      status: TaskStatus.fromString(map['status'] as String),
      createdBy: map['createdBy'] as String,
      microtaskCount: map['microtaskCount'] as int? ?? 0,
      completedMicrotasks: map['completedMicrotasks'] as int? ?? 0,
      createdAt: (map['createdAt'] as Timestamp).toDate(),
      updatedAt: (map['updatedAt'] as Timestamp).toDate(),
    );
  }

  /// Cria uma inst√¢ncia de TaskModel a partir de um DocumentSnapshot do Firestore
  factory TaskModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return TaskModel.fromMap({'id': doc.id, ...data});
  }

  /// Converte a inst√¢ncia para um Map (JSON)
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'eventId': eventId,
      'title': title,
      'description': description,
      'priority': priority.value,
      'status': status.value,
      'createdBy': createdBy,
      'microtaskCount': microtaskCount,
      'completedMicrotasks': completedMicrotasks,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
    };
  }

  /// Converte para formato do Firestore (sem o ID)
  Map<String, dynamic> toFirestore() {
    final map = toMap();
    map.remove('id');
    return map;
  }

  /// Cria uma c√≥pia da inst√¢ncia com alguns campos alterados
  TaskModel copyWith({
    String? id,
    String? eventId,
    String? title,
    String? description,
    TaskPriority? priority,
    TaskStatus? status,
    String? createdBy,
    int? microtaskCount,
    int? completedMicrotasks,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return TaskModel(
      id: id ?? this.id,
      eventId: eventId ?? this.eventId,
      title: title ?? this.title,
      description: description ?? this.description,
      priority: priority ?? this.priority,
      status: status ?? this.status,
      createdBy: createdBy ?? this.createdBy,
      microtaskCount: microtaskCount ?? this.microtaskCount,
      completedMicrotasks: completedMicrotasks ?? this.completedMicrotasks,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  /// Cria uma nova inst√¢ncia com updatedAt atualizado para agora
  TaskModel withUpdatedTimestamp() {
    return copyWith(updatedAt: DateTime.now());
  }

  /// Factory para criar uma nova task
  /// Note: ID e timestamps devem ser definidos pelo service
  factory TaskModel.create({
    required String id,
    required String eventId,
    required String title,
    required String description,
    required TaskPriority priority,
    required String createdBy,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) {
    return TaskModel(
      id: id,
      eventId: eventId,
      title: title,
      description: description,
      priority: priority,
      status: TaskStatus.pending,
      createdBy: createdBy,
      microtaskCount: 0,
      completedMicrotasks: 0,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  /// Valida se os dados da task s√£o v√°lidos
  List<String> validate() {
    final errors = <String>[];

    if (eventId.isEmpty) {
      errors.add('ID do evento √© obrigat√≥rio');
    }

    if (title.isEmpty) {
      errors.add('T√≠tulo da task √© obrigat√≥rio');
    } else if (title.length < 3) {
      errors.add('T√≠tulo deve ter pelo menos 3 caracteres');
    } else if (title.length > 100) {
      errors.add('T√≠tulo deve ter no m√°ximo 100 caracteres');
    }

    if (description.isEmpty) {
      errors.add('Descri√ß√£o da task √© obrigat√≥ria');
    } else if (description.length > 500) {
      errors.add('Descri√ß√£o deve ter no m√°ximo 500 caracteres');
    }

    if (createdBy.isEmpty) {
      errors.add('Criador da task √© obrigat√≥rio');
    }

    if (microtaskCount < 0) {
      errors.add('N√∫mero de microtasks n√£o pode ser negativo');
    }

    if (completedMicrotasks < 0) {
      errors.add('N√∫mero de microtasks conclu√≠das n√£o pode ser negativo');
    }

    if (completedMicrotasks > microtaskCount) {
      errors.add(
        'N√∫mero de microtasks conclu√≠das n√£o pode ser maior que o total',
      );
    }

    return errors;
  }

  /// Verifica se a task √© v√°lida
  bool isValid() => validate().isEmpty;

  /// Calcula o progresso da task (0.0 a 1.0)
  double get progress {
    if (microtaskCount == 0) return 0.0;
    return completedMicrotasks / microtaskCount;
  }

  /// Verifica se a task est√° conclu√≠da
  bool get isCompleted => status == TaskStatus.completed;

  /// Verifica se a task est√° em progresso
  bool get isInProgress => status == TaskStatus.inProgress;

  /// Verifica se a task est√° pendente
  bool get isPending => status == TaskStatus.pending;

  /// Verifica se a task foi cancelada
  bool get isCancelled => status == TaskStatus.cancelled;

  /// Atualiza o status baseado no progresso das microtasks
  TaskModel updateStatusFromMicrotasks() {
    TaskStatus newStatus;

    if (completedMicrotasks == 0) {
      newStatus = TaskStatus.pending;
    } else if (completedMicrotasks == microtaskCount) {
      newStatus = TaskStatus.completed;
    } else {
      newStatus = TaskStatus.inProgress;
    }

    return copyWith(status: newStatus, updatedAt: DateTime.now());
  }

  /// Incrementa o contador de microtasks
  TaskModel incrementMicrotaskCount() {
    return copyWith(
      microtaskCount: microtaskCount + 1,
      updatedAt: DateTime.now(),
    );
  }

  /// Decrementa o contador de microtasks
  TaskModel decrementMicrotaskCount() {
    final newCount = microtaskCount > 0 ? microtaskCount - 1 : 0;
    final newCompleted = completedMicrotasks > newCount
        ? newCount
        : completedMicrotasks;

    return copyWith(
      microtaskCount: newCount,
      completedMicrotasks: newCompleted,
      updatedAt: DateTime.now(),
    );
  }

  /// Incrementa o contador de microtasks conclu√≠das
  TaskModel incrementCompletedMicrotasks() {
    final newCompleted = completedMicrotasks < microtaskCount
        ? completedMicrotasks + 1
        : completedMicrotasks;

    return copyWith(
      completedMicrotasks: newCompleted,
      updatedAt: DateTime.now(),
    );
  }

  /// Decrementa o contador de microtasks conclu√≠das
  TaskModel decrementCompletedMicrotasks() {
    final newCompleted = completedMicrotasks > 0 ? completedMicrotasks - 1 : 0;

    return copyWith(
      completedMicrotasks: newCompleted,
      updatedAt: DateTime.now(),
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is TaskModel &&
        other.id == id &&
        other.eventId == eventId &&
        other.title == title &&
        other.description == description &&
        other.priority == priority &&
        other.status == status &&
        other.createdBy == createdBy &&
        other.microtaskCount == microtaskCount &&
        other.completedMicrotasks == completedMicrotasks;
  }

  @override
  int get hashCode {
    return Object.hash(
      id,
      eventId,
      title,
      description,
      priority,
      status,
      createdBy,
      microtaskCount,
      completedMicrotasks,
    );
  }

  @override
  String toString() {
    return 'TaskModel(id: $id, title: $title, status: $status, progress: ${(progress * 100).toStringAsFixed(1)}%)';
  }
}

## lib\presentation\controllers\task_controller.dart <a id="task_controller_dart"></a>

### Dependencies

- `package:flutter/foundation.dart`
- `../../data/models/task_model.dart`
- `../../data/models/microtask_model.dart`
- `../../data/models/user_microtask_model.dart`
- `../../data/models/volunteer_profile_model.dart`
- `../../data/repositories/task_repository.dart`
- `../../data/repositories/microtask_repository.dart`
- `../../core/exceptions/app_exceptions.dart`

import 'package:flutter/foundation.dart';
import '../../data/models/task_model.dart';
import '../../data/models/microtask_model.dart';
import '../../data/models/user_microtask_model.dart';
import '../../data/models/volunteer_profile_model.dart';
import '../../data/repositories/task_repository.dart';
import '../../data/repositories/microtask_repository.dart';
import '../../core/exceptions/app_exceptions.dart';

/// Estados poss√≠veis do controller de tasks
enum TaskControllerState { initial, loading, loaded, error }

/// Controller respons√°vel por gerenciar o estado das tasks e microtasks
class TaskController extends ChangeNotifier {
  final TaskRepository _taskRepository;
  final MicrotaskRepository _microtaskRepository;

  TaskController({
    TaskRepository? taskRepository,
    MicrotaskRepository? microtaskRepository,
  }) : _taskRepository = taskRepository ?? TaskRepository(),
       _microtaskRepository = microtaskRepository ?? MicrotaskRepository();

  // Estado atual
  TaskControllerState _state = TaskControllerState.initial;
  String? _errorMessage;
  bool _isLoading = false;

  // Dados das tasks
  List<TaskModel> _tasks = [];
  final Map<String, List<MicrotaskModel>> _microtasksByTask = {};
  final Map<String, List<UserMicrotaskModel>> _userMicrotasksByMicrotask = {};

  // Filtros
  TaskStatus? _statusFilter;
  TaskPriority? _priorityFilter;
  String? _creatorFilter;
  MicrotaskStatus? _microtaskStatusFilter;

  // Getters
  TaskControllerState get state => _state;
  String? get errorMessage => _errorMessage;
  bool get isLoading => _isLoading;
  List<TaskModel> get tasks => List.unmodifiable(_tasks);
  Map<String, List<MicrotaskModel>> get microtasksByTask =>
      Map.unmodifiable(_microtasksByTask);
  Map<String, List<UserMicrotaskModel>> get userMicrotasksByMicrotask =>
      Map.unmodifiable(_userMicrotasksByMicrotask);

  // Getters de filtros
  TaskStatus? get statusFilter => _statusFilter;
  TaskPriority? get priorityFilter => _priorityFilter;
  String? get creatorFilter => _creatorFilter;
  MicrotaskStatus? get microtaskStatusFilter => _microtaskStatusFilter;

  /// Carrega todas as tasks de um evento
  Future<void> loadTasksByEventId(String eventId) async {
    try {
      _setLoading(true);
      _clearError();

      final tasks = await _taskRepository.getTasksByEventId(eventId);
      _tasks = tasks;

      // Carrega microtasks para cada task
      await _loadMicrotasksForTasks();

      _setState(TaskControllerState.loaded);
    } on AppException catch (e) {
      _setError(e.message);
    } catch (e) {
      _setError('Erro inesperado ao carregar tasks');
    } finally {
      _setLoading(false);
    }
  }

  /// Carrega tasks com filtros
  Future<void> loadTasksWithFilters({
    required String eventId,
    TaskStatus? status,
    TaskPriority? priority,
    String? createdBy,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      _statusFilter = status;
      _priorityFilter = priority;
      _creatorFilter = createdBy;

      final tasks = await _taskRepository.getTasksWithFilters(
        eventId: eventId,
        status: status,
        priority: priority,
        createdBy: createdBy,
      );
      _tasks = tasks;

      // Carrega microtasks para cada task
      await _loadMicrotasksForTasks();

      _setState(TaskControllerState.loaded);
    } on AppException catch (e) {
      _setError(e.message);
    } catch (e) {
      _setError('Erro inesperado ao carregar tasks com filtros');
    } finally {
      _setLoading(false);
    }
  }

  /// Cria uma nova task
  Future<bool> createTask({
    required String eventId,
    required String title,
    required String description,
    required TaskPriority priority,
    required String createdBy,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      final task = await _taskRepository.createTask(
        eventId: eventId,
        title: title,
        description: description,
        priority: priority,
        createdBy: createdBy,
      );

      // Adiciona √† lista local
      _tasks.add(task);
      _microtasksByTask[task.id] = [];

      _setState(TaskControllerState.loaded);
      return true;
    } on AppException catch (e) {
      _setError(e.message);
      return false;
    } catch (e) {
      _setError('Erro inesperado ao criar task');
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Cria uma nova microtask
  Future<bool> createMicrotask({
    required String taskId,
    required String eventId,
    required String title,
    required String description,
    required List<String> requiredSkills,
    required List<String> requiredResources,
    DateTime? startDateTime,
    DateTime? endDateTime,
    required String priority,
    required int maxVolunteers,
    required String createdBy,
    String? notes,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      final microtask = await _microtaskRepository.createMicrotask(
        taskId: taskId,
        eventId: eventId,
        title: title,
        description: description,
        requiredSkills: requiredSkills,
        requiredResources: requiredResources,
        startDateTime: startDateTime,
        endDateTime: endDateTime,
        priority: priority,
        maxVolunteers: maxVolunteers,
        createdBy: createdBy,
        notes: notes,
      );

      // Adiciona √† lista local
      if (_microtasksByTask.containsKey(taskId)) {
        _microtasksByTask[taskId]!.add(microtask);
      } else {
        _microtasksByTask[taskId] = [microtask];
      }

      // Atualiza contador da task pai
      await _taskRepository.incrementMicrotaskCount(taskId);
      await _refreshTask(taskId);

      _setState(TaskControllerState.loaded);
      return true;
    } on AppException catch (e) {
      _setError(e.message);
      return false;
    } catch (e) {
      _setError('Erro inesperado ao criar microtask');
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Atribui um volunt√°rio a uma microtask
  Future<bool> assignVolunteerToMicrotask({
    required String microtaskId,
    required String userId,
    required String eventId,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      print("ABACAXIA1: assinando microtask");
      final updatedMicrotask = await _microtaskRepository.assignVolunteer(
        microtaskId: microtaskId,
        userId: userId,
        eventId: eventId,
      );

      // Atualiza na lista local
      _updateMicrotaskInList(updatedMicrotask);

      // Carrega rela√ß√µes usu√°rio-microtask
      await _loadUserMicrotasksForMicrotask(microtaskId);

      _setState(TaskControllerState.loaded);
      return true;
    } on AppException catch (e) {
      _setError(e.message);
      return false;
    } catch (e) {
      _setError('Erro inesperado ao atribuir volunt√°rio');
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Remove um volunt√°rio de uma microtask
  Future<bool> unassignVolunteerFromMicrotask({
    required String microtaskId,
    required String userId,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      final updatedMicrotask = await _microtaskRepository.unassignVolunteer(
        microtaskId: microtaskId,
        userId: userId,
      );

      // Atualiza na lista local
      _updateMicrotaskInList(updatedMicrotask);

      // Carrega rela√ß√µes usu√°rio-microtask
      await _loadUserMicrotasksForMicrotask(microtaskId);

      _setState(TaskControllerState.loaded);
      return true;
    } on AppException catch (e) {
      _setError(e.message);
      return false;
    } catch (e) {
      _setError('Erro inesperado ao remover volunt√°rio');
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Busca volunt√°rios compat√≠veis com uma microtask
  Future<List<VolunteerProfileModel>> getCompatibleVolunteers({
    required String eventId,
    required String microtaskId,
  }) async {
    try {
      return await _microtaskRepository.getCompatibleVolunteers(
        eventId: eventId,
        microtaskId: microtaskId,
      );
    } on AppException catch (e) {
      _setError(e.message);
      return [];
    } catch (e) {
      _setError('Erro inesperado ao buscar volunt√°rios compat√≠veis');
      return [];
    }
  }

  /// Atualiza o status individual de um usu√°rio em uma microtask
  Future<bool> updateUserMicrotaskStatus({
    required String userId,
    required String microtaskId,
    required UserMicrotaskStatus status,
    double? actualHours,
    String? notes,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      final updatedUserMicrotask = await _microtaskRepository
          .updateUserMicrotaskStatus(
            userId: userId,
            microtaskId: microtaskId,
            status: status,
            actualHours: actualHours,
            notes: notes,
          );

      // Atualiza na lista local
      if (_userMicrotasksByMicrotask.containsKey(microtaskId)) {
        final index = _userMicrotasksByMicrotask[microtaskId]!.indexWhere(
          (um) => um.userId == userId,
        );
        if (index != -1) {
          _userMicrotasksByMicrotask[microtaskId]![index] =
              updatedUserMicrotask;
        }
      }

      // Recarrega a microtask para pegar status atualizado
      final microtask = await _microtaskRepository.getMicrotaskById(
        microtaskId,
      );
      if (microtask != null) {
        _updateMicrotaskInList(microtask);
      }

      _setState(TaskControllerState.loaded);
      return true;
    } on AppException catch (e) {
      _setError(e.message);
      return false;
    } catch (e) {
      _setError('Erro inesperado ao atualizar status do usu√°rio');
      return false;
    } finally {
      _setLoading(false);
    }
  }

  /// Busca microtasks de uma task espec√≠fica
  List<MicrotaskModel> getMicrotasksByTaskId(String taskId) {
    return _microtasksByTask[taskId] ?? [];
  }

  /// Busca rela√ß√µes usu√°rio-microtask de uma microtask espec√≠fica
  List<UserMicrotaskModel> getUserMicrotasksByMicrotaskId(String microtaskId) {
    return _userMicrotasksByMicrotask[microtaskId] ?? [];
  }

  /// Limpa os filtros
  void clearFilters() {
    _statusFilter = null;
    _priorityFilter = null;
    _creatorFilter = null;
    _microtaskStatusFilter = null;
    notifyListeners();
  }

  /// Aplica filtro de status de microtask
  void setMicrotaskStatusFilter(MicrotaskStatus? status) {
    _microtaskStatusFilter = status;
    notifyListeners();
  }

  /// Busca estat√≠sticas das tasks
  Future<Map<String, dynamic>> getTaskStatistics(String eventId) async {
    try {
      return await _taskRepository.getTaskStatistics(eventId);
    } on AppException catch (e) {
      _setError(e.message);
      return {};
    } catch (e) {
      _setError('Erro inesperado ao calcular estat√≠sticas');
      return {};
    }
  }

  /// Carrega microtasks para todas as tasks
  Future<void> _loadMicrotasksForTasks() async {
    _microtasksByTask.clear();

    for (final task in _tasks) {
      final microtasks = await _microtaskRepository.getMicrotasksByTaskId(
        task.id,
      );
      _microtasksByTask[task.id] = microtasks;

      // Carrega rela√ß√µes usu√°rio-microtask para cada microtask
      for (final microtask in microtasks) {
        await _loadUserMicrotasksForMicrotask(microtask.id);
      }
    }
  }

  /// Carrega rela√ß√µes usu√°rio-microtask para uma microtask espec√≠fica
  Future<void> _loadUserMicrotasksForMicrotask(String microtaskId) async {
    final userMicrotasks = await _microtaskRepository
        .getUserMicrotasksByMicrotaskId(microtaskId);
    _userMicrotasksByMicrotask[microtaskId] = userMicrotasks;
  }

  /// Atualiza uma microtask na lista local
  void _updateMicrotaskInList(MicrotaskModel updatedMicrotask) {
    for (final taskId in _microtasksByTask.keys) {
      final microtasks = _microtasksByTask[taskId]!;
      final index = microtasks.indexWhere((m) => m.id == updatedMicrotask.id);
      if (index != -1) {
        microtasks[index] = updatedMicrotask;
        break;
      }
    }
  }

  /// Recarrega uma task espec√≠fica
  Future<void> _refreshTask(String taskId) async {
    final task = await _taskRepository.getTaskById(taskId);
    if (task != null) {
      final index = _tasks.indexWhere((t) => t.id == taskId);
      if (index != -1) {
        _tasks[index] = task;
      }
    }
  }

  /// Define o estado de loading
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }

  /// Define o estado
  void _setState(TaskControllerState state) {
    _state = state;
    notifyListeners();
  }

  /// Define uma mensagem de erro
  void _setError(String message) {
    _errorMessage = message;
    _setState(TaskControllerState.error);
  }

  /// Limpa a mensagem de erro
  void _clearError() {
    _errorMessage = null;
  }

  /// Limpa todos os dados
  void clear() {
    _tasks.clear();
    _microtasksByTask.clear();
    _userMicrotasksByMicrotask.clear();
    clearFilters();
    _setState(TaskControllerState.initial);
  }
}

## lib\presentation\widgets\task\task_progress_widget.dart <a id="task_progress_widget_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/task_model.dart`
- `../../../data/models/microtask_model.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/task_model.dart';
import '../../../data/models/microtask_model.dart';

/// Widget para exibir o progresso de uma task ou microtask
class TaskProgressWidget extends StatelessWidget {
  final TaskModel? task;
  final MicrotaskModel? microtask;
  final bool showDetails;
  final bool showPercentage;
  final double? customProgress;
  final String? customLabel;

  const TaskProgressWidget({
    super.key,
    this.task,
    this.microtask,
    this.showDetails = true,
    this.showPercentage = true,
    this.customProgress,
    this.customLabel,
  }) : assert(task != null || microtask != null || customProgress != null);

  @override
  Widget build(BuildContext context) {
    final progress = _calculateProgress();
    final color = _getProgressColor(progress);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Header com t√≠tulo e porcentagem
        if (showDetails)
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                customLabel ?? _getProgressLabel(),
                style: const TextStyle(
                  fontSize: 12,
                  fontWeight: FontWeight.w500,
                  color: AppColors.textSecondary,
                ),
              ),
              if (showPercentage)
                Text(
                  '${(progress * 100).toInt()}%',
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                    color: color,
                  ),
                ),
            ],
          ),

        if (showDetails) const SizedBox(height: 4),

        // Barra de progresso
        LinearProgressIndicator(
          value: progress,
          backgroundColor: AppColors.border,
          valueColor: AlwaysStoppedAnimation<Color>(color),
          minHeight: 6,
        ),

        // Detalhes adicionais
        if (showDetails && (task != null || microtask != null)) ...[
          const SizedBox(height: 4),
          _buildProgressDetails(),
        ],
      ],
    );
  }

  Widget _buildProgressDetails() {
    if (task != null) {
      return _buildTaskDetails();
    } else if (microtask != null) {
      return _buildMicrotaskDetails();
    }
    return const SizedBox.shrink();
  }

  Widget _buildTaskDetails() {
    if (task == null) return const SizedBox.shrink();

    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          '${task!.completedMicrotasks} de ${task!.microtaskCount} microtasks',
          style: const TextStyle(fontSize: 10, color: AppColors.textSecondary),
        ),
        _buildStatusChip(task!.status.toString().split('.').last),
      ],
    );
  }

  Widget _buildMicrotaskDetails() {
    if (microtask == null) return const SizedBox.shrink();

    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          microtask!.hasSchedule
              ? 'Dura√ß√£o: ${microtask!.estimatedHours.toStringAsFixed(1)}h'
              : 'Hor√°rio n√£o definido',
          style: const TextStyle(fontSize: 10, color: AppColors.textSecondary),
        ),
        _buildStatusChip(microtask!.status.toString().split('.').last),
      ],
    );
  }

  Widget _buildStatusChip(String status) {
    Color color;
    String text;

    switch (status.toLowerCase()) {
      case 'pending':
        color = AppColors.warning;
        text = 'Pendente';
        break;
      case 'assigned':
        color = AppColors.primary;
        text = 'Atribu√≠da';
        break;
      case 'inprogress':
        color = AppColors.secondary;
        text = 'Em Progresso';
        break;
      case 'completed':
        color = AppColors.success;
        text = 'Conclu√≠da';
        break;
      case 'cancelled':
        color = AppColors.error;
        text = 'Cancelada';
        break;
      default:
        color = AppColors.textSecondary;
        text = status;
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontSize: 9,
          fontWeight: FontWeight.w600,
          color: color,
        ),
      ),
    );
  }

  double _calculateProgress() {
    if (customProgress != null) {
      return customProgress!.clamp(0.0, 1.0);
    }

    if (task != null) {
      if (task!.microtaskCount == 0) return 0.0;
      return (task!.completedMicrotasks / task!.microtaskCount).clamp(0.0, 1.0);
    }

    if (microtask != null) {
      switch (microtask!.status) {
        case MicrotaskStatus.pending:
          return 0.0;
        case MicrotaskStatus.assigned:
          return 0.1;
        case MicrotaskStatus.inProgress:
          return 0.5;
        case MicrotaskStatus.completed:
          return 1.0;
        case MicrotaskStatus.cancelled:
          return 0.0;
      }
    }

    return 0.0;
  }

  Color _getProgressColor(double progress) {
    if (progress == 0.0) {
      return AppColors.warning;
    } else if (progress == 1.0) {
      return AppColors.success;
    } else {
      return AppColors.primary;
    }
  }

  String _getProgressLabel() {
    if (task != null) {
      return 'Progresso da Task';
    } else if (microtask != null) {
      return 'Progresso da Microtask';
    } else {
      return 'Progresso';
    }
  }
}

/// Widget para exibir progresso circular
class CircularTaskProgressWidget extends StatelessWidget {
  final double progress;
  final double size;
  final Color? color;
  final String? centerText;
  final bool showPercentage;

  const CircularTaskProgressWidget({
    super.key,
    required this.progress,
    this.size = 60,
    this.color,
    this.centerText,
    this.showPercentage = true,
  });

  @override
  Widget build(BuildContext context) {
    final progressColor = color ?? _getProgressColor(progress);

    return SizedBox(
      width: size,
      height: size,
      child: Stack(
        alignment: Alignment.center,
        children: [
          // C√≠rculo de progresso
          CircularProgressIndicator(
            value: progress,
            strokeWidth: 4,
            backgroundColor: AppColors.border,
            valueColor: AlwaysStoppedAnimation<Color>(progressColor),
          ),

          // Texto central
          if (showPercentage || centerText != null)
            Text(
              centerText ?? '${(progress * 100).toInt()}%',
              style: TextStyle(
                fontSize: size * 0.2,
                fontWeight: FontWeight.bold,
                color: progressColor,
              ),
            ),
        ],
      ),
    );
  }

  Color _getProgressColor(double progress) {
    if (progress == 0.0) {
      return AppColors.warning;
    } else if (progress == 1.0) {
      return AppColors.success;
    } else {
      return AppColors.primary;
    }
  }
}

/// Widget para exibir m√∫ltiplos progressos (ex: por volunt√°rio)
class MultiProgressWidget extends StatelessWidget {
  final List<ProgressItem> items;
  final String title;

  const MultiProgressWidget({
    super.key,
    required this.items,
    required this.title,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingSm),

        ...items.map(
          (item) => Padding(
            padding: const EdgeInsets.only(bottom: AppDimensions.spacingSm),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      item.label,
                      style: const TextStyle(
                        fontSize: 12,
                        color: AppColors.textSecondary,
                      ),
                    ),
                    Text(
                      '${(item.progress * 100).toInt()}%',
                      style: TextStyle(
                        fontSize: 12,
                        fontWeight: FontWeight.w600,
                        color: item.color ?? _getProgressColor(item.progress),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 2),
                LinearProgressIndicator(
                  value: item.progress,
                  backgroundColor: AppColors.border,
                  valueColor: AlwaysStoppedAnimation<Color>(
                    item.color ?? _getProgressColor(item.progress),
                  ),
                  minHeight: 4,
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Color _getProgressColor(double progress) {
    if (progress == 0.0) {
      return AppColors.warning;
    } else if (progress == 1.0) {
      return AppColors.success;
    } else {
      return AppColors.primary;
    }
  }
}

/// Classe para representar um item de progresso
class ProgressItem {
  final String label;
  final double progress;
  final Color? color;

  const ProgressItem({required this.label, required this.progress, this.color});
}

## lib\data\repositories\task_repository.dart <a id="task_repository_dart"></a>

### Dependencies

- `../models/task_model.dart`
- `../services/task_service.dart`
- `../../core/exceptions/app_exceptions.dart`

import '../models/task_model.dart';
import '../services/task_service.dart';
import '../../core/exceptions/app_exceptions.dart';

/// Reposit√≥rio respons√°vel por gerenciar dados de tasks
/// Atua como uma camada de abstra√ß√£o entre os controllers e os services
class TaskRepository {
  final TaskService _taskService;

  TaskRepository({TaskService? taskService})
    : _taskService = taskService ?? TaskService();

  /// Cria uma nova task
  Future<TaskModel> createTask({
    required String eventId,
    required String title,
    required String description,
    required TaskPriority priority,
    required String createdBy,
  }) async {
    try {
      // Create a temporary task for validation
      final tempTask = TaskModel.create(
        id: 'temp', // Temporary ID for validation
        eventId: eventId,
        title: title.trim(),
        description: description.trim(),
        priority: priority,
        createdBy: createdBy,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      // Validate before calling service
      final validationErrors = tempTask.validate();
      if (validationErrors.isNotEmpty) {
        throw ValidationException(
          'Dados inv√°lidos: ${validationErrors.join(', ')}',
        );
      }

      // Repository delegates to service for creation with ID/timestamp generation
      return await _taskService.createTask(
        eventId: eventId,
        title: title.trim(),
        description: description.trim(),
        priority: priority,
        createdBy: createdBy,
      );
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao criar task: ${e.toString()}');
    }
  }

  /// Busca uma task por ID
  Future<TaskModel?> getTaskById(String taskId) async {
    try {
      if (taskId.isEmpty) {
        throw ValidationException('ID da task √© obrigat√≥rio');
      }

      return await _taskService.getTaskById(taskId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao buscar task: ${e.toString()}');
    }
  }

  /// Busca todas as tasks de um evento
  Future<List<TaskModel>> getTasksByEventId(String eventId) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      return await _taskService.getTasksByEventId(eventId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar tasks do evento: ${e.toString()}',
      );
    }
  }

  /// Busca tasks criadas por um usu√°rio espec√≠fico
  Future<List<TaskModel>> getTasksByCreator(String userId) async {
    try {
      if (userId.isEmpty) {
        throw ValidationException('ID do usu√°rio √© obrigat√≥rio');
      }

      return await _taskService.getTasksByCreator(userId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar tasks do usu√°rio: ${e.toString()}',
      );
    }
  }

  /// Busca tasks por status
  Future<List<TaskModel>> getTasksByStatus(
    String eventId,
    TaskStatus status,
  ) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      return await _taskService.getTasksByStatus(eventId, status);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar tasks por status: ${e.toString()}',
      );
    }
  }

  /// Busca tasks por prioridade
  Future<List<TaskModel>> getTasksByPriority(
    String eventId,
    TaskPriority priority,
  ) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      return await _taskService.getTasksByPriority(eventId, priority);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar tasks por prioridade: ${e.toString()}',
      );
    }
  }

  /// Atualiza uma task
  Future<TaskModel> updateTask(TaskModel task) async {
    try {
      if (task.id.isEmpty) {
        throw ValidationException('ID da task √© obrigat√≥rio para atualiza√ß√£o');
      }

      return await _taskService.updateTask(task);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao atualizar task: ${e.toString()}');
    }
  }

  /// Atualiza o status de uma task
  Future<TaskModel> updateTaskStatus(String taskId, TaskStatus status) async {
    try {
      if (taskId.isEmpty) {
        throw ValidationException('ID da task √© obrigat√≥rio');
      }

      return await _taskService.updateTaskStatus(taskId, status);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao atualizar status da task: ${e.toString()}',
      );
    }
  }

  /// Atualiza os contadores de microtasks
  Future<TaskModel> updateMicrotaskCounters({
    required String taskId,
    required int microtaskCount,
    required int completedMicrotasks,
  }) async {
    try {
      if (taskId.isEmpty) {
        throw ValidationException('ID da task √© obrigat√≥rio');
      }

      if (microtaskCount < 0) {
        throw ValidationException('N√∫mero de microtasks n√£o pode ser negativo');
      }

      if (completedMicrotasks < 0) {
        throw ValidationException(
          'N√∫mero de microtasks conclu√≠das n√£o pode ser negativo',
        );
      }

      if (completedMicrotasks > microtaskCount) {
        throw ValidationException(
          'N√∫mero de microtasks conclu√≠das n√£o pode ser maior que o total',
        );
      }

      return await _taskService.updateMicrotaskCounters(
        taskId: taskId,
        microtaskCount: microtaskCount,
        completedMicrotasks: completedMicrotasks,
      );
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao atualizar contadores da task: ${e.toString()}',
      );
    }
  }

  /// Incrementa o contador de microtasks
  Future<TaskModel> incrementMicrotaskCount(String taskId) async {
    try {
      if (taskId.isEmpty) {
        throw ValidationException('ID da task √© obrigat√≥rio');
      }

      return await _taskService.incrementMicrotaskCount(taskId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao incrementar contador de microtasks: ${e.toString()}',
      );
    }
  }

  /// Decrementa o contador de microtasks
  Future<TaskModel> decrementMicrotaskCount(String taskId) async {
    try {
      if (taskId.isEmpty) {
        throw ValidationException('ID da task √© obrigat√≥rio');
      }

      return await _taskService.decrementMicrotaskCount(taskId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao decrementar contador de microtasks: ${e.toString()}',
      );
    }
  }

  /// Incrementa o contador de microtasks conclu√≠das
  Future<TaskModel> incrementCompletedMicrotasks(String taskId) async {
    try {
      if (taskId.isEmpty) {
        throw ValidationException('ID da task √© obrigat√≥rio');
      }

      return await _taskService.incrementCompletedMicrotasks(taskId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao incrementar microtasks conclu√≠das: ${e.toString()}',
      );
    }
  }

  /// Decrementa o contador de microtasks conclu√≠das
  Future<TaskModel> decrementCompletedMicrotasks(String taskId) async {
    try {
      if (taskId.isEmpty) {
        throw ValidationException('ID da task √© obrigat√≥rio');
      }

      return await _taskService.decrementCompletedMicrotasks(taskId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao decrementar microtasks conclu√≠das: ${e.toString()}',
      );
    }
  }

  /// Deleta uma task
  Future<void> deleteTask(String taskId) async {
    try {
      if (taskId.isEmpty) {
        throw ValidationException('ID da task √© obrigat√≥rio');
      }

      await _taskService.deleteTask(taskId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao deletar task: ${e.toString()}');
    }
  }

  /// Deleta todas as tasks de um evento
  Future<void> deleteTasksByEventId(String eventId) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      await _taskService.deleteTasksByEventId(eventId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao deletar tasks do evento: ${e.toString()}',
      );
    }
  }

  /// Stream para escutar mudan√ßas em uma task
  Stream<TaskModel?> watchTask(String taskId) {
    if (taskId.isEmpty) {
      throw ValidationException('ID da task √© obrigat√≥rio');
    }

    return _taskService.watchTask(taskId);
  }

  /// Stream para escutar mudan√ßas nas tasks de um evento
  Stream<List<TaskModel>> watchTasksByEventId(String eventId) {
    if (eventId.isEmpty) {
      throw ValidationException('ID do evento √© obrigat√≥rio');
    }

    return _taskService.watchTasksByEventId(eventId);
  }

  /// Busca tasks com filtros m√∫ltiplos
  Future<List<TaskModel>> getTasksWithFilters({
    required String eventId,
    TaskStatus? status,
    TaskPriority? priority,
    String? createdBy,
  }) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      return await _taskService.getTasksWithFilters(
        eventId: eventId,
        status: status,
        priority: priority,
        createdBy: createdBy,
      );
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao buscar tasks com filtros: ${e.toString()}',
      );
    }
  }

  /// Valida se os dados de uma task s√£o v√°lidos
  bool validateTaskData({
    required String title,
    required String description,
    required String eventId,
    required String createdBy,
  }) {
    if (title.trim().isEmpty) return false;
    if (title.trim().length < 3) return false;
    if (title.trim().length > 100) return false;
    if (description.trim().isEmpty) return false;
    if (description.trim().length > 500) return false;
    if (eventId.isEmpty) return false;
    if (createdBy.isEmpty) return false;

    return true;
  }

  /// Calcula estat√≠sticas das tasks de um evento
  Future<Map<String, dynamic>> getTaskStatistics(String eventId) async {
    try {
      if (eventId.isEmpty) {
        throw ValidationException('ID do evento √© obrigat√≥rio');
      }

      final tasks = await getTasksByEventId(eventId);

      final stats = <String, dynamic>{
        'total': tasks.length,
        'pending': tasks.where((t) => t.isPending).length,
        'inProgress': tasks.where((t) => t.isInProgress).length,
        'completed': tasks.where((t) => t.isCompleted).length,
        'cancelled': tasks.where((t) => t.isCancelled).length,
        'highPriority': tasks
            .where((t) => t.priority == TaskPriority.high)
            .length,
        'mediumPriority': tasks
            .where((t) => t.priority == TaskPriority.medium)
            .length,
        'lowPriority': tasks
            .where((t) => t.priority == TaskPriority.low)
            .length,
        'totalMicrotasks': tasks.fold<int>(
          0,
          (sum, task) => sum + task.microtaskCount,
        ),
        'completedMicrotasks': tasks.fold<int>(
          0,
          (sum, task) => sum + task.completedMicrotasks,
        ),
      };

      // Calcula progresso geral
      final totalMicrotasks = stats['totalMicrotasks'] as int;
      final completedMicrotasks = stats['completedMicrotasks'] as int;
      stats['overallProgress'] = totalMicrotasks > 0
          ? (completedMicrotasks / totalMicrotasks).toDouble()
          : 0.0;

      return stats;
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException(
        'Erro ao calcular estat√≠sticas das tasks: ${e.toString()}',
      );
    }
  }
}

## lib\presentation\widgets\task\task_card.dart <a id="task_card_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/task_model.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/task_model.dart';

/// Widget card para exibir informa√ß√µes de uma task
class TaskCard extends StatelessWidget {
  final TaskModel task;
  final VoidCallback? onTap;
  final VoidCallback? onExpand;
  final bool isExpanded;
  final Widget? expandedContent;
  final bool showProgress;

  const TaskCard({
    super.key,
    required this.task,
    this.onTap,
    this.onExpand,
    this.isExpanded = false,
    this.expandedContent,
    this.showProgress = true,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 2,
      margin: const EdgeInsets.symmetric(
        horizontal: AppDimensions.paddingMd,
        vertical: AppDimensions.paddingSm,
      ),
      child: Column(
        children: [
          InkWell(
            onTap: onTap,
            borderRadius: BorderRadius.circular(8),
            child: Padding(
              padding: const EdgeInsets.all(AppDimensions.paddingMd),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Header com t√≠tulo e a√ß√µes
                  Row(
                    children: [
                      // √çcone de status
                      Container(
                        width: 12,
                        height: 12,
                        decoration: BoxDecoration(
                          color: _getStatusColor(),
                          shape: BoxShape.circle,
                        ),
                      ),
                      const SizedBox(width: AppDimensions.spacingSm),

                      // T√≠tulo
                      Expanded(
                        child: Text(
                          task.title,
                          style: const TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                            color: AppColors.textPrimary,
                          ),
                        ),
                      ),

                      // Badge de prioridade
                      _buildPriorityBadge(),

                      // Bot√£o de expandir (se dispon√≠vel)
                      if (onExpand != null) ...[
                        const SizedBox(width: AppDimensions.spacingSm),
                        IconButton(
                          onPressed: onExpand,
                          icon: Icon(
                            isExpanded ? Icons.expand_less : Icons.expand_more,
                            color: AppColors.textSecondary,
                          ),
                          constraints: const BoxConstraints(
                            minWidth: 32,
                            minHeight: 32,
                          ),
                          padding: EdgeInsets.zero,
                        ),
                      ],
                    ],
                  ),

                  const SizedBox(height: AppDimensions.spacingSm),

                  // Descri√ß√£o
                  if (task.description.isNotEmpty)
                    Text(
                      task.description,
                      style: const TextStyle(
                        fontSize: 14,
                        color: AppColors.textSecondary,
                        height: 1.4,
                      ),
                      maxLines: isExpanded ? null : 2,
                      overflow: isExpanded ? null : TextOverflow.ellipsis,
                    ),

                  const SizedBox(height: AppDimensions.spacingMd),

                  // Informa√ß√µes da task
                  Row(
                    children: [
                      // Status
                      _buildInfoChip(
                        icon: Icons.info_outline,
                        label: _getStatusText(),
                        color: _getStatusColor(),
                      ),

                      const SizedBox(width: AppDimensions.spacingSm),

                      // Contador de microtasks
                      _buildInfoChip(
                        icon: Icons.checklist,
                        label: '${task.completedMicrotasks}/${task.microtaskCount}',
                        color: AppColors.secondary,
                      ),

                      const Spacer(),

                      // Data de cria√ß√£o
                      Text(
                        _formatDate(task.createdAt),
                        style: const TextStyle(
                          fontSize: 12,
                          color: AppColors.textSecondary,
                        ),
                      ),
                    ],
                  ),

                  // Barra de progresso (se habilitada)
                  if (showProgress && task.microtaskCount > 0) ...[
                    const SizedBox(height: AppDimensions.spacingMd),
                    _buildProgressBar(),
                  ],
                ],
              ),
            ),
          ),

          // Conte√∫do expandido
          if (isExpanded && expandedContent != null)
            expandedContent!,
        ],
      ),
    );
  }

  Widget _buildPriorityBadge() {
    Color color;
    String text;

    switch (task.priority) {
      case TaskPriority.high:
        color = AppColors.error;
        text = 'Alta';
        break;
      case TaskPriority.medium:
        color = AppColors.warning;
        text = 'M√©dia';
        break;
      case TaskPriority.low:
        color = AppColors.success;
        text = 'Baixa';
        break;
    }

    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimensions.paddingSm,
        vertical: 2,
      ),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontSize: 10,
          fontWeight: FontWeight.w600,
          color: color,
        ),
      ),
    );
  }

  Widget _buildInfoChip({
    required IconData icon,
    required String label,
    required Color color,
  }) {
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimensions.paddingSm,
        vertical: 4,
      ),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(16),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 14,
            color: color,
          ),
          const SizedBox(width: 4),
          Text(
            label,
            style: TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.w500,
              color: color,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildProgressBar() {
    final progress = task.microtaskCount > 0
        ? task.completedMicrotasks / task.microtaskCount
        : 0.0;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            const Text(
              'Progresso',
              style: TextStyle(
                fontSize: 12,
                fontWeight: FontWeight.w500,
                color: AppColors.textSecondary,
              ),
            ),
            Text(
              '${(progress * 100).toInt()}%',
              style: const TextStyle(
                fontSize: 12,
                fontWeight: FontWeight.w600,
                color: AppColors.textPrimary,
              ),
            ),
          ],
        ),
        const SizedBox(height: 4),
        LinearProgressIndicator(
          value: progress,
          backgroundColor: AppColors.border,
          valueColor: AlwaysStoppedAnimation<Color>(
            progress == 1.0 ? AppColors.success : AppColors.primary,
          ),
          minHeight: 6,
        ),
      ],
    );
  }

  Color _getStatusColor() {
    switch (task.status) {
      case TaskStatus.pending:
        return AppColors.warning;
      case TaskStatus.inProgress:
        return AppColors.primary;
      case TaskStatus.completed:
        return AppColors.success;
      case TaskStatus.cancelled:
        return AppColors.error;
    }
  }

  String _getStatusText() {
    switch (task.status) {
      case TaskStatus.pending:
        return 'Pendente';
      case TaskStatus.inProgress:
        return 'Em Progresso';
      case TaskStatus.completed:
        return 'Conclu√≠da';
      case TaskStatus.cancelled:
        return 'Cancelada';
    }
  }

  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date);

    if (difference.inDays == 0) {
      return 'Hoje';
    } else if (difference.inDays == 1) {
      return 'Ontem';
    } else if (difference.inDays < 7) {
      return '${difference.inDays} dias atr√°s';
    } else {
      return '${date.day}/${date.month}/${date.year}';
    }
  }
}

## lib\data\services\task_service.dart <a id="task_service_dart"></a>

### Dependencies

- `package:cloud_firestore/cloud_firestore.dart`
- `package:uuid/uuid.dart`
- `../models/task_model.dart`
- `../../core/exceptions/app_exceptions.dart`

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:uuid/uuid.dart';
import '../models/task_model.dart';
import '../../core/exceptions/app_exceptions.dart';

/// Servi√ßo respons√°vel por opera√ß√µes relacionadas a tasks no Firebase
class TaskService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final Uuid _uuid = const Uuid();

  // Refer√™ncia da cole√ß√£o
  CollectionReference get _tasksCollection => _firestore.collection('tasks');

  /// Cria uma nova task
  Future<TaskModel> createTask({
    required String eventId,
    required String title,
    required String description,
    required TaskPriority priority,
    required String createdBy,
  }) async {
    try {
      // Gera um ID √∫nico para a task
      final taskId = _uuid.v4();
      final now = DateTime.now();

      // Cria a task com dados gerados pelo service
      final task = TaskModel.create(
        id: taskId,
        eventId: eventId,
        title: title,
        description: description,
        priority: priority,
        createdBy: createdBy,
        createdAt: now,
        updatedAt: now,
      );

      // Note: Validation should be done by repository/controller before calling service

      // Salva no Firestore
      await _tasksCollection.doc(taskId).set(task.toFirestore());

      return task;
    } catch (e) {
      if (e is ValidationException) rethrow;
      throw DatabaseException('Erro ao criar task: ${e.toString()}');
    }
  }

  /// Busca uma task por ID
  Future<TaskModel?> getTaskById(String taskId) async {
    try {
      final doc = await _tasksCollection.doc(taskId).get();

      if (!doc.exists) return null;

      return TaskModel.fromFirestore(doc);
    } catch (e) {
      throw DatabaseException('Erro ao buscar task: ${e.toString()}');
    }
  }

  /*
  /// Busca todas as tasks de um evento
  Future<List<TaskModel>> getTasksByEventId(String eventId) async {
    try {
      final querySnapshot = await _tasksCollection
          .where('eventId', isEqualTo: eventId)
          .get();

      return querySnapshot.docs
          .map((doc) => TaskModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      throw DatabaseException(
        'Erro ao buscar tasks do evento: ${e.toString()}',
      );
    }
  }
  */

  Future<List<TaskModel>> getTasksByEventId(String eventId) async {
    try {
      final querySnapshot = await _tasksCollection
          .where('eventId', isEqualTo: eventId)
          .orderBy('createdAt', descending: true) // agora funciona
          .get();

      return querySnapshot.docs
          .map((doc) => TaskModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      print('Erro ao buscar tasks do evento: ${e.toString()}');
      throw DatabaseException(
        'Erro ao buscar tasks do evento: ${e.toString()}',
      );
    }
  }

  /// Busca tasks criadas por um usu√°rio espec√≠fico
  Future<List<TaskModel>> getTasksByCreator(String userId) async {
    try {
      final querySnapshot = await _tasksCollection
          .where('createdBy', isEqualTo: userId)
          .orderBy('createdAt', descending: true)
          .get();

      return querySnapshot.docs
          .map((doc) => TaskModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      throw DatabaseException(
        'Erro ao buscar tasks do usu√°rio: ${e.toString()}',
      );
    }
  }

  /// Busca tasks por status
  Future<List<TaskModel>> getTasksByStatus(
    String eventId,
    TaskStatus status,
  ) async {
    try {
      final querySnapshot = await _tasksCollection
          .where('eventId', isEqualTo: eventId)
          .where('status', isEqualTo: status.value)
          .orderBy('createdAt', descending: false)
          .get();

      return querySnapshot.docs
          .map((doc) => TaskModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      throw DatabaseException(
        'Erro ao buscar tasks por status: ${e.toString()}',
      );
    }
  }

  /// Busca tasks por prioridade
  Future<List<TaskModel>> getTasksByPriority(
    String eventId,
    TaskPriority priority,
  ) async {
    try {
      final querySnapshot = await _tasksCollection
          .where('eventId', isEqualTo: eventId)
          .where('priority', isEqualTo: priority.value)
          .orderBy('createdAt', descending: false)
          .get();

      return querySnapshot.docs
          .map((doc) => TaskModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      throw DatabaseException(
        'Erro ao buscar tasks por prioridade: ${e.toString()}',
      );
    }
  }

  /// Atualiza uma task
  Future<TaskModel> updateTask(TaskModel task) async {
    try {
      if (task.id.isEmpty) {
        throw ValidationException('ID da task √© obrigat√≥rio para atualiza√ß√£o');
      }

      // Note: Validation should be done by repository/controller before calling service

      // Atualiza o timestamp
      final updatedTask = task.withUpdatedTimestamp();

      // Salva no Firestore
      await _tasksCollection.doc(task.id).update(updatedTask.toFirestore());

      return updatedTask;
    } catch (e) {
      if (e is ValidationException) rethrow;
      throw DatabaseException('Erro ao atualizar task: ${e.toString()}');
    }
  }

  /// Atualiza o status de uma task
  Future<TaskModel> updateTaskStatus(String taskId, TaskStatus status) async {
    try {
      final task = await getTaskById(taskId);
      if (task == null) {
        throw DatabaseException('Task n√£o encontrada');
      }

      final updatedTask = task.copyWith(
        status: status,
        updatedAt: DateTime.now(),
      );

      return await updateTask(updatedTask);
    } catch (e) {
      if (e is DatabaseException || e is ValidationException) rethrow;
      throw DatabaseException(
        'Erro ao atualizar status da task: ${e.toString()}',
      );
    }
  }

  /// Atualiza os contadores de microtasks
  Future<TaskModel> updateMicrotaskCounters({
    required String taskId,
    required int microtaskCount,
    required int completedMicrotasks,
  }) async {
    try {
      final task = await getTaskById(taskId);
      if (task == null) {
        throw DatabaseException('Task n√£o encontrada');
      }

      final updatedTask = task
          .copyWith(
            microtaskCount: microtaskCount,
            completedMicrotasks: completedMicrotasks,
            updatedAt: DateTime.now(),
          )
          .updateStatusFromMicrotasks();

      return await updateTask(updatedTask);
    } catch (e) {
      if (e is DatabaseException || e is ValidationException) rethrow;
      throw DatabaseException(
        'Erro ao atualizar contadores da task: ${e.toString()}',
      );
    }
  }

  /// Incrementa o contador de microtasks
  Future<TaskModel> incrementMicrotaskCount(String taskId) async {
    try {
      final task = await getTaskById(taskId);
      if (task == null) {
        throw DatabaseException('Task n√£o encontrada');
      }

      final updatedTask = task.incrementMicrotaskCount();
      return await updateTask(updatedTask);
    } catch (e) {
      if (e is DatabaseException || e is ValidationException) rethrow;
      throw DatabaseException(
        'Erro ao incrementar contador de microtasks: ${e.toString()}',
      );
    }
  }

  /// Decrementa o contador de microtasks
  Future<TaskModel> decrementMicrotaskCount(String taskId) async {
    try {
      final task = await getTaskById(taskId);
      if (task == null) {
        throw DatabaseException('Task n√£o encontrada');
      }

      final updatedTask = task.decrementMicrotaskCount();
      return await updateTask(updatedTask);
    } catch (e) {
      if (e is DatabaseException || e is ValidationException) rethrow;
      throw DatabaseException(
        'Erro ao decrementar contador de microtasks: ${e.toString()}',
      );
    }
  }

  /// Incrementa o contador de microtasks conclu√≠das
  Future<TaskModel> incrementCompletedMicrotasks(String taskId) async {
    try {
      final task = await getTaskById(taskId);
      if (task == null) {
        throw DatabaseException('Task n√£o encontrada');
      }

      final updatedTask = task
          .incrementCompletedMicrotasks()
          .updateStatusFromMicrotasks();
      return await updateTask(updatedTask);
    } catch (e) {
      if (e is DatabaseException || e is ValidationException) rethrow;
      throw DatabaseException(
        'Erro ao incrementar microtasks conclu√≠das: ${e.toString()}',
      );
    }
  }

  /// Decrementa o contador de microtasks conclu√≠das
  Future<TaskModel> decrementCompletedMicrotasks(String taskId) async {
    try {
      final task = await getTaskById(taskId);
      if (task == null) {
        throw DatabaseException('Task n√£o encontrada');
      }

      final updatedTask = task
          .decrementCompletedMicrotasks()
          .updateStatusFromMicrotasks();
      return await updateTask(updatedTask);
    } catch (e) {
      if (e is DatabaseException || e is ValidationException) rethrow;
      throw DatabaseException(
        'Erro ao decrementar microtasks conclu√≠das: ${e.toString()}',
      );
    }
  }

  /// Deleta uma task
  Future<void> deleteTask(String taskId) async {
    try {
      await _tasksCollection.doc(taskId).delete();
    } catch (e) {
      throw DatabaseException('Erro ao deletar task: ${e.toString()}');
    }
  }

  /// Deleta todas as tasks de um evento
  Future<void> deleteTasksByEventId(String eventId) async {
    try {
      final querySnapshot = await _tasksCollection
          .where('eventId', isEqualTo: eventId)
          .get();

      final batch = _firestore.batch();
      for (final doc in querySnapshot.docs) {
        batch.delete(doc.reference);
      }

      await batch.commit();
    } catch (e) {
      throw DatabaseException(
        'Erro ao deletar tasks do evento: ${e.toString()}',
      );
    }
  }

  /// Stream para escutar mudan√ßas em uma task
  Stream<TaskModel?> watchTask(String taskId) {
    return _tasksCollection.doc(taskId).snapshots().map((doc) {
      if (!doc.exists) return null;
      return TaskModel.fromFirestore(doc);
    });
  }

  /// Stream para escutar mudan√ßas nas tasks de um evento
  Stream<List<TaskModel>> watchTasksByEventId(String eventId) {
    return _tasksCollection
        .where('eventId', isEqualTo: eventId)
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map(
          (snapshot) =>
              snapshot.docs.map((doc) => TaskModel.fromFirestore(doc)).toList(),
        );
  }

  /// Busca tasks com filtros m√∫ltiplos
  Future<List<TaskModel>> getTasksWithFilters({
    required String eventId,
    TaskStatus? status,
    TaskPriority? priority,
    String? createdBy,
  }) async {
    try {
      Query query = _tasksCollection.where('eventId', isEqualTo: eventId);

      if (status != null) {
        query = query.where('status', isEqualTo: status.value);
      }

      if (priority != null) {
        query = query.where('priority', isEqualTo: priority.value);
      }

      if (createdBy != null && createdBy.isNotEmpty) {
        query = query.where('createdBy', isEqualTo: createdBy);
      }

      // Removido orderBy temporariamente para evitar problemas de √≠ndice
      query = query.orderBy('createdAt', descending: false);

      final querySnapshot = await query.get();

      return querySnapshot.docs
          .map((doc) => TaskModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      throw DatabaseException(
        'Erro ao buscar tasks com filtros: ${e.toString()}',
      );
    }
  }
}

## lib\presentation\screens\event\track_tasks_screen.dart <a id="track_tasks_screen_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `package:provider/provider.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/task_model.dart`
- `../../controllers/task_controller.dart`
- `../../widgets/common/loading_widget.dart`
- `../../widgets/common/custom_app_bar.dart`
- `../../widgets/common/skill_chip.dart`
- `../../widgets/task/task_card.dart`
- `../../widgets/task/microtask_card.dart`
- `../../widgets/task/task_progress_widget.dart`

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/task_model.dart';
import '../../controllers/task_controller.dart';
import '../../widgets/common/loading_widget.dart';
import '../../widgets/common/custom_app_bar.dart';
import '../../widgets/common/skill_chip.dart';
import '../../widgets/task/task_card.dart';
import '../../widgets/task/microtask_card.dart';
import '../../widgets/task/task_progress_widget.dart';

/// Tela para acompanhamento de tasks (implementa√ß√£o b√°sica)
class TrackTasksScreen extends StatefulWidget {
  final String eventId;

  const TrackTasksScreen({super.key, required this.eventId});

  @override
  State<TrackTasksScreen> createState() => _TrackTasksScreenState();
}

class _TrackTasksScreenState extends State<TrackTasksScreen> {
  final Set<String> _expandedTasks = {};
  String _searchQuery = '';

  @override
  Widget build(BuildContext context) {
    return Consumer<TaskController>(
      builder: (context, taskController, child) {
        if (taskController.isLoading) {
          return const LoadingWidget(message: 'Carregando tasks...');
        }

        final allTasks = taskController.tasks;
        final filteredTasks = _getFilteredTasks(allTasks);

        return Column(
          children: [
            _buildSearchAndFilters(),
            Expanded(
              child: filteredTasks.isEmpty
                  ? _buildEmptyState()
                  : SingleChildScrollView(
                      padding: const EdgeInsets.all(AppDimensions.paddingLg),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          _buildHeader(allTasks),
                          const SizedBox(height: AppDimensions.spacingLg),
                          _buildTasksList(allTasks, taskController),
                        ],
                      ),
                    ),
            ),
          ],
        );
      },
    );
  }

  Widget _buildEmptyState() {
    return Padding(
      padding: const EdgeInsets.all(AppDimensions.paddingLg),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.task_alt,
            size: 64,
            color: AppColors.primary.withOpacity(0.5),
          ),
          const SizedBox(height: AppDimensions.spacingLg),
          const Text(
            'Nenhuma Task Criada',
            style: TextStyle(
              fontSize: 24,
              fontWeight: FontWeight.bold,
              color: AppColors.textPrimary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingMd),
          const Text(
            'Ainda n√£o h√° tasks criadas para este evento.\n\nV√° para a aba "Criar Tasks" para come√ßar a organizar o trabalho.',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 16,
              color: AppColors.textSecondary,
              height: 1.5,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildHeader(List<TaskModel> tasks) {
    final totalTasks = tasks.length;
    final completedTasks = tasks.where((task) => task.isCompleted).length;
    final totalMicrotasks = tasks.fold<int>(
      0,
      (sum, task) => sum + task.microtaskCount,
    );
    final completedMicrotasks = tasks.fold<int>(
      0,
      (sum, task) => sum + task.completedMicrotasks,
    );

    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(AppDimensions.paddingLg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Icon(Icons.analytics_outlined, color: AppColors.primary),
                const SizedBox(width: AppDimensions.spacingSm),
                const Text(
                  'Progresso Geral',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: AppColors.textPrimary,
                  ),
                ),
              ],
            ),
            const SizedBox(height: AppDimensions.spacingMd),
            Row(
              children: [
                Expanded(
                  child: _buildProgressItem(
                    'Tasks',
                    completedTasks,
                    totalTasks,
                    Icons.task_alt,
                    AppColors.primary,
                  ),
                ),
                const SizedBox(width: AppDimensions.spacingMd),
                Expanded(
                  child: _buildProgressItem(
                    'Microtasks',
                    completedMicrotasks,
                    totalMicrotasks,
                    Icons.checklist,
                    AppColors.secondary,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildProgressItem(
    String label,
    int completed,
    int total,
    IconData icon,
    Color color,
  ) {
    final progress = total > 0 ? completed / total : 0.0;

    return Container(
      padding: const EdgeInsets.all(AppDimensions.paddingMd),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Column(
        children: [
          Icon(icon, color: color, size: 24),
          const SizedBox(height: AppDimensions.spacingSm),
          Text(
            '$completed/$total',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
          Text(
            label,
            style: const TextStyle(
              fontSize: 12,
              color: AppColors.textSecondary,
            ),
          ),
          const SizedBox(height: AppDimensions.spacingSm),
          LinearProgressIndicator(
            value: progress,
            backgroundColor: color.withOpacity(0.2),
            valueColor: AlwaysStoppedAnimation<Color>(color),
          ),
          const SizedBox(height: AppDimensions.spacingXs),
          Text(
            '${(progress * 100).toStringAsFixed(0)}%',
            style: TextStyle(
              fontSize: 10,
              color: color,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTasksList(List<TaskModel> tasks, TaskController taskController) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Tasks do Evento',
          style: TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
            color: AppColors.textPrimary,
          ),
        ),
        const SizedBox(height: AppDimensions.spacingMd),
        ...tasks.map((task) => _buildTaskCard(task, taskController)),
      ],
    );
  }

  Widget _buildTaskCard(TaskModel task, TaskController taskController) {
    final microtasks = taskController.getMicrotasksByTaskId(task.id);

    return Card(
      elevation: 1,
      margin: const EdgeInsets.only(bottom: AppDimensions.spacingMd),
      child: ExpansionTile(
        leading: _buildTaskStatusIcon(task),
        title: Text(
          task.title,
          style: const TextStyle(
            fontWeight: FontWeight.w600,
            color: AppColors.textPrimary,
          ),
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              task.description,
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
              style: const TextStyle(
                color: AppColors.textSecondary,
                fontSize: 12,
              ),
            ),
            const SizedBox(height: AppDimensions.spacingXs),
            Row(
              children: [
                _buildPriorityChip(task.priority),
                const SizedBox(width: AppDimensions.spacingSm),
                Text(
                  '${task.completedMicrotasks}/${task.microtaskCount} microtasks',
                  style: const TextStyle(
                    fontSize: 12,
                    color: AppColors.textSecondary,
                  ),
                ),
              ],
            ),
          ],
        ),
        children: [
          if (microtasks.isEmpty)
            const Padding(
              padding: EdgeInsets.all(AppDimensions.paddingMd),
              child: Text(
                'Nenhuma microtask criada ainda',
                style: TextStyle(
                  color: AppColors.textSecondary,
                  fontStyle: FontStyle.italic,
                ),
              ),
            )
          else
            ...microtasks.map((microtask) => _buildMicrotaskItem(microtask)),
        ],
      ),
    );
  }

  Widget _buildTaskStatusIcon(TaskModel task) {
    IconData icon;
    Color color;

    switch (task.status) {
      case TaskStatus.pending:
        icon = Icons.schedule;
        color = AppColors.warning;
        break;
      case TaskStatus.inProgress:
        icon = Icons.play_circle;
        color = AppColors.primary;
        break;
      case TaskStatus.completed:
        icon = Icons.check_circle;
        color = AppColors.success;
        break;
      case TaskStatus.cancelled:
        icon = Icons.cancel;
        color = AppColors.error;
        break;
    }

    return Icon(icon, color: color);
  }

  Widget _buildPriorityChip(TaskPriority priority) {
    Color color;
    String text;

    switch (priority) {
      case TaskPriority.high:
        color = AppColors.error;
        text = 'Alta';
        break;
      case TaskPriority.medium:
        color = AppColors.warning;
        text = 'M√©dia';
        break;
      case TaskPriority.low:
        color = AppColors.success;
        text = 'Baixa';
        break;
    }

    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppDimensions.paddingSm,
        vertical: 2,
      ),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontSize: 10,
          color: color,
          fontWeight: FontWeight.w500,
        ),
      ),
    );
  }

  Widget _buildMicrotaskItem(microtask) {
    return ListTile(
      dense: true,
      leading: Icon(
        Icons.check_box_outline_blank,
        size: 16,
        color: AppColors.textSecondary,
      ),
      title: Text(
        microtask.title,
        style: const TextStyle(fontSize: 14, color: AppColors.textPrimary),
      ),
      subtitle: Text(
        'Volunt√°rios: ${microtask.assignedTo.length}/${microtask.maxVolunteers}',
        style: const TextStyle(fontSize: 12, color: AppColors.textSecondary),
      ),
      trailing: Text(
        microtask.status.toString().split('.').last,
        style: const TextStyle(fontSize: 12, color: AppColors.textSecondary),
      ),
    );
  }

  List<TaskModel> _getFilteredTasks(List<TaskModel> tasks) {
    List<TaskModel> filtered = List.from(tasks);

    // Aplicar filtro de busca
    if (_searchQuery.isNotEmpty) {
      filtered = filtered.where((task) {
        final title = task.title.toLowerCase();
        final description = task.description.toLowerCase();
        final query = _searchQuery.toLowerCase();
        return title.contains(query) || description.contains(query);
      }).toList();
    }
    return filtered;
  }

  Widget _buildSearchAndFilters() {
    return Container(
      padding: const EdgeInsets.all(AppDimensions.paddingMd),
      decoration: const BoxDecoration(
        color: AppColors.background,
        border: Border(bottom: BorderSide(color: AppColors.border)),
      ),
      child: Column(
        children: [
          // Barra de busca
          TextField(
            onChanged: (value) {
              setState(() {
                _searchQuery = value;
              });
            },
            decoration: InputDecoration(
              hintText: 'Buscar tasks...',
              prefixIcon: const Icon(Icons.search),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              contentPadding: const EdgeInsets.symmetric(
                horizontal: AppDimensions.paddingMd,
                vertical: AppDimensions.paddingSm,
              ),
            ),
          ),
          const SizedBox(height: AppDimensions.spacingMd),
        ],
      ),
    );
  }
}

## lib\data\services\user_service.dart <a id="user_service_dart"></a>

### Dependencies

- `package:cloud_firestore/cloud_firestore.dart`
- `../../core/exceptions/app_exceptions.dart`
- `../models/user_model.dart`

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../core/exceptions/app_exceptions.dart';
import '../models/user_model.dart';

/// Servi√ßo respons√°vel por opera√ß√µes relacionadas a usu√°rios
class UserService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  late final CollectionReference _usersCollection;

  UserService() {
    _usersCollection = _firestore.collection('users');
  }

  /// Busca um usu√°rio pelo ID
  Future<UserModel?> getUserById(String userId) async {
    try {
      if (userId.isEmpty) {
        throw ValidationException('ID do usu√°rio √© obrigat√≥rio');
      }

      final doc = await _usersCollection.doc(userId).get();

      if (!doc.exists) {
        return null;
      }

      return UserModel.fromFirestore(doc);
    } catch (e) {
      if (e is ValidationException) rethrow;
      throw DatabaseException('Erro ao buscar usu√°rio: ${e.toString()}');
    }
  }

  /// Busca m√∫ltiplos usu√°rios pelos IDs
  Future<List<UserModel>> getUsersByIds(List<String> userIds) async {
    try {
      if (userIds.isEmpty) {
        return [];
      }

      // Remove IDs duplicados e vazios
      final cleanIds = userIds.where((id) => id.isNotEmpty).toSet().toList();

      if (cleanIds.isEmpty) {
        return [];
      }

      // Firestore tem limite de 10 itens por consulta 'in'
      // Vamos dividir em chunks se necess√°rio
      final users = <UserModel>[];
      const chunkSize = 10;

      for (int i = 0; i < cleanIds.length; i += chunkSize) {
        final chunk = cleanIds.skip(i).take(chunkSize).toList();

        final querySnapshot = await _usersCollection
            .where(FieldPath.documentId, whereIn: chunk)
            .get();

        final chunkUsers = querySnapshot.docs
            .map((doc) => UserModel.fromFirestore(doc))
            .toList();

        users.addAll(chunkUsers);
      }

      return users;
    } catch (e) {
      throw DatabaseException('Erro ao buscar usu√°rios: ${e.toString()}');
    }
  }

  /// Busca usu√°rios por email (para busca/filtro)
  Future<List<UserModel>> searchUsersByEmail(String emailQuery) async {
    try {
      if (emailQuery.isEmpty) {
        return [];
      }

      // Busca por email que comece com o termo
      final querySnapshot = await _usersCollection
          .where('email', isGreaterThanOrEqualTo: emailQuery.toLowerCase())
          .where('email', isLessThan: '${emailQuery.toLowerCase()}z')
          .limit(20)
          .get();

      return querySnapshot.docs
          .map((doc) => UserModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      throw DatabaseException('Erro ao buscar usu√°rios por email: ${e.toString()}');
    }
  }

  /// Busca usu√°rios por nome (para busca/filtro)
  Future<List<UserModel>> searchUsersByName(String nameQuery) async {
    try {
      if (nameQuery.isEmpty) {
        return [];
      }

      // Busca por nome que comece com o termo
      final querySnapshot = await _usersCollection
          .where('name', isGreaterThanOrEqualTo: nameQuery)
          .where('name', isLessThan: '${nameQuery}z')
          .limit(20)
          .get();

      return querySnapshot.docs
          .map((doc) => UserModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      throw DatabaseException('Erro ao buscar usu√°rios por nome: ${e.toString()}');
    }
  }

  /// Atualiza informa√ß√µes do usu√°rio
  Future<UserModel> updateUser(UserModel user) async {
    try {
      final validationErrors = user.validate();
      if (validationErrors.isNotEmpty) {
        throw ValidationException(
          'Dados inv√°lidos: ${validationErrors.join(', ')}',
        );
      }

      await _usersCollection.doc(user.id).update(user.toFirestore());

      return user;
    } catch (e) {
      if (e is ValidationException) rethrow;
      throw DatabaseException('Erro ao atualizar usu√°rio: ${e.toString()}');
    }
  }

  /// Cria ou atualiza um usu√°rio
  Future<UserModel> createOrUpdateUser(UserModel user) async {
    try {
      final validationErrors = user.validate();
      if (validationErrors.isNotEmpty) {
        throw ValidationException(
          'Dados inv√°lidos: ${validationErrors.join(', ')}',
        );
      }

      await _usersCollection.doc(user.id).set(user.toFirestore(), SetOptions(merge: true));

      return user;
    } catch (e) {
      if (e is ValidationException) rethrow;
      throw DatabaseException('Erro ao criar/atualizar usu√°rio: ${e.toString()}');
    }
  }

  /// Verifica se um usu√°rio existe
  Future<bool> userExists(String userId) async {
    try {
      if (userId.isEmpty) {
        return false;
      }

      final doc = await _usersCollection.doc(userId).get();
      return doc.exists;
    } catch (e) {
      throw DatabaseException('Erro ao verificar exist√™ncia do usu√°rio: ${e.toString()}');
    }
  }

  /// Stream para monitorar mudan√ßas em um usu√°rio
  Stream<UserModel?> watchUser(String userId) {
    if (userId.isEmpty) {
      return Stream.value(null);
    }

    return _usersCollection
        .doc(userId)
        .snapshots()
        .map((doc) {
          if (!doc.exists) return null;
          return UserModel.fromFirestore(doc);
        });
  }

  /// Busca usu√°rios recentes (√∫ltimos cadastrados)
  Future<List<UserModel>> getRecentUsers({int limit = 10}) async {
    try {
      final querySnapshot = await _usersCollection
          .orderBy('createdAt', descending: true)
          .limit(limit)
          .get();

      return querySnapshot.docs
          .map((doc) => UserModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      throw DatabaseException('Erro ao buscar usu√°rios recentes: ${e.toString()}');
    }
  }
}

## lib\data\models\user_microtask_model.dart <a id="user_microtask_model_dart"></a>

### Dependencies

- `package:cloud_firestore/cloud_firestore.dart`

import 'package:cloud_firestore/cloud_firestore.dart';

/// Enums para status individual do usu√°rio na microtask
enum UserMicrotaskStatus {
  assigned('assigned'),
  started('started'),
  completed('completed'),
  cancelled('cancelled');

  const UserMicrotaskStatus(this.value);
  final String value;

  static UserMicrotaskStatus fromString(String value) {
    return UserMicrotaskStatus.values.firstWhere(
      (status) => status.value == value,
      orElse: () => UserMicrotaskStatus.assigned,
    );
  }

  @override
  String toString() => value;
}

/// Modelo de dados para representar a rela√ß√£o entre um usu√°rio e uma microtask
/// Controla o status individual de cada volunt√°rio em uma microtask
/// Baseado na estrutura definida no SPEC_GERAL.md
class UserMicrotaskModel {
  final String id;
  final String userId;
  final String microtaskId;
  final String eventId;
  final UserMicrotaskStatus status;
  final DateTime assignedAt;
  final DateTime? startedAt;
  final DateTime? completedAt;
  final double? actualHours;
  final String notes;
  final DateTime createdAt;
  final DateTime updatedAt;

  const UserMicrotaskModel({
    required this.id,
    required this.userId,
    required this.microtaskId,
    required this.eventId,
    required this.status,
    required this.assignedAt,
    this.startedAt,
    this.completedAt,
    this.actualHours,
    required this.notes,
    required this.createdAt,
    required this.updatedAt,
  });

  /// Cria uma inst√¢ncia de UserMicrotaskModel a partir de um Map (JSON)
  factory UserMicrotaskModel.fromMap(Map<String, dynamic> map) {
    return UserMicrotaskModel(
      id: map['id'] as String,
      userId: map['userId'] as String,
      microtaskId: map['microtaskId'] as String,
      eventId: map['eventId'] as String,
      status: UserMicrotaskStatus.fromString(map['status'] as String),
      assignedAt: (map['assignedAt'] as Timestamp).toDate(),
      startedAt: map['startedAt'] != null
          ? (map['startedAt'] as Timestamp).toDate()
          : null,
      completedAt: map['completedAt'] != null
          ? (map['completedAt'] as Timestamp).toDate()
          : null,
      actualHours: (map['actualHours'] as num?)?.toDouble(),
      notes: map['notes'] as String? ?? '',
      createdAt: (map['createdAt'] as Timestamp).toDate(),
      updatedAt: (map['updatedAt'] as Timestamp).toDate(),
    );
  }

  /// Cria uma inst√¢ncia de UserMicrotaskModel a partir de um DocumentSnapshot do Firestore
  factory UserMicrotaskModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return UserMicrotaskModel.fromMap({'id': doc.id, ...data});
  }

  /// Converte a inst√¢ncia para um Map (JSON)
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'userId': userId,
      'microtaskId': microtaskId,
      'eventId': eventId,
      'status': status.value,
      'assignedAt': Timestamp.fromDate(assignedAt),
      'startedAt': startedAt != null ? Timestamp.fromDate(startedAt!) : null,
      'completedAt': completedAt != null
          ? Timestamp.fromDate(completedAt!)
          : null,
      'actualHours': actualHours,
      'notes': notes,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
    };
  }

  /// Converte para formato do Firestore (sem o ID)
  Map<String, dynamic> toFirestore() {
    final map = toMap();
    map.remove('id');
    return map;
  }

  /// Cria uma c√≥pia da inst√¢ncia com alguns campos alterados
  UserMicrotaskModel copyWith({
    String? id,
    String? userId,
    String? microtaskId,
    String? eventId,
    UserMicrotaskStatus? status,
    DateTime? assignedAt,
    DateTime? startedAt,
    DateTime? completedAt,
    double? actualHours,
    String? notes,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return UserMicrotaskModel(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      microtaskId: microtaskId ?? this.microtaskId,
      eventId: eventId ?? this.eventId,
      status: status ?? this.status,
      assignedAt: assignedAt ?? this.assignedAt,
      startedAt: startedAt ?? this.startedAt,
      completedAt: completedAt ?? this.completedAt,
      actualHours: actualHours ?? this.actualHours,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  /// Cria uma nova inst√¢ncia com updatedAt atualizado para agora
  UserMicrotaskModel withUpdatedTimestamp() {
    return copyWith(updatedAt: DateTime.now());
  }

  /// Factory para criar uma nova rela√ß√£o usu√°rio-microtask
  /// Note: ID e timestamps devem ser definidos pelo service
  factory UserMicrotaskModel.create({
    required String id,
    required String userId,
    required String microtaskId,
    required String eventId,
    required DateTime assignedAt,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) {
    return UserMicrotaskModel(
      id: id,
      userId: userId,
      microtaskId: microtaskId,
      eventId: eventId,
      status: UserMicrotaskStatus.assigned,
      assignedAt: assignedAt,
      notes: '',
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  /// Valida se os dados da rela√ß√£o s√£o v√°lidos
  List<String> validate() {
    final errors = <String>[];

    if (userId.isEmpty) {
      errors.add('ID do usu√°rio √© obrigat√≥rio');
    }

    if (microtaskId.isEmpty) {
      errors.add('ID da microtask √© obrigat√≥rio');
    }

    if (eventId.isEmpty) {
      errors.add('ID do evento √© obrigat√≥rio');
    }

    if (actualHours != null && actualHours! < 0) {
      errors.add('Horas trabalhadas n√£o podem ser negativas');
    }

    if (startedAt != null && startedAt!.isBefore(assignedAt)) {
      errors.add('Data de in√≠cio n√£o pode ser anterior √† data de atribui√ß√£o');
    }

    if (completedAt != null &&
        startedAt != null &&
        completedAt!.isBefore(startedAt!)) {
      errors.add('Data de conclus√£o n√£o pode ser anterior √† data de in√≠cio');
    }

    return errors;
  }

  /// Verifica se a rela√ß√£o √© v√°lida
  bool isValid() => validate().isEmpty;

  /// Verifica se o usu√°rio completou a microtask
  bool get isCompleted => status == UserMicrotaskStatus.completed;

  /// Verifica se o usu√°rio iniciou a microtask
  bool get isStarted => status == UserMicrotaskStatus.started;

  /// Verifica se o usu√°rio foi apenas atribu√≠do (n√£o iniciou)
  bool get isAssigned => status == UserMicrotaskStatus.assigned;

  /// Verifica se foi cancelado
  bool get isCancelled => status == UserMicrotaskStatus.cancelled;

  /// Marca como iniciado
  UserMicrotaskModel markAsStarted() {
    if (status == UserMicrotaskStatus.assigned) {
      final now = DateTime.now();
      return copyWith(
        status: UserMicrotaskStatus.started,
        startedAt: now,
        updatedAt: now,
      );
    }
    return this;
  }

  /// Marca como conclu√≠do
  UserMicrotaskModel markAsCompleted({double? actualHours}) {
    final now = DateTime.now();
    return copyWith(
      status: UserMicrotaskStatus.completed,
      completedAt: now,
      actualHours: actualHours ?? this.actualHours,
      updatedAt: now,
    );
  }

  /// Marca como cancelado
  UserMicrotaskModel markAsCancelled() {
    final now = DateTime.now();
    return copyWith(status: UserMicrotaskStatus.cancelled, updatedAt: now);
  }

  /// Atualiza as notas
  UserMicrotaskModel updateNotes(String newNotes) {
    return copyWith(notes: newNotes, updatedAt: DateTime.now());
  }

  /// Atualiza as horas trabalhadas
  UserMicrotaskModel updateActualHours(double hours) {
    return copyWith(
      actualHours: hours >= 0 ? hours : 0,
      updatedAt: DateTime.now(),
    );
  }

  /// Calcula a dura√ß√£o do trabalho (se iniciado e conclu√≠do)
  Duration? get workDuration {
    if (startedAt != null && completedAt != null) {
      return completedAt!.difference(startedAt!);
    }
    return null;
  }

  /// Calcula a dura√ß√£o desde a atribui√ß√£o at√© agora (se n√£o conclu√≠do)
  Duration get durationSinceAssigned {
    final endTime = completedAt ?? DateTime.now();
    return endTime.difference(assignedAt);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is UserMicrotaskModel &&
        other.id == id &&
        other.userId == userId &&
        other.microtaskId == microtaskId &&
        other.eventId == eventId &&
        other.status == status;
  }

  @override
  int get hashCode {
    return Object.hash(id, userId, microtaskId, eventId, status);
  }

  @override
  String toString() {
    return 'UserMicrotaskModel(id: $id, userId: $userId, microtaskId: $microtaskId, status: $status)';
  }
}

## lib\data\models\user_model.dart <a id="user_model_dart"></a>

### Dependencies

- `package:cloud_firestore/cloud_firestore.dart`

import 'package:cloud_firestore/cloud_firestore.dart';

/// Modelo de dados para representar um usu√°rio no sistema
/// Baseado na estrutura definida no SPEC_GERAL.md
class UserModel {
  final String id;
  final String name;
  final String email;
  final String? photoUrl;
  final DateTime createdAt;
  final DateTime updatedAt;

  const UserModel({
    required this.id,
    required this.name,
    required this.email,
    this.photoUrl,
    required this.createdAt,
    required this.updatedAt,
  });

  /// Cria uma inst√¢ncia de UserModel a partir de um Map (JSON)
  factory UserModel.fromMap(Map<String, dynamic> map) {
    return UserModel(
      id: map['id'] as String,
      name: map['name'] as String,
      email: map['email'] as String,
      photoUrl: map['photoUrl'] as String?,
      createdAt: (map['createdAt'] as Timestamp).toDate(),
      updatedAt: (map['updatedAt'] as Timestamp).toDate(),
    );
  }

  /// Cria uma inst√¢ncia de UserModel a partir de um DocumentSnapshot do Firestore
  factory UserModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return UserModel.fromMap({'id': doc.id, ...data});
  }

  /// Converte a inst√¢ncia para um Map (JSON)
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'email': email,
      'photoUrl': photoUrl,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
    };
  }

  /// Converte para Map sem o ID (usado para criar documentos no Firestore)
  Map<String, dynamic> toFirestore() {
    final map = toMap();
    map.remove('id'); // Remove o ID pois ser√° gerado pelo Firestore
    return map;
  }

  /// Cria uma c√≥pia da inst√¢ncia com alguns campos alterados
  UserModel copyWith({
    String? id,
    String? name,
    String? email,
    String? photoUrl,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return UserModel(
      id: id ?? this.id,
      name: name ?? this.name,
      email: email ?? this.email,
      photoUrl: photoUrl ?? this.photoUrl,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  /// Cria uma nova inst√¢ncia com updatedAt atualizado para agora
  UserModel withUpdatedTimestamp() {
    return copyWith(updatedAt: DateTime.now());
  }

  /// Valida se os dados do usu√°rio s√£o v√°lidos
  bool isValid() {
    return id.isNotEmpty &&
        name.isNotEmpty &&
        email.isNotEmpty &&
        _isValidEmail(email);
  }

  /// Valida se o email tem formato v√°lido
  bool _isValidEmail(String email) {
    return RegExp(
      r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',
    ).hasMatch(email);
  }

  /// Retorna as iniciais do nome do usu√°rio
  String get initials {
    if (name.isEmpty) return '';

    final words = name.trim().split(' ');
    if (words.length == 1) {
      return words[0][0].toUpperCase();
    }

    return '${words[0][0]}${words[words.length - 1][0]}'.toUpperCase();
  }

  /// Retorna o primeiro nome do usu√°rio
  String get firstName {
    if (name.isEmpty) return '';
    return name.split(' ')[0];
  }

  /// Retorna o nome completo formatado
  String get displayName {
    return name.trim();
  }

  /// Verifica se o usu√°rio tem foto de perfil
  bool get hasPhoto {
    return photoUrl != null && photoUrl!.isNotEmpty;
  }

  /// Retorna a URL da foto ou null se n√£o houver
  String? get profileImageUrl {
    return hasPhoto ? photoUrl : null;
  }

  /// Factory para criar um usu√°rio a partir dos dados do Google Sign-In
  factory UserModel.fromGoogleSignIn({
    required String uid,
    required String name,
    required String email,
    String? photoUrl,
  }) {
    final now = DateTime.now();
    return UserModel(
      id: uid,
      name: name,
      email: email,
      photoUrl: photoUrl,
      createdAt: now,
      updatedAt: now,
    );
  }

  /// Factory para criar um usu√°rio a partir do cadastro manual
  factory UserModel.fromRegistration({
    required String uid,
    required String name,
    required String email,
  }) {
    final now = DateTime.now();
    return UserModel(
      id: uid,
      name: name,
      email: email,
      photoUrl: null,
      createdAt: now,
      updatedAt: now,
    );
  }

  /// Converte para string para debug
  @override
  String toString() {
    return 'UserModel(id: $id, name: $name, email: $email, photoUrl: $photoUrl, createdAt: $createdAt, updatedAt: $updatedAt)';
  }

  /// Implementa igualdade baseada no ID
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is UserModel && other.id == id;
  }

  /// Implementa hashCode baseado no ID
  @override
  int get hashCode => id.hashCode;

  /// M√©todo para validar dados antes de salvar
  List<String> validate() {
    final errors = <String>[];

    if (id.isEmpty) {
      errors.add('ID √© obrigat√≥rio');
    }

    if (name.isEmpty) {
      errors.add('Nome √© obrigat√≥rio');
    } else if (name.length < 2) {
      errors.add('Nome deve ter pelo menos 2 caracteres');
    } else if (name.length > 50) {
      errors.add('Nome deve ter no m√°ximo 50 caracteres');
    }

    if (email.isEmpty) {
      errors.add('E-mail √© obrigat√≥rio');
    } else if (!_isValidEmail(email)) {
      errors.add('E-mail inv√°lido');
    }

    if (photoUrl != null && photoUrl!.isNotEmpty) {
      final uri = Uri.tryParse(photoUrl!);
      if (uri == null || !uri.hasAbsolutePath) {
        errors.add('URL da foto inv√°lida');
      }
    }

    return errors;
  }

  /// Verifica se o usu√°rio foi criado recentemente (√∫ltimas 24 horas)
  bool get isNewUser {
    final now = DateTime.now();
    final difference = now.difference(createdAt);
    return difference.inHours < 24;
  }

  /// Retorna h√° quanto tempo o usu√°rio foi criado
  String get createdTimeAgo {
    final now = DateTime.now();
    final difference = now.difference(createdAt);

    if (difference.inDays > 0) {
      return '${difference.inDays} dia${difference.inDays > 1 ? 's' : ''} atr√°s';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} hora${difference.inHours > 1 ? 's' : ''} atr√°s';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} minuto${difference.inMinutes > 1 ? 's' : ''} atr√°s';
    } else {
      return 'Agora mesmo';
    }
  }

  /// Retorna h√° quanto tempo o usu√°rio foi atualizado
  String get updatedTimeAgo {
    final now = DateTime.now();
    final difference = now.difference(updatedAt);

    if (difference.inDays > 0) {
      return '${difference.inDays} dia${difference.inDays > 1 ? 's' : ''} atr√°s';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} hora${difference.inHours > 1 ? 's' : ''} atr√°s';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} minuto${difference.inMinutes > 1 ? 's' : ''} atr√°s';
    } else {
      return 'Agora mesmo';
    }
  }
}

## lib\presentation\widgets\volunteer\volunteer_card.dart <a id="volunteer_card_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/user_model.dart`
- `../../../data/models/volunteer_profile_model.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/user_model.dart';
import '../../../data/models/volunteer_profile_model.dart';

/// Widget card para exibir informa√ß√µes de um volunt√°rio (vers√£o compacta)
class VolunteerCard extends StatelessWidget {
  final UserModel user;
  final VolunteerProfileModel? profile;
  final VoidCallback? onTap;
  final VoidCallback?
  onShowActions; // Callback unificado para mostrar o menu de a√ß√µes
  final bool showActions;
  final bool isManager;
  final int assignedMicrotasksCount;
  final bool
  isCompatible; // Indica se o volunt√°rio √© compat√≠vel com filtros ativos
  final bool
  showDetailedAvailability; // Mostra hor√°rio detalhado de disponibilidade

  const VolunteerCard({
    super.key,
    required this.user,
    this.profile,
    this.onTap,
    this.onShowActions, // A√ß√£o unificada
    this.showActions = true,
    this.isManager = false,
    this.assignedMicrotasksCount = 0,
    this.isCompatible = false,
    this.showDetailedAvailability = false,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 2,
      margin: const EdgeInsets.symmetric(
        horizontal: AppDimensions.paddingSm, // Menor margem horizontal
        vertical: AppDimensions.paddingSm / 2, // Menor margem vertical
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(8),
        child: Padding(
          padding: const EdgeInsets.symmetric(
            horizontal: AppDimensions.paddingSm,
            vertical: AppDimensions.paddingSm,
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header principal com ListTile
              ListTile(
                contentPadding: EdgeInsets.zero,
                leading: CircleAvatar(
                  radius: 22,
                  backgroundColor: AppColors.primary.withOpacity(0.1),
                  backgroundImage: user.photoUrl != null
                      ? NetworkImage(user.photoUrl!)
                      : null,
                  child: user.photoUrl == null
                      ? Text(
                          user.name.isNotEmpty
                              ? user.name[0].toUpperCase()
                              : '?',
                          style: const TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: AppColors.primary,
                          ),
                        )
                      : null,
                ),
                title: Text(
                  user.name,
                  style: const TextStyle(
                    fontSize: 15,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                subtitle: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      user.email,
                      style: const TextStyle(
                        fontSize: 12,
                        color: AppColors.textSecondary,
                      ),
                    ),
                    const SizedBox(height: 4),
                    _buildAvailabilityIndicator(),
                  ],
                ),
                // Indicadores visuais e a√ß√µes
                trailing: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    // Indicador de compatibilidade (estrela)
                    if (isCompatible)
                      Container(
                        margin: const EdgeInsets.only(right: 4),
                        child: Icon(
                          Icons.star,
                          size: 16,
                          color: AppColors.warning,
                        ),
                      ),
                    // Contador de microtasks atribu√≠das
                    if (assignedMicrotasksCount > 0) _buildMicrotaskBadge(),
                    // Bot√£o de a√ß√µes
                    if (showActions && isManager)
                      IconButton(
                        icon: const Icon(Icons.more_vert),
                        onPressed: onShowActions,
                        tooltip: 'Mais op√ß√µes',
                      ),
                  ],
                ),
              ),

              // Informa√ß√µes do perfil (se dispon√≠vel)
              if (profile != null &&
                  (profile!.skills.isNotEmpty ||
                      profile!.resources.isNotEmpty ||
                      profile!.availableDays.isNotEmpty)) ...[
                const Divider(height: AppDimensions.spacingMd),
                _buildProfileInfo(),
              ],
            ],
          ),
        ),
      ),
    );
  }

  // Indicador de disponibilidade (exibido no subt√≠tulo)
  Widget _buildAvailabilityIndicator() {
    return Row(
      children: [
        Container(
          width: 8,
          height: 8,
          decoration: BoxDecoration(
            color: _getAvailabilityColor(),
            shape: BoxShape.circle,
          ),
        ),
        const SizedBox(width: 4),
        Expanded(
          child: Text(
            _getAvailabilityText(),
            style: TextStyle(
              fontSize: 11,
              color: _getAvailabilityColor(),
              fontWeight: FontWeight.w500,
            ),
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }

  // Badge de contagem de microtasks
  Widget _buildMicrotaskBadge() {
    final count = profile?.assignedMicrotasksCount ?? assignedMicrotasksCount;
    final color = _getMicrotaskBadgeColor(count);

    return Container(
      margin: const EdgeInsets.only(right: 4),
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.assignment, size: 12, color: color),
          const SizedBox(width: 2),
          Text(
            '$count',
            style: TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
        ],
      ),
    );
  }

  // Cor do badge baseada na carga de trabalho
  Color _getMicrotaskBadgeColor(int count) {
    if (count == 0) return AppColors.textSecondary;
    if (count < 3) return AppColors.success;
    if (count < 5) return AppColors.warning;
    return AppColors.error;
  }

  // Se√ß√£o de informa√ß√µes do perfil (Habilidades, Recursos, etc.)
  Widget _buildProfileInfo() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (profile!.availableDays.isNotEmpty) ...[
            _buildInfoRow(
              Icons.event_available_outlined,
              _buildAvailabilityChips(),
            ),
            const SizedBox(height: AppDimensions.spacingSm),
          ],
          if (profile!.skills.isNotEmpty) ...[
            _buildInfoRow(
              Icons.construction_outlined,
              _buildChips(profile!.skills, AppColors.primary),
            ),
            const SizedBox(height: AppDimensions.spacingSm),
          ],
          if (profile!.resources.isNotEmpty) ...[
            _buildInfoRow(
              Icons.build_circle_outlined,
              _buildChips(profile!.resources, AppColors.secondary),
            ),
          ],
        ],
      ),
    );
  }

  // Linha de informa√ß√£o gen√©rica (√çcone + Conte√∫do)
  Widget _buildInfoRow(IconData icon, Widget content) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(icon, size: 14, color: AppColors.textSecondary),
        const SizedBox(width: AppDimensions.spacingSm),
        Expanded(child: content),
      ],
    );
  }

  // Chips de dias dispon√≠veis
  Widget _buildAvailabilityChips() {
    return Wrap(
      spacing: 4,
      runSpacing: 4,
      children: profile!.availableDays.map((day) {
        return _buildChip(_getDayAbbreviation(day), AppColors.success);
      }).toList(),
    );
  }

  // Chips gen√©ricos para Habilidades e Recursos
  Widget _buildChips(List<String> items, Color color) {
    return Wrap(
      spacing: 4,
      runSpacing: 4,
      children: items.map((item) => _buildChip(item, color)).toList(),
    );
  }

  // Widget de chip customizado
  Widget _buildChip(String label, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Text(
        label,
        style: TextStyle(
          fontSize: 10,
          color: color,
          fontWeight: FontWeight.w500,
        ),
      ),
    );
  }

  // Fun√ß√µes de l√≥gica
  Color _getAvailabilityColor() {
    if (profile == null) return AppColors.warning;

    // Se disponibilidade integral est√° ativa, sempre verde
    if (profile!.isFullTimeAvailable) return AppColors.success;

    final now = DateTime.now();
    final currentDay = _getCurrentDayString(now);
    return profile!.availableDays.contains(currentDay)
        ? AppColors.success
        : AppColors.error;
  }

  String _getAvailabilityText() {
    if (profile == null) return 'Sem perfil';

    // Se disponibilidade integral est√° ativa
    if (profile!.isFullTimeAvailable) {
      return showDetailedAvailability
          ? 'Dispon√≠vel integral (qualquer hor√°rio)'
          : 'Dispon√≠vel integral';
    }

    final now = DateTime.now();
    final currentDay = _getCurrentDayString(now);
    final isAvailableToday = profile!.availableDays.contains(currentDay);

    if (showDetailedAvailability && profile!.availableHours.isValid()) {
      final hours =
          '${profile!.availableHours.start}-${profile!.availableHours.end}';
      return isAvailableToday ? 'Hoje: $hours' : 'Indispon√≠vel hoje ($hours)';
    }

    return isAvailableToday ? 'Dispon√≠vel hoje' : 'Indispon√≠vel hoje';
  }

  String _getCurrentDayString(DateTime date) {
    final weekdays = [
      'Segunda',
      'Ter√ßa',
      'Quarta',
      'Quinta',
      'Sexta',
      'S√°bado',
      'Domingo',
    ];
    return weekdays[date.weekday - 1];
  }

  String _getDayAbbreviation(String day) {
    const abbreviations = {
      'Segunda': 'Seg',
      'Ter√ßa': 'Ter',
      'Quarta': 'Qua',
      'Quinta': 'Qui',
      'Sexta': 'Sex',
      'S√°bado': 'S√°b',
      'Domingo': 'Dom',
    };
    return abbreviations[day] ?? day.substring(0, 3);
  }
}

## lib\core\utils\validators.dart <a id="validators_dart"></a>

### Dependencies

- `../constants/app_constants.dart`

import '../constants/app_constants.dart';

/// Classe utilit√°ria para valida√ß√µes de formul√°rios
class Validators {
  /// Valida se o email tem formato v√°lido
  static String? validateEmail(String? value) {
    if (value == null || value.isEmpty) {
      return 'E-mail √© obrigat√≥rio';
    }

    final emailRegex = RegExp(AppConstants.emailPattern);
    if (!emailRegex.hasMatch(value)) {
      return 'E-mail inv√°lido';
    }

    return null;
  }

  /// Valida senha
  static String? validatePassword(String? value) {
    if (value == null || value.isEmpty) {
      return 'Senha √© obrigat√≥ria';
    }

    if (value.length < AppConstants.passwordMinLength) {
      return 'Senha deve ter pelo menos ${AppConstants.passwordMinLength} caracteres';
    }

    if (value.length > AppConstants.passwordMaxLength) {
      return 'Senha deve ter no m√°ximo ${AppConstants.passwordMaxLength} caracteres';
    }

    return null;
  }

  /// Valida confirma√ß√£o de senha
  static String? validatePasswordConfirmation(String? value, String? password) {
    if (value == null || value.isEmpty) {
      return 'Confirma√ß√£o de senha √© obrigat√≥ria';
    }

    if (value != password) {
      return 'Senhas n√£o coincidem';
    }

    return null;
  }

  /// Valida nome
  static String? validateName(String? value) {
    if (value == null || value.isEmpty) {
      return 'Nome √© obrigat√≥rio';
    }

    if (value.length < AppConstants.nameMinLength) {
      return 'Nome deve ter pelo menos ${AppConstants.nameMinLength} caracteres';
    }

    if (value.length > AppConstants.nameMaxLength) {
      return 'Nome deve ter no m√°ximo ${AppConstants.nameMaxLength} caracteres';
    }

    return null;
  }

  /// Valida nome do evento
  static String? validateEventName(String? value) {
    if (value == null || value.isEmpty) {
      return 'Nome do evento √© obrigat√≥rio';
    }

    if (value.length < AppConstants.eventNameMinLength) {
      return 'Nome deve ter pelo menos ${AppConstants.eventNameMinLength} caracteres';
    }

    if (value.length > AppConstants.eventNameMaxLength) {
      return 'Nome deve ter no m√°ximo ${AppConstants.eventNameMaxLength} caracteres';
    }

    return null;
  }

  /// Valida descri√ß√£o do evento
  static String? validateEventDescription(String? value) {
    if (value != null && value.length > AppConstants.eventDescriptionMaxLength) {
      return 'Descri√ß√£o deve ter no m√°ximo ${AppConstants.eventDescriptionMaxLength} caracteres';
    }

    return null;
  }

  /// Valida localiza√ß√£o do evento
  static String? validateEventLocation(String? value) {
    if (value != null && value.length > AppConstants.eventLocationMaxLength) {
      return 'Localiza√ß√£o deve ter no m√°ximo ${AppConstants.eventLocationMaxLength} caracteres';
    }

    return null;
  }

  /// Valida c√≥digo/tag do evento
  static String? validateEventTag(String? value) {
    if (value == null || value.isEmpty) {
      return 'C√≥digo do evento √© obrigat√≥rio';
    }

    final tagRegex = RegExp(AppConstants.eventTagPattern);
    if (!tagRegex.hasMatch(value)) {
      return 'C√≥digo deve ter 6 caracteres alfanum√©ricos mai√∫sculos';
    }

    return null;
  }

  /// Valida nome da task
  static String? validateTaskName(String? value) {
    if (value == null || value.isEmpty) {
      return 'Nome da tarefa √© obrigat√≥rio';
    }

    if (value.length < AppConstants.taskNameMinLength) {
      return 'Nome deve ter pelo menos ${AppConstants.taskNameMinLength} caracteres';
    }

    if (value.length > AppConstants.taskNameMaxLength) {
      return 'Nome deve ter no m√°ximo ${AppConstants.taskNameMaxLength} caracteres';
    }

    return null;
  }

  /// Valida descri√ß√£o da task
  static String? validateTaskDescription(String? value) {
    if (value != null && value.length > AppConstants.taskDescriptionMaxLength) {
      return 'Descri√ß√£o deve ter no m√°ximo ${AppConstants.taskDescriptionMaxLength} caracteres';
    }

    return null;
  }

  /// Valida nome da microtask
  static String? validateMicrotaskName(String? value) {
    if (value == null || value.isEmpty) {
      return 'Nome da microtarefa √© obrigat√≥rio';
    }

    if (value.length < AppConstants.microtaskNameMinLength) {
      return 'Nome deve ter pelo menos ${AppConstants.microtaskNameMinLength} caracteres';
    }

    if (value.length > AppConstants.microtaskNameMaxLength) {
      return 'Nome deve ter no m√°ximo ${AppConstants.microtaskNameMaxLength} caracteres';
    }

    return null;
  }

  /// Valida descri√ß√£o da microtask
  static String? validateMicrotaskDescription(String? value) {
    if (value != null && value.length > AppConstants.microtaskDescriptionMaxLength) {
      return 'Descri√ß√£o deve ter no m√°ximo ${AppConstants.microtaskDescriptionMaxLength} caracteres';
    }

    return null;
  }

  /// Valida horas estimadas
  static String? validateEstimatedHours(String? value) {
    if (value == null || value.isEmpty) {
      return 'Horas estimadas s√£o obrigat√≥rias';
    }

    final hours = double.tryParse(value);
    if (hours == null) {
      return 'Valor inv√°lido';
    }

    if (hours < AppConstants.minEstimatedHours) {
      return 'M√≠nimo de ${AppConstants.minEstimatedHours} horas';
    }

    if (hours > AppConstants.maxEstimatedHours) {
      return 'M√°ximo de ${AppConstants.maxEstimatedHours} horas';
    }

    return null;
  }

  /// Valida se uma lista n√£o est√° vazia
  static String? validateRequiredList(List<dynamic>? value, String fieldName) {
    if (value == null || value.isEmpty) {
      return '$fieldName √© obrigat√≥rio';
    }

    return null;
  }

  /// Valida se um valor n√£o √© nulo nem vazio
  static String? validateRequired(String? value, String fieldName) {
    if (value == null || value.isEmpty) {
      return '$fieldName √© obrigat√≥rio';
    }

    return null;
  }
}

## lib\data\repositories\user_repository.dart <a id="user_repository_dart"></a>

### Dependencies

- `../../core/exceptions/app_exceptions.dart`
- `../models/user_model.dart`
- `../services/user_service.dart`

import '../../core/exceptions/app_exceptions.dart';
import '../models/user_model.dart';
import '../services/user_service.dart';

/// Reposit√≥rio respons√°vel por opera√ß√µes relacionadas a usu√°rios
/// Implementa o padr√£o Repository para abstrair o acesso aos dados
class UserRepository {
  final UserService _userService;

  UserRepository({UserService? userService})
      : _userService = userService ?? UserService();

  /// Busca um usu√°rio pelo ID
  Future<UserModel?> getUserById(String userId) async {
    try {
      if (userId.isEmpty) {
        throw ValidationException('ID do usu√°rio √© obrigat√≥rio');
      }

      return await _userService.getUserById(userId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao buscar usu√°rio: ${e.toString()}');
    }
  }

  /// Busca m√∫ltiplos usu√°rios pelos IDs
  Future<List<UserModel>> getUsersByIds(List<String> userIds) async {
    try {
      if (userIds.isEmpty) {
        return [];
      }

      return await _userService.getUsersByIds(userIds);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao buscar usu√°rios: ${e.toString()}');
    }
  }

  /// Busca usu√°rios por email
  Future<List<UserModel>> searchUsersByEmail(String emailQuery) async {
    try {
      if (emailQuery.isEmpty) {
        return [];
      }

      return await _userService.searchUsersByEmail(emailQuery);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao buscar usu√°rios por email: ${e.toString()}');
    }
  }

  /// Busca usu√°rios por nome
  Future<List<UserModel>> searchUsersByName(String nameQuery) async {
    try {
      if (nameQuery.isEmpty) {
        return [];
      }

      return await _userService.searchUsersByName(nameQuery);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao buscar usu√°rios por nome: ${e.toString()}');
    }
  }

  /// Atualiza informa√ß√µes do usu√°rio
  Future<UserModel> updateUser(UserModel user) async {
    try {
      return await _userService.updateUser(user);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao atualizar usu√°rio: ${e.toString()}');
    }
  }

  /// Cria ou atualiza um usu√°rio
  Future<UserModel> createOrUpdateUser(UserModel user) async {
    try {
      return await _userService.createOrUpdateUser(user);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao criar/atualizar usu√°rio: ${e.toString()}');
    }
  }

  /// Verifica se um usu√°rio existe
  Future<bool> userExists(String userId) async {
    try {
      if (userId.isEmpty) {
        return false;
      }

      return await _userService.userExists(userId);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao verificar exist√™ncia do usu√°rio: ${e.toString()}');
    }
  }

  /// Stream para monitorar mudan√ßas em um usu√°rio
  Stream<UserModel?> watchUser(String userId) {
    try {
      if (userId.isEmpty) {
        return Stream.value(null);
      }

      return _userService.watchUser(userId);
    } catch (e) {
      throw RepositoryException('Erro ao monitorar usu√°rio: ${e.toString()}');
    }
  }

  /// Busca usu√°rios recentes
  Future<List<UserModel>> getRecentUsers({int limit = 10}) async {
    try {
      return await _userService.getRecentUsers(limit: limit);
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao buscar usu√°rios recentes: ${e.toString()}');
    }
  }

  /// Busca usu√°rios com filtro combinado (nome ou email)
  Future<List<UserModel>> searchUsers(String query) async {
    try {
      if (query.isEmpty) {
        return [];
      }

      // Se cont√©m @, busca por email, sen√£o por nome
      if (query.contains('@')) {
        return await searchUsersByEmail(query);
      } else {
        return await searchUsersByName(query);
      }
    } catch (e) {
      if (e is AppException) rethrow;
      throw RepositoryException('Erro ao buscar usu√°rios: ${e.toString()}');
    }
  }
}

## lib\presentation\widgets\volunteer\volunteer_list_widget.dart <a id="volunteer_list_widget_dart"></a>

### Dependencies

- `package:flutter/material.dart`
- `../../../core/constants/app_colors.dart`
- `../../../core/constants/app_dimensions.dart`
- `../../../data/models/user_model.dart`
- `../../../data/models/volunteer_profile_model.dart`
- `volunteer_card.dart`

import 'package:flutter/material.dart';
import '../../../core/constants/app_colors.dart';
import '../../../core/constants/app_dimensions.dart';
import '../../../data/models/user_model.dart';
import '../../../data/models/volunteer_profile_model.dart';
import 'volunteer_card.dart';

/// Widget para exibir lista de volunt√°rios
class VolunteerListWidget extends StatelessWidget {
  final List<UserModel> volunteers;
  final List<VolunteerProfileModel> profiles;
  final Function(UserModel)? onVolunteerTap;
  final Function(UserModel)? onAssignMicrotask;
  final Function(UserModel)? onRemoveVolunteer;
  final Function(UserModel)? onPromoteToManager;
  final bool showActions;
  final bool isManager;
  final String? emptyMessage;
  final Widget? emptyWidget;
  final bool isLoading;

  const VolunteerListWidget({
    super.key,
    required this.volunteers,
    required this.profiles,
    this.onVolunteerTap,
    this.onAssignMicrotask,
    this.onRemoveVolunteer,
    this.onPromoteToManager,
    this.showActions = true,
    this.isManager = false,
    this.emptyMessage,
    this.emptyWidget,
    this.isLoading = false,
  });

  @override
  Widget build(BuildContext context) {
    if (isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (volunteers.isEmpty) {
      return emptyWidget ?? _buildEmptyState();
    }

    return ListView.builder(
      padding: const EdgeInsets.all(AppDimensions.paddingSm),
      itemCount: volunteers.length,
      itemBuilder: (context, index) {
        final volunteer = volunteers[index];
        final profile = _getVolunteerProfile(volunteer.id);

        return VolunteerCard(
          user: volunteer,
          profile: profile,
          isManager: true, // Supondo que esta tela seja para gerentes
          showActions: true,
          assignedMicrotasksCount: _getAssignedMicrotasksCount(volunteer.id),
          // A√ß√£o unificada que chama o novo di√°logo de op√ß√µes
          onShowActions: () => {},
        );
      },
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(AppDimensions.paddingLg),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.people_outline,
              size: 64,
              color: AppColors.textSecondary.withOpacity(0.5),
            ),
            const SizedBox(height: AppDimensions.spacingLg),
            Text(
              emptyMessage ?? 'Nenhum volunt√°rio encontrado',
              style: const TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.w600,
                color: AppColors.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }

  VolunteerProfileModel? _getVolunteerProfile(String userId) {
    try {
      return profiles.firstWhere((p) => p.userId == userId);
    } catch (e) {
      return null;
    }
  }

  int _getAssignedMicrotasksCount(String userId) {
    final profile = _getVolunteerProfile(userId);
    return profile?.assignedMicrotasksCount ?? 0;
  }
}

/// Widget compacto para lista de volunt√°rios em microtasks
class CompactVolunteerList extends StatelessWidget {
  final List<UserModel> volunteers;
  final int maxVolunteers;
  final Function(UserModel)? onVolunteerTap;
  final VoidCallback? onAddVolunteer;
  final Function(UserModel)? onRemoveVolunteer;
  final bool showAddButton;
  final bool showRemoveButton;

  const CompactVolunteerList({
    super.key,
    required this.volunteers,
    required this.maxVolunteers,
    this.onVolunteerTap,
    this.onAddVolunteer,
    this.onRemoveVolunteer,
    this.showAddButton = true,
    this.showRemoveButton = false,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Header com contador
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Volunt√°rios (${volunteers.length}/$maxVolunteers)',
              style: const TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.w600,
                color: AppColors.textPrimary,
              ),
            ),
            if (showAddButton && volunteers.length < maxVolunteers)
              IconButton(
                onPressed: onAddVolunteer,
                icon: const Icon(Icons.add),
                color: AppColors.primary,
                iconSize: 20,
              ),
          ],
        ),

        const SizedBox(height: AppDimensions.spacingSm),

        // Lista de volunt√°rios
        if (volunteers.isEmpty)
          Container(
            padding: const EdgeInsets.all(AppDimensions.paddingMd),
            decoration: BoxDecoration(
              color: AppColors.background,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: AppColors.border),
            ),
            child: const Row(
              children: [
                Icon(
                  Icons.person_add_outlined,
                  color: AppColors.textSecondary,
                  size: 20,
                ),
                SizedBox(width: AppDimensions.spacingSm),
                Text(
                  'Nenhum volunt√°rio atribu√≠do',
                  style: TextStyle(
                    fontSize: 14,
                    color: AppColors.textSecondary,
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ],
            ),
          )
        else
          ...volunteers.map((volunteer) => _buildVolunteerItem(volunteer)),
      ],
    );
  }

  Widget _buildVolunteerItem(UserModel volunteer) {
    return Container(
      margin: const EdgeInsets.only(bottom: AppDimensions.spacingSm),
      padding: const EdgeInsets.all(AppDimensions.paddingSm),
      decoration: BoxDecoration(
        color: AppColors.background,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: AppColors.border),
      ),
      child: Row(
        children: [
          // Avatar
          CircleAvatar(
            radius: 16,
            backgroundColor: AppColors.primary.withOpacity(0.1),
            backgroundImage: volunteer.photoUrl != null
                ? NetworkImage(volunteer.photoUrl!)
                : null,
            child: volunteer.photoUrl == null
                ? Text(
                    volunteer.name.isNotEmpty
                        ? volunteer.name[0].toUpperCase()
                        : '?',
                    style: const TextStyle(
                      fontSize: 14,
                      fontWeight: FontWeight.bold,
                      color: AppColors.primary,
                    ),
                  )
                : null,
          ),

          const SizedBox(width: AppDimensions.spacingSm),

          // Informa√ß√µes do volunt√°rio
          Expanded(
            child: GestureDetector(
              onTap: onVolunteerTap != null
                  ? () => onVolunteerTap!(volunteer)
                  : null,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    volunteer.name,
                    style: const TextStyle(
                      fontSize: 14,
                      fontWeight: FontWeight.w600,
                      color: AppColors.textPrimary,
                    ),
                  ),
                  Text(
                    volunteer.email,
                    style: const TextStyle(
                      fontSize: 12,
                      color: AppColors.textSecondary,
                    ),
                  ),
                ],
              ),
            ),
          ),

          // Bot√£o de remover
          if (showRemoveButton)
            IconButton(
              onPressed: onRemoveVolunteer != null
                  ? () => onRemoveVolunteer!(volunteer)
                  : null,
              icon: const Icon(Icons.remove_circle_outline),
              color: AppColors.error,
              iconSize: 20,
            ),
        ],
      ),
    );
  }
}

/// Widget para exibir avatares dos volunt√°rios em linha
class VolunteerAvatarList extends StatelessWidget {
  final List<UserModel> volunteers;
  final int maxVisible;
  final double avatarSize;
  final Function(UserModel)? onVolunteerTap;
  final VoidCallback? onShowAll;

  const VolunteerAvatarList({
    super.key,
    required this.volunteers,
    this.maxVisible = 3,
    this.avatarSize = 32,
    this.onVolunteerTap,
    this.onShowAll,
  });

  @override
  Widget build(BuildContext context) {
    if (volunteers.isEmpty) {
      return const SizedBox.shrink();
    }

    final visibleVolunteers = volunteers.take(maxVisible).toList();
    final remainingCount = volunteers.length - maxVisible;

    return Row(
      children: [
        ...visibleVolunteers.asMap().entries.map((entry) {
          final index = entry.key;
          final volunteer = entry.value;

          return Container(
            margin: EdgeInsets.only(left: index > 0 ? -8 : 0),
            child: GestureDetector(
              onTap: onVolunteerTap != null
                  ? () => onVolunteerTap!(volunteer)
                  : null,
              child: CircleAvatar(
                radius: avatarSize / 2,
                backgroundColor: AppColors.primary.withOpacity(0.1),
                backgroundImage: volunteer.photoUrl != null
                    ? NetworkImage(volunteer.photoUrl!)
                    : null,
                child: volunteer.photoUrl == null
                    ? Text(
                        volunteer.name.isNotEmpty
                            ? volunteer.name[0].toUpperCase()
                            : '?',
                        style: TextStyle(
                          fontSize: avatarSize * 0.4,
                          fontWeight: FontWeight.bold,
                          color: AppColors.primary,
                        ),
                      )
                    : null,
              ),
            ),
          );
        }),

        // Indicador de mais volunt√°rios
        if (remainingCount > 0)
          Container(
            margin: const EdgeInsets.only(left: -8),
            child: GestureDetector(
              onTap: onShowAll,
              child: CircleAvatar(
                radius: avatarSize / 2,
                backgroundColor: AppColors.textSecondary.withOpacity(0.2),
                child: Text(
                  '+$remainingCount',
                  style: TextStyle(
                    fontSize: avatarSize * 0.3,
                    fontWeight: FontWeight.bold,
                    color: AppColors.textSecondary,
                  ),
                ),
              ),
            ),
          ),
      ],
    );
  }
}

## lib\data\models\volunteer_profile_model.dart <a id="volunteer_profile_model_dart"></a>

### Dependencies

- `package:cloud_firestore/cloud_firestore.dart`

import 'package:cloud_firestore/cloud_firestore.dart';

/// Modelo de dados para representar o perfil de um volunt√°rio em um evento
/// Baseado na estrutura definida no SPEC_GERAL.md
/// Inclui dados denormalizados do usu√°rio para otimizar consultas
class VolunteerProfileModel {
  final String id;
  final String userId;
  final String eventId;
  final List<String> availableDays;
  final TimeRange availableHours;
  final bool
  isFullTimeAvailable; // Disponibilidade integral (sem restri√ß√µes de data/hora)
  final List<String> skills;
  final List<String> resources;
  final int assignedMicrotasksCount; // Contador de microtasks atribu√≠das
  final DateTime joinedAt;

  // Dados denormalizados do usu√°rio para otimiza√ß√£o de consultas
  final String userName;
  final String userEmail;
  final String? userPhotoUrl;

  const VolunteerProfileModel({
    required this.id,
    required this.userId,
    required this.eventId,
    required this.availableDays,
    required this.availableHours,
    required this.isFullTimeAvailable,
    required this.skills,
    required this.resources,
    required this.assignedMicrotasksCount,
    required this.joinedAt,
    required this.userName,
    required this.userEmail,
    this.userPhotoUrl,
  });

  /// Cria uma inst√¢ncia de VolunteerProfileModel a partir de um Map (JSON)
  factory VolunteerProfileModel.fromMap(Map<String, dynamic> map) {
    return VolunteerProfileModel(
      id: map['id'] as String,
      userId: map['userId'] as String,
      eventId: map['eventId'] as String,
      availableDays: List<String>.from(map['availableDays'] as List),
      availableHours: TimeRange.fromMap(
        map['availableHours'] as Map<String, dynamic>,
      ),
      isFullTimeAvailable: map['isFullTimeAvailable'] as bool? ?? false,
      skills: List<String>.from(map['skills'] as List),
      resources: List<String>.from(map['resources'] as List),
      assignedMicrotasksCount: map['assignedMicrotasksCount'] as int? ?? 0,
      joinedAt: (map['joinedAt'] as Timestamp).toDate(),
      userName: map['userName'] as String? ?? '',
      userEmail: map['userEmail'] as String? ?? '',
      userPhotoUrl: map['userPhotoUrl'] as String?,
    );
  }

  /// Cria uma inst√¢ncia de VolunteerProfileModel a partir de um DocumentSnapshot do Firestore
  factory VolunteerProfileModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return VolunteerProfileModel.fromMap({'id': doc.id, ...data});
  }

  /// Converte a inst√¢ncia para um Map (JSON)
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'userId': userId,
      'eventId': eventId,
      'availableDays': availableDays,
      'availableHours': availableHours.toMap(),
      'isFullTimeAvailable': isFullTimeAvailable,
      'skills': skills,
      'resources': resources,
      'assignedMicrotasksCount': assignedMicrotasksCount,
      'joinedAt': Timestamp.fromDate(joinedAt),
      'userName': userName,
      'userEmail': userEmail,
      'userPhotoUrl': userPhotoUrl,
    };
  }

  /// Converte para Map sem o ID (usado para criar documentos no Firestore)
  Map<String, dynamic> toFirestore() {
    final map = toMap();
    map.remove('id'); // Remove o ID pois ser√° gerado pelo Firestore
    return map;
  }

  /// Cria uma c√≥pia da inst√¢ncia com alguns campos alterados
  VolunteerProfileModel copyWith({
    String? id,
    String? userId,
    String? eventId,
    List<String>? availableDays,
    TimeRange? availableHours,
    bool? isFullTimeAvailable,
    List<String>? skills,
    List<String>? resources,
    int? assignedMicrotasksCount,
    DateTime? joinedAt,
    String? userName,
    String? userEmail,
    String? userPhotoUrl,
  }) {
    return VolunteerProfileModel(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      eventId: eventId ?? this.eventId,
      availableDays: availableDays ?? List<String>.from(this.availableDays),
      availableHours: availableHours ?? this.availableHours,
      isFullTimeAvailable: isFullTimeAvailable ?? this.isFullTimeAvailable,
      skills: skills ?? List<String>.from(this.skills),
      resources: resources ?? List<String>.from(this.resources),
      assignedMicrotasksCount:
          assignedMicrotasksCount ?? this.assignedMicrotasksCount,
      joinedAt: joinedAt ?? this.joinedAt,
      userName: userName ?? this.userName,
      userEmail: userEmail ?? this.userEmail,
      userPhotoUrl: userPhotoUrl ?? this.userPhotoUrl,
    );
  }

  /// Verifica se o volunt√°rio tem uma habilidade espec√≠fica
  bool hasSkill(String skill) {
    return skills.contains(skill);
  }

  /// Verifica se o volunt√°rio tem um recurso espec√≠fico
  bool hasResource(String resource) {
    return resources.contains(resource);
  }

  /// Verifica se o volunt√°rio est√° dispon√≠vel em um dia espec√≠fico
  bool isAvailableOnDay(String day) {
    return availableDays.contains(day);
  }

  /// Verifica se o volunt√°rio est√° dispon√≠vel em um hor√°rio espec√≠fico
  bool isAvailableAtTime(String time) {
    return availableHours.contains(time);
  }

  /// Adiciona uma habilidade ao perfil
  VolunteerProfileModel addSkill(String skill) {
    if (skills.contains(skill)) return this;

    final newSkills = List<String>.from(skills)..add(skill);
    return copyWith(skills: newSkills);
  }

  /// Remove uma habilidade do perfil
  VolunteerProfileModel removeSkill(String skill) {
    if (!skills.contains(skill)) return this;

    final newSkills = List<String>.from(skills)..remove(skill);
    return copyWith(skills: newSkills);
  }

  /// Adiciona um recurso ao perfil
  VolunteerProfileModel addResource(String resource) {
    if (resources.contains(resource)) return this;

    final newResources = List<String>.from(resources)..add(resource);
    return copyWith(resources: newResources);
  }

  /// Remove um recurso do perfil
  VolunteerProfileModel removeResource(String resource) {
    if (!resources.contains(resource)) return this;

    final newResources = List<String>.from(resources)..remove(resource);
    return copyWith(resources: newResources);
  }

  /// Adiciona um dia de disponibilidade
  VolunteerProfileModel addAvailableDay(String day) {
    if (availableDays.contains(day)) return this;

    final newDays = List<String>.from(availableDays)..add(day);
    return copyWith(availableDays: newDays);
  }

  /// Remove um dia de disponibilidade
  VolunteerProfileModel removeAvailableDay(String day) {
    if (!availableDays.contains(day)) return this;

    final newDays = List<String>.from(availableDays)..remove(day);
    return copyWith(availableDays: newDays);
  }

  /// Atualiza o hor√°rio de disponibilidade
  VolunteerProfileModel updateAvailableHours(TimeRange newHours) {
    return copyWith(availableHours: newHours);
  }

  /// Verifica compatibilidade com habilidades necess√°rias
  bool isCompatibleWithSkills(List<String> requiredSkills) {
    if (requiredSkills.isEmpty) return true;
    return requiredSkills.any((skill) => skills.contains(skill));
  }

  /// Verifica compatibilidade com recursos necess√°rios
  bool isCompatibleWithResources(List<String> requiredResources) {
    if (requiredResources.isEmpty) return true;
    return requiredResources.any((resource) => resources.contains(resource));
  }

  /// Verifica compatibilidade geral (habilidades E recursos)
  bool isCompatibleWith({
    List<String>? requiredSkills,
    List<String>? requiredResources,
  }) {
    final skillsMatch =
        requiredSkills == null ||
        requiredSkills.isEmpty ||
        isCompatibleWithSkills(requiredSkills);

    final resourcesMatch =
        requiredResources == null ||
        requiredResources.isEmpty ||
        isCompatibleWithResources(requiredResources);

    return skillsMatch && resourcesMatch;
  }

  /// Retorna as habilidades como string formatada
  String get skillsText {
    if (skills.isEmpty) return 'Nenhuma habilidade informada';
    return skills.join(', ');
  }

  /// Retorna os recursos como string formatada
  String get resourcesText {
    if (resources.isEmpty) return 'Nenhum recurso informado';
    return resources.join(', ');
  }

  /// Retorna os dias dispon√≠veis como string formatada
  String get availableDaysText {
    if (availableDays.isEmpty) return 'Nenhum dia informado';

    final dayNames = {
      'monday': 'Segunda',
      'tuesday': 'Ter√ßa',
      'wednesday': 'Quarta',
      'thursday': 'Quinta',
      'friday': 'Sexta',
      'saturday': 'S√°bado',
      'sunday': 'Domingo',
    };

    final translatedDays = availableDays
        .map((day) => dayNames[day] ?? day)
        .toList();

    return translatedDays.join(', ');
  }

  /// Retorna h√° quanto tempo o volunt√°rio se juntou ao evento
  String get joinedTimeAgo {
    final now = DateTime.now();
    final difference = now.difference(joinedAt);

    if (difference.inDays > 0) {
      return '${difference.inDays} dia${difference.inDays > 1 ? 's' : ''} atr√°s';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} hora${difference.inHours > 1 ? 's' : ''} atr√°s';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} minuto${difference.inMinutes > 1 ? 's' : ''} atr√°s';
    } else {
      return 'Agora mesmo';
    }
  }

  /// Factory para criar um novo perfil de volunt√°rio
  /// Note: ID e timestamp devem ser definidos pelo service
  factory VolunteerProfileModel.create({
    required String id,
    required String userId,
    required String eventId,
    required List<String> availableDays,
    required TimeRange availableHours,
    bool isFullTimeAvailable = false,
    required List<String> skills,
    required List<String> resources,
    int assignedMicrotasksCount = 0,
    required String userName,
    required String userEmail,
    String? userPhotoUrl,
    required DateTime joinedAt,
  }) {
    return VolunteerProfileModel(
      id: id,
      userId: userId,
      eventId: eventId,
      availableDays: availableDays,
      availableHours: availableHours,
      isFullTimeAvailable: isFullTimeAvailable,
      skills: skills,
      resources: resources,
      assignedMicrotasksCount: assignedMicrotasksCount,
      joinedAt: joinedAt,
      userName: userName,
      userEmail: userEmail,
      userPhotoUrl: userPhotoUrl,
    );
  }

  /// Factory para criar um perfil com dados do usu√°rio (para compatibilidade)
  /// Note: ID e timestamp devem ser definidos pelo service
  factory VolunteerProfileModel.createWithUserData({
    required String id,
    required String userId,
    required String eventId,
    required List<String> availableDays,
    required TimeRange availableHours,
    bool isFullTimeAvailable = false,
    required List<String> skills,
    required List<String> resources,
    int assignedMicrotasksCount = 0,
    required String userName,
    required String userEmail,
    String? userPhotoUrl,
    required DateTime joinedAt,
  }) {
    return VolunteerProfileModel.create(
      id: id,
      userId: userId,
      eventId: eventId,
      availableDays: availableDays,
      availableHours: availableHours,
      isFullTimeAvailable: isFullTimeAvailable,
      skills: skills,
      resources: resources,
      assignedMicrotasksCount: assignedMicrotasksCount,
      userName: userName,
      userEmail: userEmail,
      userPhotoUrl: userPhotoUrl,
      joinedAt: joinedAt,
    );
  }

  /// Atualiza os dados do usu√°rio no perfil
  VolunteerProfileModel updateUserData({
    required String userName,
    required String userEmail,
    String? userPhotoUrl,
  }) {
    return copyWith(
      userName: userName,
      userEmail: userEmail,
      userPhotoUrl: userPhotoUrl,
    );
  }

  /// Verifica se tem dados do usu√°rio v√°lidos
  bool get hasValidUserData {
    return userName.isNotEmpty && userEmail.isNotEmpty;
  }

  /// Retorna as iniciais do nome do usu√°rio
  String get userInitials {
    if (userName.isEmpty) return '';

    final words = userName.trim().split(' ');
    if (words.length == 1) {
      return words[0][0].toUpperCase();
    }

    return '${words[0][0]}${words[words.length - 1][0]}'.toUpperCase();
  }

  /// Retorna o primeiro nome do usu√°rio
  String get userFirstName {
    if (userName.isEmpty) return '';
    return userName.split(' ')[0];
  }

  /// Verifica se o usu√°rio tem foto de perfil
  bool get hasUserPhoto {
    return userPhotoUrl != null && userPhotoUrl!.isNotEmpty;
  }

  /// Valida se os dados do perfil s√£o v√°lidos
  bool isValid() {
    return id.isNotEmpty &&
        userId.isNotEmpty &&
        eventId.isNotEmpty &&
        (isFullTimeAvailable ||
            (availableDays.isNotEmpty && availableHours.isValid()));
  }

  /// M√©todo para validar dados antes de salvar
  List<String> validate() {
    final errors = <String>[];

    if (userId.isEmpty) {
      errors.add('ID do usu√°rio √© obrigat√≥rio');
    }

    if (eventId.isEmpty) {
      errors.add('ID do evento √© obrigat√≥rio');
    }

    if (!isFullTimeAvailable) {
      if (availableDays.isEmpty) {
        errors.add('Pelo menos um dia de disponibilidade √© obrigat√≥rio');
      }

      if (!availableHours.isValid()) {
        errors.add('Hor√°rio de disponibilidade inv√°lido');
      }
    }

    return errors;
  }

  /// Retorna a disponibilidade como string formatada
  String get availabilityText {
    if (isFullTimeAvailable) {
      return 'Disponibilidade integral (qualquer hor√°rio)';
    }

    if (availableDays.isEmpty) return 'Disponibilidade n√£o informada';

    return '$availableDaysText - ${availableHours.formatted}';
  }

  /// Verifica se o volunt√°rio est√° dispon√≠vel em um hor√°rio espec√≠fico
  bool isAvailableAt(DateTime dateTime) {
    if (isFullTimeAvailable) return true;

    // Verifica o dia da semana
    final dayNames = [
      'monday',
      'tuesday',
      'wednesday',
      'thursday',
      'friday',
      'saturday',
      'sunday',
    ];
    final dayOfWeek = dayNames[dateTime.weekday - 1];

    if (!availableDays.contains(dayOfWeek)) return false;

    // Verifica o hor√°rio
    final timeString =
        '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
    return availableHours.contains(timeString);
  }

  /// Verifica se o volunt√°rio est√° dispon√≠vel em um per√≠odo
  bool isAvailableForPeriod(DateTime startDateTime, DateTime endDateTime) {
    if (isFullTimeAvailable) return true;

    // Para simplicidade, verifica apenas o hor√°rio de in√≠cio
    // Em uma implementa√ß√£o mais robusta, verificaria todo o per√≠odo
    return isAvailableAt(startDateTime);
  }

  /// Incrementa o contador de microtasks atribu√≠das
  VolunteerProfileModel incrementAssignedMicrotasks() {
    return copyWith(assignedMicrotasksCount: assignedMicrotasksCount + 1);
  }

  /// Decrementa o contador de microtasks atribu√≠das
  VolunteerProfileModel decrementAssignedMicrotasks() {
    return copyWith(
      assignedMicrotasksCount: assignedMicrotasksCount > 0
          ? assignedMicrotasksCount - 1
          : 0,
    );
  }

  /// Atualiza o contador de microtasks atribu√≠das
  VolunteerProfileModel updateAssignedMicrotasksCount(int count) {
    return copyWith(assignedMicrotasksCount: count >= 0 ? count : 0);
  }

  /// Verifica se o volunt√°rio tem carga de trabalho baixa (menos de 3 microtasks)
  bool get hasLowWorkload => assignedMicrotasksCount < 3;

  /// Verifica se o volunt√°rio tem carga de trabalho alta (5 ou mais microtasks)
  bool get hasHighWorkload => assignedMicrotasksCount >= 5;

  /// Retorna o n√≠vel de carga de trabalho como string
  String get workloadLevel {
    if (assignedMicrotasksCount == 0) return 'Sem tarefas';
    if (assignedMicrotasksCount < 3) return 'Carga baixa';
    if (assignedMicrotasksCount < 5) return 'Carga m√©dia';
    return 'Carga alta';
  }

  /// Converte para string para debug
  @override
  String toString() {
    return 'VolunteerProfileModel(id: $id, userId: $userId, eventId: $eventId, skills: ${skills.length}, resources: ${resources.length})';
  }

  /// Implementa igualdade baseada no ID
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is VolunteerProfileModel && other.id == id;
  }

  /// Implementa hashCode baseado no ID
  @override
  int get hashCode => id.hashCode;
}

/// Classe para representar um intervalo de tempo
class TimeRange {
  final String start;
  final String end;

  const TimeRange({required this.start, required this.end});

  /// Cria uma inst√¢ncia de TimeRange a partir de um Map
  factory TimeRange.fromMap(Map<String, dynamic> map) {
    return TimeRange(start: map['start'] as String, end: map['end'] as String);
  }

  /// Converte a inst√¢ncia para um Map
  Map<String, dynamic> toMap() {
    return {'start': start, 'end': end};
  }

  /// Verifica se um hor√°rio est√° dentro do intervalo
  bool contains(String time) {
    // Implementa√ß√£o simplificada - pode ser melhorada
    return time.compareTo(start) >= 0 && time.compareTo(end) <= 0;
  }

  /// Verifica se o intervalo √© v√°lido
  bool isValid() {
    return start.isNotEmpty && end.isNotEmpty && start.compareTo(end) < 0;
  }

  /// Retorna o intervalo formatado
  String get formatted => '$start - $end';

  @override
  String toString() => formatted;

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is TimeRange && other.start == start && other.end == end;
  }

  @override
  int get hashCode => start.hashCode ^ end.hashCode;
}
## Code Visualization


### Architecture and Relationships

These diagrams visualize code relationships at different levels of abstraction.

### File Dependencies

This diagram shows dependencies between individual source files.

#

Below is a visualization of file dependencies in the codebase:

```mermaid
graph LR
  F1_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_SPEC_MY_ATUAL_BASE.md["SPEC_MY_ATUAL_BASE.md"]
  F2_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_.flattenignore[".flattenignore"]
  F3_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios_.gitignore[".gitignore"]
  F4_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_devtools_options.yaml["devtools_options.yaml"]
  F5_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\macos_.gitignore[".gitignore"]
  F6_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android_.gitignore[".gitignore"]
  F7_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\linux_.gitignore[".gitignore"]
  F8_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows_.gitignore[".gitignore"]
  F9_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_.gitignore[".gitignore"]
  F10_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\Runner\Assets.xcassets\LaunchImage.imageset_README.md["README.md"]
  F11_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\macos\Runner_AppDelegate.swift["AppDelegate.swift"]
  F12_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_main.cpp["main.cpp"]
  F13_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\Runner_AppDelegate.swift["AppDelegate.swift"]
  F14_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_README.md["README.md"]
  F15_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_flutter_window.cpp["flutter_window.cpp"]
  F16_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\Runner_GeneratedPluginRegistrant.h["GeneratedPluginRegistrant.h"]
  F17_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\Flutter\ephemeral_flutter_lldb_helper.py["flutter_lldb_helper.py"]
  F18_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\linux\flutter_generated_plugin_registrant.h["generated_plugin_registrant.h"]
  F19_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_flutter_window.h["flutter_window.h"]
  F20_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android\app\src\main\java\io\flutter\plugins_GeneratedPluginRegistrant.java["GeneratedPluginRegistrant.java"]
  F21_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\flutter_generated_plugin_registrant.h["generated_plugin_registrant.h"]
  F22_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\macos\Flutter_GeneratedPluginRegistrant.swift["GeneratedPluginRegistrant.swift"]
  F23_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android\app\src\main\kotlin\com\example\contask_MainActivity.kt["MainActivity.kt"]
  F24_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\macos\Runner_MainFlutterWindow.swift["MainFlutterWindow.swift"]
  F25_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\linux\runner_my_application.h["my_application.h"]
  F26_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_utils.cpp["utils.cpp"]
  F27_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_resource.h["resource.h"]
  F28_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\Runner_Runner-Bridging-Header.h["Runner-Bridging-Header.h"]
  F29_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\macos\RunnerTests_RunnerTests.swift["RunnerTests.swift"]
  F30_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_utils.h["utils.h"]
  F31_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\RunnerTests_RunnerTests.swift["RunnerTests.swift"]
  F32_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_win32_window.cpp["win32_window.cpp"]
  F33_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_win32_window.h["win32_window.h"]
  F34_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_CHECKLIST_DESENVOLVIMENTO.md["CHECKLIST_DESENVOLVIMENTO.md"]
  F35_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\.augment\rules_rule1.md["rule1.md"]
  F36_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_SPEC_GERAL.md["SPEC_GERAL.md"]
  F37_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_.cursorignore[".cursorignore"]
  F38_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\docs_volunteer_management_optimization_analysis.md["volunteer_management_optimization_analysis.md"]
  F39_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_TESTE_FASE2.md["TESTE_FASE2.md"]
  F40_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_TESTE_FASE3.md["TESTE_FASE3.md"]
  F41_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_TESTE_FASE3_AJUSTES.md["TESTE_FASE3_AJUSTES.md"]
  F42_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_alteracao_corrente["alteracao_corrente"]
  F43_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_.metadata[".metadata"]
  F44_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_analysis_options.yaml["analysis_options.yaml"]
  F45_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android\app\src\debug_AndroidManifest.xml["AndroidManifest.xml"]
  F46_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android\app\src\main_AndroidManifest.xml["AndroidManifest.xml"]
  F47_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\core\constants_app_colors.dart["app_colors.dart"]
  F48_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\core\constants_app_dimensions.dart["app_dimensions.dart"]
  F49_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\core\exceptions_app_exceptions.dart["app_exceptions.dart"]
  F50_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\core\constants_app_constants.dart["app_constants.dart"]
  F51_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android\app\src\profile_AndroidManifest.xml["AndroidManifest.xml"]
  F52_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\routes_app_routes.dart["app_routes.dart"]
  F53_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\core\constants_app_strings.dart["app_strings.dart"]
  F54_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\core\theme_app_theme.dart["app_theme.dart"]
  F55_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\dialogs_assignment_dialog.dart["assignment_dialog.dart"]
  F56_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\screens\assignment_assignment_screen.dart["assignment_screen.dart"]
  F57_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\services_assignment_service.dart["assignment_service.dart"]
  F58_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\repositories_auth_repository.dart["auth_repository.dart"]
  F59_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\controllers_auth_controller.dart["auth_controller.dart"]
  F60_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\services_auth_service.dart["auth_service.dart"]
  F61_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android\app_build.gradle.kts["build.gradle.kts"]
  F62_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\common_confirmation_dialog.dart["confirmation_dialog.dart"]
  F63_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\dialogs_confirmation_dialog.dart["confirmation_dialog.dart"]
  F64_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android_build.gradle.kts["build.gradle.kts"]
  F65_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\Runner\Assets.xcassets\LaunchImage.imageset_Contents.json["Contents.json"]
  F66_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\Runner\Assets.xcassets\AppIcon.appiconset_Contents.json["Contents.json"]
  F67_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\macos\Runner\Assets.xcassets\AppIcon.appiconset_Contents.json["Contents.json"]
  F68_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\screens\event_create_event_screen.dart["create_event_screen.dart"]
  F69_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\screens\task_create_microtask_screen.dart["create_microtask_screen.dart"]
  F70_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\screens\task_create_task_screen.dart["create_task_screen.dart"]
  F71_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\screens\event_create_tasks_screen.dart["create_tasks_screen.dart"]
  F72_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\common_custom_app_bar.dart["custom_app_bar.dart"]
  F73_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\common_custom_button.dart["custom_button.dart"]
  F74_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\common_custom_text_field.dart["custom_text_field.dart"]
  F75_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\core\utils_date_helpers.dart["date_helpers.dart"]
  F76_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\core\utils_error_handler.dart["error_handler.dart"]
  F77_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\common_error_message_widget.dart["error_message_widget.dart"]
  F78_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\common_error_widget.dart["error_widget.dart"]
  F79_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\event_event_card.dart["event_card.dart"]
  F80_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\controllers_event_controller.dart["event_controller.dart"]
  F81_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\screens\event_event_details_screen.dart["event_details_screen.dart"]
  F82_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\event_event_info_card.dart["event_info_card.dart"]
  F83_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\repositories_event_repository.dart["event_repository.dart"]
  F84_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\services_event_service.dart["event_service.dart"]
  F85_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\models_event_model.dart["event_model.dart"]
  F86_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\event_event_stats_widget.dart["event_stats_widget.dart"]
  F87_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib_firebase_options.dart["firebase_options.dart"]
  F88_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\Flutter\ephemeral_flutter_lldbinit["flutter_lldbinit"]
  F89_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_firebase.json["firebase.json"]
  F90_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\macos\Flutter\ephemeral_flutter_export_environment.sh["flutter_export_environment.sh"]
  F91_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\Flutter_flutter_export_environment.sh["flutter_export_environment.sh"]
  F92_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\core\utils_form_validators.dart["form_validators.dart"]
  F93_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\flutter_generated_plugin_registrant.cc["generated_plugin_registrant.cc"]
  F94_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\linux\flutter_generated_plugin_registrant.cc["generated_plugin_registrant.cc"]
  F95_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android\app_google-services.json["google-services.json"]
  F96_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android_gradlew["gradlew"]
  F97_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\screens\home_home_screen.dart["home_screen.dart"]
  F98_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\web_index.html["index.html"]
  F99_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android\app\src\main\res\drawable_launch_background.xml["launch_background.xml"]
  F100_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\screens\event_join_event_screen.dart["join_event_screen.dart"]
  F101_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android\app\src\main\res\drawable-v21_launch_background.xml["launch_background.xml"]
  F102_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\common_loading_widget.dart["loading_widget.dart"]
  F103_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\linux\runner_main.cc["main.cc"]
  F104_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib_main.dart["main.dart"]
  F105_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\web_manifest.json["manifest.json"]
  F106_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\screens\event_manage_volunteers_screen.dart["manage_volunteers_screen.dart"]
  F107_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\task_microtask_card.dart["microtask_card.dart"]
  F108_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\linux\runner_my_application.cc["my_application.cc"]
  F109_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\services_microtask_service.dart["microtask_service.dart"]
  F110_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\models_microtask_model.dart["microtask_model.dart"]
  F111_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\utils_migration_utils.dart["migration_utils.dart"]
  F112_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\repositories_microtask_repository.dart["microtask_repository.dart"]
  F113_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask_pubspec.yaml["pubspec.yaml"]
  F114_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android_settings.gradle.kts["settings.gradle.kts"]
  F115_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\common_skill_chip.dart["skill_chip.dart"]
  F116_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\event_skill_chip.dart["skill_chip.dart"]
  F117_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\core\utils_string_helpers.dart["string_helpers.dart"]
  F118_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android\app\src\main\res\values_styles.xml["styles.xml"]
  F119_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\android\app\src\main\res\values-night_styles.xml["styles.xml"]
  F120_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\models_task_model.dart["task_model.dart"]
  F121_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\controllers_task_controller.dart["task_controller.dart"]
  F122_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\task_task_progress_widget.dart["task_progress_widget.dart"]
  F123_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\task_task_card.dart["task_card.dart"]
  F124_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\repositories_task_repository.dart["task_repository.dart"]
  F125_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\services_task_service.dart["task_service.dart"]
  F126_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\screens\event_track_tasks_screen.dart["track_tasks_screen.dart"]
  F127_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\services_user_service.dart["user_service.dart"]
  F128_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\models_user_microtask_model.dart["user_microtask_model.dart"]
  F129_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\models_user_model.dart["user_model.dart"]
  F130_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\core\utils_validators.dart["validators.dart"]
  F131_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\volunteer_volunteer_card.dart["volunteer_card.dart"]
  F132_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\volunteer_volunteer_list_widget.dart["volunteer_list_widget.dart"]
  F133_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\repositories_user_repository.dart["user_repository.dart"]
  F134_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\data\models_volunteer_profile_model.dart["volunteer_profile_model.dart"]
  F12_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_main.cpp --> F19_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_flutter_window.h
  F12_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_main.cpp --> F30_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_utils.h
  F13_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\Runner_AppDelegate.swift --> F17_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\Flutter\ephemeral_flutter_lldb_helper.py
  F15_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_flutter_window.cpp --> F19_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_flutter_window.h
  F17_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\Flutter\ephemeral_flutter_lldb_helper.py --> F17_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\Flutter\ephemeral_flutter_lldb_helper.py
  F19_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_flutter_window.h --> F33_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_win32_window.h
  F26_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_utils.cpp --> F30_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_utils.h
  F30_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_utils.h --> F53_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\core\constants_app_strings.dart
  F31_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\RunnerTests_RunnerTests.swift --> F17_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\ios\Flutter\ephemeral_flutter_lldb_helper.py
  F32_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_win32_window.cpp --> F33_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_win32_window.h
  F32_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_win32_window.cpp --> F27_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_resource.h
  F33_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\runner_win32_window.h --> F53_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\core\constants_app_strings.dart
  F81_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\screens\event_event_details_screen.dart --> F106_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\screens\event_manage_volunteers_screen.dart
  F81_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\screens\event_event_details_screen.dart --> F126_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\screens\event_track_tasks_screen.dart
  F82_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\event_event_info_card.dart --> F115_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\common_skill_chip.dart
  F87_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib_firebase_options.dart --> F87_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib_firebase_options.dart
  F93_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\windows\flutter_generated_plugin_registrant.cc --> F18_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\linux\flutter_generated_plugin_registrant.h
  F94_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\linux\flutter_generated_plugin_registrant.cc --> F18_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\linux\flutter_generated_plugin_registrant.h
  F103_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\linux\runner_main.cc --> F25_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\linux\runner_my_application.h
  F104_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib_main.dart --> F87_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib_firebase_options.dart
  F108_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\linux\runner_my_application.cc --> F25_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\linux\runner_my_application.h
  F132_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\volunteer_volunteer_list_widget.dart --> F131_c:\Users\Pichau\Documents\victor_teste\projetoTCC\newContask2\contask\lib\presentation\widgets\volunteer_volunteer_card.dart
```

### Class Relationships

This diagram shows inheritance and associations between classes.

```mermaid
classDiagram
  class GeneratedPluginRegistrant
```


```mermaid
graph LR
A["Main"] --> B["Utils"]
```

<!-- TEST VISUALIZATION MARKER -->

```mermaid
graph LR
A["Main"] --> B["Utils"]
```
